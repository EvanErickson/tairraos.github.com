

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十八章：继承 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第十九章：进阶小技巧" href="19-the-goodies.html"/>
        <link rel="prev" title="第十七章：类和方法" href="17-classes-and-methods.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-functions.html">第三章：函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-case-study-interface-design.html">第四章：案例研究：接口设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-conditionals-and-recursion.html">第五章：条件和递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-files.html">第十四章：文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="17-classes-and-methods.html">第十七章：类和方法</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第十八章：继承</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">卡牌对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">类属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">比较卡牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">一副牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">打印一副牌</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">添加，移除，洗牌和排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">继承</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">类图</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">数据封装</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">习题18-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">习题18-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#poker">习题18-3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第十八章：继承</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第十八章：继承<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>最常与面向对象编程联系在一起的语言特性就是 <strong>继承</strong> 。继承指的是在现有类的基础下进行修改，从而定义新类的能力。在本章中，我会用表示卡牌（playing cards）、一副牌（deck of hands）和牌型（poker hands）的类，来展示继承这一特性。</p>
<p>如果你不玩扑克牌，你可以阅读 <a class="reference external" href="http://en.wikipedia.org/wiki/Poker">http://en.wikipedia.org/wiki/Poker</a> 了解一下，但这不是必须的；我会告诉你完成练习所需要了解的知识点。</p>
<p>本章的代码示例可以从 <a class="reference external" href="code/Card.py">http://thinkpython2.com/code/Card.py</a> 下载。</p>
<div class="section" id="id2">
<h2>卡牌对象<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>一副牌有52张牌，每一张属于4种花色的一个和13个等级的一个。
4种花色是黑桃（Spades），红心（Hearts），方块（Diamonds），梅花（Clubs），
以桥牌中的逆序排列。13个等级是A、2、3、4、5、6、7、8、9、10、J、Q、K。
根据你玩的游戏的不同，A 可能比 K 大或者比 2 小。</p>
<p>如果我们定义一个新的对象来表示卡牌，明显它应该有<code class="docutils literal notranslate"><span class="pre">rank</span></code>（等级） 和<code class="docutils literal notranslate"><span class="pre">suit</span></code>（花色）
两个属性。但两个属性的类型不太明显。一个可能是使用字符串类型，
如<code class="docutils literal notranslate"><span class="pre">'Spade'</span></code>表示花色，<code class="docutils literal notranslate"><span class="pre">'Queen'</span></code>表示等级。这种实现的一个问题是，不是那么容易比较牌的大小，看哪张牌的等级或花色更高。</p>
<p>另外一种方法，是使用一个整型来 <strong>编码</strong> 等级和花色。
在这里，“编码”表示我们要定义一个数字到花色或数字到等级的映射。
但是这里的编码并不是为了保密（那就成了“加密”）。</p>
<p>例如，下面的表格列出了花色和对应的整数码：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 53%" />
<col style="width: 14%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Spades</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>Hearts</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>Diamonds</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>Clubs</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>整数码使得很容易比较牌的大小；因为更高的花色对应更高的数字，我们可以通过比较数字，来判断花色的的大小。</p>
<p>等级的映射类型选择就显而易见；每个数字等级对应相应的整数，然后对于J，K，Q：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 56%" />
<col style="width: 18%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Jack</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>11</p></td>
</tr>
<tr class="row-even"><td><p>Queen</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>12</p></td>
</tr>
<tr class="row-odd"><td><p>King</p></td>
<td><p><span class="math">\mapsto</span></p></td>
<td><p>13</p></td>
</tr>
</tbody>
</table>
<p>这里，我使用<span class="math">\mapsto</span>符号来清楚的表示，这些不是 Python 程序的一部分。它们属于程序设计的一部分，但是不会出现在代码中。</p>
<p><code class="docutils literal notranslate"><span class="pre">Card</span></code>的类定义如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Card</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;代表一张标准的卡牌&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">=</span> <span class="n">suit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>
</pre></div>
</div>
<p>通常，init 方法接受针对每个属性的可选形参。默认的卡牌是梅花 2。</p>
<p>可以使用你需要的花色和等级调用 <code class="docutils literal notranslate"><span class="pre">Card</span></code> ，创建一个 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 对象。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">queen_of_diamonds</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>类属性<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>为了以大家能够轻松看懂的方式来打印卡牌对象，我们需要一个从整数码到对应的等级和花色的映射。
一种直接的方法是使用字符串列表。我们把这些列表赋值到<strong>类属性</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在Card类内部:</span>

    <span class="n">suit_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Clubs&#39;</span><span class="p">,</span> <span class="s1">&#39;Diamonds&#39;</span><span class="p">,</span> <span class="s1">&#39;Hearts&#39;</span><span class="p">,</span> <span class="s1">&#39;Spades&#39;</span><span class="p">]</span>
    <span class="n">rank_names</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Ace&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span>
              <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;Jack&#39;</span><span class="p">,</span> <span class="s1">&#39;Queen&#39;</span><span class="p">,</span> <span class="s1">&#39;King&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">rank_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span>
                             <span class="n">Card</span><span class="o">.</span><span class="n">suit_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">suit</span><span class="p">])</span>
</pre></div>
</div>
<p>像 <code class="docutils literal notranslate"><span class="pre">suit_names</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rank_names</span></code> 这样的变量，是定义在类内部但在方法之外，
被称为类属性。因为他们是被关联到 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 类对象上的。</p>
<p>这个术语将它们同 <code class="docutils literal notranslate"><span class="pre">suit</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rank</span></code> 这样的变量区分开来，后者被称为<strong>实例属性</strong>，
因为他们被关联到了特定的实例。</p>
<p>这两种属性都使用点标记法来访问。例如，在<code class="docutils literal notranslate"><span class="pre">__str__</span></code>中，<code class="docutils literal notranslate"><span class="pre">self</span></code> 是一个卡牌对
象，<code class="docutils literal notranslate"><span class="pre">self.rank</span></code> 是它的等级。
同样的，<code class="docutils literal notranslate"><span class="pre">Card</span></code> 是一个类对象，<code class="docutils literal notranslate"><span class="pre">Card.rank_names</span></code>是一个和类关联的字符串列表。</p>
<p>每一张卡牌都有自己的花色和等级，
但是这里只有一份<code class="docutils literal notranslate"><span class="pre">suit_names</span></code>和<code class="docutils literal notranslate"><span class="pre">rank_names</span></code>拷贝。</p>
<p>综合来说，表达式<code class="docutils literal notranslate"><span class="pre">Card.rank_names[self.rank]</span></code>表示“使用 <code class="docutils literal notranslate"><span class="pre">self</span></code> 对象
中的 <code class="docutils literal notranslate"><span class="pre">rank</span></code> 属性作为 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 类的<code class="docutils literal notranslate"><span class="pre">rank_names</span></code>列表的索引下标，然后获取相应的字符串。”</p>
<p><code class="docutils literal notranslate"><span class="pre">rank_names</span></code>的第一个元素是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，因为没有卡牌的等级是 0 。
通过使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为占位符，我们可以很好地将索引 2 映射到字符串<code class="docutils literal notranslate"><span class="pre">'2'</span></code>，等等。
为了避免使用这种小技巧，我们也可以使用一个字典来代替列表。</p>
<p>利用现有的方法，我们可以创建和打印卡牌：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">card1</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">card1</span><span class="p">)</span>
<span class="go">Jack of Hearts</span>
</pre></div>
</div>
<div class="figure align-default" id="id19">
<span id="fig-card1"></span><img alt="图18-1：对象图" src="_images/card1.png" />
<p class="caption"><span class="caption-text">图18-1：对象图</span><a class="headerlink" href="#id19" title="永久链接至图片">¶</a></p>
</div>
<p><a class="reference internal" href="#fig-card1"><span class="std std-ref">图18-1：对象图</span></a>是 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 类对象和一个 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 实例的图示。<code class="docutils literal notranslate"><span class="pre">Card</span></code> 是一个类对象；它的类型是 <code class="docutils literal notranslate"><span class="pre">type</span></code> 。<code class="docutils literal notranslate"><span class="pre">card1</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 的一个实例，因此它的类型是 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 。为了节省空间，我没有画出<code class="docutils literal notranslate"><span class="pre">suit_names</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rank_names</span></code>的内容。</p>
</div>
<div class="section" id="id4">
<h2>比较卡牌<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>对于内建类型，有关系运算符(&lt;, &gt;, ==, 等等)可以比较值，判断哪一个是大于、小于或等于另外一个。
对于程序员自定义的类型，我们可以通过提供一个叫 <code class="docutils literal notranslate"><span class="pre">__lt__</span></code>（代表“小于”）的方法，来覆盖内建运算符的行为。</p>
<p><code class="docutils literal notranslate"><span class="pre">__lt__</span></code>接受 2 个参数, <code class="docutils literal notranslate"><span class="pre">self</span></code> 和 <code class="docutils literal notranslate"><span class="pre">other</span></code>，如果 <code class="docutils literal notranslate"><span class="pre">self</span></code> 比 <code class="docutils literal notranslate"><span class="pre">other</span></code> 的值要小则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。</p>
<p>卡牌的正确顺序并不明显。例如，梅花 3 和方块 2 哪个更高？
一个等级更高，另一个花色更高。为了比较卡牌，你必须决定等级还是花色更重要。</p>
<p>答案可能根据你玩的是什么游戏而不同，但是简洁起见，我们将规定花色更重要，所以所有的黑桃大于任何方块卡牌，以此类推。</p>
<p>定好了这个规则后，我们可以编写<code class="docutils literal notranslate"><span class="pre">__lt__</span></code>了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在Card类内部:</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># 判断花色</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># 花色相同...判断等级</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span>
</pre></div>
</div>
<p>你可以使用元组比较来使得代码更加简洁：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在Card类内部:</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">return</span> <span class="n">t1</span> <span class="o">&lt;</span> <span class="n">t2</span>
</pre></div>
</div>
<p>我们做个练习，编写一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">__lt__</span></code> 方法。你可以使用元组比较，也可以考虑比较整数。</p>
</div>
<div class="section" id="id5">
<h2>一副牌<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>现在我们有 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 类了，下一步是定义完整的一副牌（Deck）了。因为一副牌由许多牌组成，自然地
每一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 都有一个卡牌列表作为属性。</p>
<p>下面是一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 的类定义。初始化方法创建了 <code class="docutils literal notranslate"><span class="pre">cards</span></code> 属性，然后生成了由52张牌组成一副标准卡牌。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">suit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">):</span>
                <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">suit</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
</pre></div>
</div>
<p>生成一副牌的最简单方法是使用嵌套循环。外层循环枚举 0 到 3 的花色。内层循环枚举 1 到 13
的等级。每一个迭代都用当前的花色和等级创建一张新的牌。然后放入 <code class="docutils literal notranslate"><span class="pre">self.cards</span></code> 中。</p>
</div>
<div class="section" id="id6">
<h2>打印一副牌<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>下面是为 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 定义的 <code class="docutils literal notranslate"><span class="pre">__str__</span></code> 方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deck类的内部</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></div>
</div>
<p>这个方法展示了累积大字符串的高效方法：建立一个字符串列表然后使用字符串方法 <code class="docutils literal notranslate"><span class="pre">join</span></code> 。
内建函数 <code class="docutils literal notranslate"><span class="pre">str</span></code> 会调用每个卡牌上的<code class="docutils literal notranslate"><span class="pre">__str__</span></code>方法，并返回它们的字符串表示。</p>
<p>由于我们是在一个换行符上调用的 <code class="docutils literal notranslate"><span class="pre">join</span></code> ，卡牌之间被换行符分隔。下面是结果示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deck</span> <span class="o">=</span> <span class="n">Deck</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">deck</span><span class="p">)</span>
<span class="go">Ace of Clubs</span>
<span class="go">2 of Clubs</span>
<span class="go">3 of Clubs</span>
<span class="gp">...</span>
<span class="go">10 of Spades</span>
<span class="go">Jack of Spades</span>
<span class="go">Queen of Spades</span>
<span class="go">King of Spades</span>
</pre></div>
</div>
<p>虽然这个结果有52行，但他实际上是包含换行符的一个长字符串。</p>
</div>
<div class="section" id="id7">
<h2>添加，移除，洗牌和排序<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>为了发牌，我们需要一个可以把卡牌从一副牌中移除并返回的方法。
列表的 <code class="docutils literal notranslate"><span class="pre">pop</span></code> 方法提供了一个便捷的实现：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deck类的内部</span>

    <span class="k">def</span> <span class="nf">pop_card</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>Since pop removes the <em>last</em> card in the list, we are dealing from the
bottom of the deck.</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">pop</span></code> 移除列表的 <strong>最后一张</strong> 卡牌，所以我们从牌底开始发牌。</p>
<p>我们可以使用列表的 <code class="docutils literal notranslate"><span class="pre">append</span></code> 方法，添加一张卡牌：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deck类的内部</span>

    <span class="k">def</span> <span class="nf">add_card</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
</pre></div>
</div>
<p>像上面这样利用别的方法（method），自己却没有做太多处理的方法，有时候被称为 <strong>伪装方法（veneer）</strong> 。
这个隐喻来源于木工行业，他们通常用一片高质量的木质薄层粘贴在一块便宜木材的表面，改善外观形象。</p>
<p>在这里，<code class="docutils literal notranslate"><span class="pre">add_card</span></code> 是一个“瘦”方法，以卡牌的术语来表述一个列表操作。它改善了实现的外观，或者说接口。</p>
<p>再举一个例子，我们可以用 <code class="docutils literal notranslate"><span class="pre">random</span></code> 模块中的
<code class="docutils literal notranslate"><span class="pre">shuffle</span></code> 函数，给 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 写一个叫 <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> 的方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deck类的内部</span>

    <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>
</pre></div>
</div>
<p>不要忘记了导入 <code class="docutils literal notranslate"><span class="pre">random</span></code> 。</p>
<p>我们做个练习，用列表的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 方法来写一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 的 <code class="docutils literal notranslate"><span class="pre">sort</span></code> 方法，给卡牌排序。
<code class="docutils literal notranslate"><span class="pre">sort</span></code>使用我们定义的<code class="docutils literal notranslate"><span class="pre">__cmp__</span></code>来决定排序顺序。</p>
</div>
<div class="section" id="id8">
<h2>继承<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>继承指的是在现有类的基础下进行修改，从而定义新类的能力。例如，假设我们想定义一个类来代表手牌（hand），即玩家目前手里有的牌。手牌与一副牌（deck）类似：二者都由卡牌组成，都要求支持添加和移除卡牌的操作。</p>
<p>但二者也有区别；有些我们希望手牌具备的操作，对于 deck 来说并不合理。例如，在扑克牌中，我们可能需要比较两个手牌，比较哪方赢了。在桥牌中，我们可能需要计算手牌的得分，才好下注。</p>
<p>类之间有相似之处，但也存在不同，这时就可以用上继承了。你只需要在定义新类时，将现有类的名称放在括号里，即可继承现有类：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Hand</span><span class="p">(</span><span class="n">Deck</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a hand of playing cards.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>这个定义表明，<code class="docutils literal notranslate"><span class="pre">Hand</span></code> 继承自 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> ；这意味着我们也可以对 <code class="docutils literal notranslate"><span class="pre">Hands</span></code> 使用 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 的<code class="docutils literal notranslate"><span class="pre">pop_card</span></code>和<code class="docutils literal notranslate"><span class="pre">add_card</span></code>方法。</p>
<p>当一个新类继承自一个现有类时，现有类被称为 <strong>父类</strong> ，新类被称为 <strong>子类</strong> 。</p>
<p>在此例中，<code class="docutils literal notranslate"><span class="pre">Hand</span></code> 继承了 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 的<code class="docutils literal notranslate"><span class="pre">__init__</span></code>方法，但是它并没有满足我们的要求：init 方法应该为 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 初始化一个空的 <code class="docutils literal notranslate"><span class="pre">cards</span></code> 列表，而不是往手牌里添加 52 张新牌。</p>
<p>如果我们提供一个 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 的 init 方法，它会覆盖从 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 类继承来的同名方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Hand 类的内部</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
</pre></div>
</div>
<p>当你创建一个 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 时，Python 会调用这个 init 方法，而不是 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 中的同名方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="s1">&#39;new hand&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hand</span><span class="o">.</span><span class="n">cards</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hand</span><span class="o">.</span><span class="n">label</span>
<span class="go">&#39;new hand&#39;</span>
</pre></div>
</div>
<p>其它方法是从 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 继承来的，所以我们可以使用<code class="docutils literal notranslate"><span class="pre">pop_card</span></code> 和
<code class="docutils literal notranslate"><span class="pre">add_card</span></code>来发牌：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deck</span> <span class="o">=</span> <span class="n">Deck</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">card</span> <span class="o">=</span> <span class="n">deck</span><span class="o">.</span><span class="n">pop_card</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hand</span><span class="o">.</span><span class="n">add_card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hand</span><span class="p">)</span>
<span class="go">King of Spades</span>
</pre></div>
</div>
<p>很自然地，下一步就是把这些代码封装进一个叫<code class="docutils literal notranslate"><span class="pre">move_cards</span></code>的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Deck类的内部</span>

    <span class="k">def</span> <span class="nf">move_cards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hand</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">hand</span><span class="o">.</span><span class="n">add_card</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_card</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">move_cards</span></code>接受两个参数，一个是 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 对象，另一个是发牌的数量。
它会同时修改 <code class="docutils literal notranslate"><span class="pre">self</span></code> 和 <code class="docutils literal notranslate"><span class="pre">hand</span></code> ，然后返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>在有些游戏里面，卡牌从一个手牌移动到另外一个手牌，或者从手牌退还到牌堆里面。
任何这些操作都可以使用 <code class="docutils literal notranslate"><span class="pre">move_cards</span></code>：<code class="docutils literal notranslate"><span class="pre">self</span></code> 可以是一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 或者一个 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> ，而且尽管名字叫 <code class="docutils literal notranslate"><span class="pre">hand</span></code> ，它也可以是一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 。</p>
<p>继承是一个非常有用的特性。有了继承，一些重复性的代码可以写得非常的优雅。
继承有助于代码重用，因为你可以在不修改父类定义的前提下，就改变父类的行为。
在有些情况下，继承的结构反映了真实问题的结构，使得程序更易于理解。</p>
<p>另一方面，继承又有可能会使得程序更加难读。
当调用一个方法时，有时候搞不清楚去哪找它的定义。
相关的代码可能被分散在几个模块之中。
而且，许多用继承能完成的事情，不用继承也可以完成，有可能还完成得更好。</p>
</div>
<div class="section" id="id9">
<h2>类图<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>到目前为止我们已经了解过栈图，它显示的是一个程序的状态；以及对象图，它显示的是一个对象的属性及其值。这些图代表了程序执行中的一个快照，所以它们随着程序的运行而变化。</p>
<p>它们也十分的详细；但有些时候显得过于详细了。类图是程序结构的一种更加抽象的表达。
它显示的是类和类之间的关系，而不是每个独立的对象。</p>
<p>类之间有如下几种关系：</p>
<ul class="simple">
<li><p>一个类中的对象可以包含对另外一个类的对象的引用。例如，每一个矩形包含对点的引用，每一个 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 包含对许多 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 的引用。这种关系被称为组合( <strong>HAS-A</strong> )，可以类似这样描述：“一个矩形有一个（has a）点”。</p></li>
<li><p>一个类可能继承自另外一个类。这种关系被称为继承(<strong>IS-A</strong>)，可以类似这样描述：“Hand is a kind of Deck”。</p></li>
<li><p>一个类可能强赖另一个类，因为前者中的对象接受后者中的对象作为参数，或者使用后者中的对象作为计算的一部分。这种关系被称为 <strong>依赖</strong> 。</p></li>
</ul>
<p>类图是这些关系的图形化表示。例如，<a class="reference internal" href="#fig-class1"><span class="std std-ref">图18-2：类图</span></a>标明了 <code class="docutils literal notranslate"><span class="pre">Card</span></code> ， <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 和
<code class="docutils literal notranslate"><span class="pre">Hand</span></code> 之间的关系。</p>
<div class="figure align-default" id="id20">
<span id="fig-class1"></span><img alt="图18-2：类图" src="_images/class1.png" />
<p class="caption"><span class="caption-text">图18-2：类图</span><a class="headerlink" href="#id20" title="永久链接至图片">¶</a></p>
</div>
<p>带空心三角的箭头表示 IS-A 的关系；这里它表示 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 继承自 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 。</p>
<p>标准箭头表示 HAS-A 的关系；这里表示 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 包含对 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 对象的引用。</p>
<p>箭头旁边的星号是一个复数（ <strong>multiplicity</strong> ）表达；它表示 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 包含多少个 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 。一个复数表达可以是一个简单的数字(如 52 )，一个范围（如5..7）或者是*，表示有任意数量的 <code class="docutils literal notranslate"><span class="pre">Card</span></code> 。</p>
<p>上图中没有标出依赖关系。这种关系通常使用虚线箭头表示。或者，如果有很多依赖关系的话，有时候会省略。</p>
<p>一个更详细的类图可能会显示 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 实际包含了一个由 <code class="docutils literal notranslate"><span class="pre">Cards</span></code> 组成的列表，但是通常类图中不会包含 <code class="docutils literal notranslate"><span class="pre">list</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 等内建类型。</p>
</div>
<div class="section" id="id10">
<h2>数据封装<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>前面几章中描述了一种可以称为”面向对象设计“的开发计划。我们确定所需要的对象 —— 如``Point`` 、 <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code> 和  <code class="docutils literal notranslate"><span class="pre">Time</span></code> —— 然后定义代表它们的类。
对于每个类来说，这个类对象和真实世界（或至少是数学世界）中的某种实体具有明显的对应关系。</p>
<p>但是有时有很难界定你需要的对象以及它们如何交互。在这个时候，你需要一个不同的开发计划。之前我们通过封装和泛化来编写函数接口，我们同样可以通过 <strong>数据封装</strong> 来编写类接口。</p>
<p><a class="reference internal" href="13-case-study-data-structure-selection.html#markov"><span class="std std-ref">马尔科夫分析</span></a>一节中介绍的马尔科夫分析就是一个很好的例子。如果你从<a class="reference external" href="code/markov.py">http://thinkpython2.com/code/markov.py</a> 下载我的代码，你会发现它使用了两个全局变量 —— <code class="docutils literal notranslate"><span class="pre">suffix_map</span></code>和<code class="docutils literal notranslate"><span class="pre">prefix</span></code>，它们被多个函数进行读写。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">suffix_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">prefix</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
<p>因为这些变量是全局的，我们一次只能运行一个分析。如果我们读取了两个文本，
它们的前缀和后缀会被加入相同的数据结构（会使得输出文本混乱）。</p>
<p>如果想同时运行多个分析，并且保持它们的相互独立，我们可以把每个分析的状态封装到一个对象中。
下面是一个示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Markov</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
<p>下一步，我们把这些函数转换为方法。例如：下面是<code class="docutils literal notranslate"><span class="pre">process_word</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_word</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+=</span> <span class="p">(</span><span class="n">word</span><span class="p">,)</span>
        <span class="k">return</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># if there is no entry for this prefix, make one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</pre></div>
</div>
<p>像这样改变一个程序 —— 改变设计而保持功能不变 —— 是代码重构的另一个例子（参见<a class="reference internal" href="04-case-study-interface-design.html#refactoring"><span class="std std-ref">重构</span></a>一节）。</p>
<p>下面的例子给出了一种设计对象和方法的开发计划：</p>
<ol class="arabic simple">
<li><p>首先编写读取全局变量的函数（如有必要）。</p></li>
<li><p>一旦你让程序跑起来了，开始查找全局变量和使用它们的函数的联系。</p></li>
<li><p>封装相关的变量作为一个对象的属性。</p></li>
<li><p>转换相关函数为新类的方法。</p></li>
</ol>
<p>我们做个练习，从 <a class="reference external" href="code/markov.py">http://thinkpython2.com/code/markov.py</a> 下载我的马尔科夫分析代码，然后按照上面所述的步骤，将全局变量封装为新类 <code class="docutils literal notranslate"><span class="pre">Markov</span></code> （注意M为大写）的属性。</p>
</div>
<div class="section" id="id11">
<h2>调试<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>继承会使得调试变得更加复杂，因为你可能不知道实际调用的是哪个类的方法。</p>
<p>假设你在写一个处理 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 对象的函数。你可能会想让它可以处理所有种类的 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> ，如 <code class="docutils literal notranslate"><span class="pre">PockerHands</span></code> ，<code class="docutils literal notranslate"><span class="pre">BridgeHands</span></code> ，等等。如果你调用类似 <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> 这样的方法，你可能会得到 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 中定义的那个，
但是如果有任何一个子类覆盖了这个方法。你实际上得到的是子类的那个方法。这个行为通常是一件好事，但是容易让人混淆。</p>
<p>只要你不确定程序的执行流程，最简单的方法是在相关方法的开始处添加 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语
句。如果 <code class="docutils literal notranslate"><span class="pre">Deck.shuffle</span></code> 打印一条如像 <code class="docutils literal notranslate"><span class="pre">Running</span> <span class="pre">Deck.shuffle</span></code> 的消息，那么随着程序的运行，它会追踪执行的流程。</p>
<p>另外一种方法是使用下面的函数，它接受一个对象和一个方法的名字（字符串格式）作
为参数，然后返回提供这个方法定义的类：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_defining_class</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">meth_name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">meth_name</span> <span class="ow">in</span> <span class="n">ty</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ty</span>
</pre></div>
</div>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_defining_class</span><span class="p">(</span><span class="n">hand</span><span class="p">,</span> <span class="s1">&#39;shuffle&#39;</span><span class="p">)</span>
<span class="go">&lt;class &#39;Card.Deck&#39;&gt;</span>
</pre></div>
</div>
<p>所以 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 的 <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> 方法是来自于 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 的。</p>
<p><code class="docutils literal notranslate"><span class="pre">find_defining_class</span></code>使用 <code class="docutils literal notranslate"><span class="pre">mro</span></code> 方法获得将类对象（类型）的列表，
解释器将会从这里依次搜索哪个类提供了这个方法。“MOR”是“method resolution order”的简称，指的是Python “解析” 方法名时将搜索的一个类序列。</p>
<p>我提一个对程序设计的建议：当你覆盖一个方法时，新方法的接口应该与旧方法保持一致。
它们应该接受相同的参数，返回相同的类型，遵守相同的先决条件和后置条件。
如果你遵循这个原则，你会发现：任何你设计的函数，只要能用于一个父类的对象（
如 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> ），就能够用于任何子类的实例（如 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PockerHand</span></code> ）。</p>
<p>如果你违背这条规则（该原则被称为“里氏代换原理”，英文为：Liskov substitution
principle），你的代码逻辑就会变得乱七八糟。</p>
</div>
<div class="section" id="id12">
<h2>术语表<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>编码（encode）：</p>
<blockquote>
<div><p>利用另一组值代表一组值，方法时构建二者之间的映射。</p>
</div></blockquote>
<p>类属性（class attribute）：</p>
<blockquote>
<div><p>与类对象相关联的属性。类属性定义在类定义的内部，但在方法的外部。</p>
</div></blockquote>
<p>实例属性（instance attribute）：</p>
<blockquote>
<div><p>与类的实例相关联的属性。</p>
</div></blockquote>
<p>伪装方法（veneer）：</p>
<blockquote>
<div><p>提供另一个函数的不同接口，但不做太多计算的函数或方法。</p>
</div></blockquote>
<p>继承（inheritance）：</p>
<blockquote>
<div><p>在此前定义的类的基础下进行修改，从而定义一个新类的能力。</p>
</div></blockquote>
<p>父类（parent class）：</p>
<blockquote>
<div><p>子类所继承自的类。</p>
</div></blockquote>
<p>子类（child class）：</p>
<blockquote>
<div><p>通过继承一个现有类创建的新类。</p>
</div></blockquote>
<p>IS-A 关系：</p>
<blockquote>
<div><p>子类和父类之间的关系。</p>
</div></blockquote>
<p>HAS-A 关系：</p>
<blockquote>
<div><p>两个类之中，有一个类包含对另一个类的实例的引用的关系。</p>
</div></blockquote>
<p>依赖（dependency）：</p>
<blockquote>
<div><p>两个类之中，一个类的实例使用了另一个类的实例，但没有将其保存为属性的关系。</p>
</div></blockquote>
<p>类图（class diagram）：</p>
<blockquote>
<div><p>表明程序中包含的类及其之间的关系的图示。</p>
</div></blockquote>
<p>复数（multiplicity）：</p>
<blockquote>
<div><p>类图中的一种标记，表明在 HAS-A 关系中，某个对包含了多少个对另一个类实例的引用。</p>
</div></blockquote>
<p>数据封装（data encapsulation）：</p>
<blockquote>
<div><p>一种程序开发计划，包括首先编写一个使用全局变量的原型，然后再讲全局变量变成实例属性的最终版代码。</p>
</div></blockquote>
</div>
<div class="section" id="id13">
<h2>练习题<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>习题18-1<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>针对以下程序，画一个 UML 类图，说明其中包含的类及其之间的关系。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PingPongParent</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Ping</span><span class="p">(</span><span class="n">PingPongParent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pong</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pong</span> <span class="o">=</span> <span class="n">pong</span>


<span class="k">class</span> <span class="nc">Pong</span><span class="p">(</span><span class="n">PingPongParent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pings</span> <span class="o">=</span> <span class="n">pings</span>

    <span class="k">def</span> <span class="nf">add_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ping</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ping</span><span class="p">)</span>

<span class="n">pong</span> <span class="o">=</span> <span class="n">Pong</span><span class="p">()</span>
<span class="n">ping</span> <span class="o">=</span> <span class="n">Ping</span><span class="p">(</span><span class="n">pong</span><span class="p">)</span>
<span class="n">pong</span><span class="o">.</span><span class="n">add_ping</span><span class="p">(</span><span class="n">ping</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>习题18-2<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>为 <code class="docutils literal notranslate"><span class="pre">Deck</span></code> 编写一个叫 <code class="docutils literal notranslate"><span class="pre">deal_hands</span></code> 的方法，接受两个参数：手牌的数量以及每个手牌的卡牌数。它应该创建相应数量的 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> 对象，给每个手牌发放相应数量的卡牌，然后返回一个 <code class="docutils literal notranslate"><span class="pre">Hands</span></code> 列表。</p>
<p>下面是扑克牌中可能的手牌（牌型），越往下值越大，几率越低：</p>
<p>对牌：</p>
<blockquote>
<div><p>两张相同牌面的牌</p>
</div></blockquote>
<p>两对牌：</p>
<blockquote>
<div><p>两对相同牌面的牌</p>
</div></blockquote>
<p>三条：</p>
<blockquote>
<div><p>三张等级相同的牌</p>
</div></blockquote>
<p>顺子：</p>
<blockquote>
<div><p>五张连续的牌（A可高可低。如A-2-3-4-5是一个顺子,10-J-Q-K-A也
是。但是Q-K-A-2-3就不是）</p>
</div></blockquote>
<p>同花：</p>
<blockquote>
<div><p>五张花色一样的牌</p>
</div></blockquote>
<p>三代二：</p>
<blockquote>
<div><p>三张等级一样的牌，另外两张等级一样的牌</p>
</div></blockquote>
<p>四条：</p>
<blockquote>
<div><p>四张牌面一样的牌</p>
</div></blockquote>
<p>同花顺：</p>
<blockquote>
<div><p>五张花色相同的等级连续的牌</p>
</div></blockquote>
</div>
<div class="section" id="poker">
<span id="id16"></span><h3>习题18-3<a class="headerlink" href="#poker" title="永久链接至标题">¶</a></h3>
<p>下面这些习题的目的，是估算抽到不同手牌的几率。</p>
<ol class="arabic">
<li><p>从<a class="reference external" href="code">http://thinkpython2.com/code</a> 页面下载以下文件：</p>
<dl class="simple">
<dt>Card.py</dt><dd><p>: 本章中完整版本的Card , Deck和Hand类。</p>
</dd>
<dt>PokerHand.py</dt><dd><p>: 代表 poker hand 的不完整的实现，和一些测试代码。</p>
</dd>
</dl>
</li>
<li><p>如果你运行 <code class="docutils literal notranslate"><span class="pre">PokerHand.py</span></code> ,它会发放 7 张牌的 poker hand，检查是否含有顺子。仔细阅读代码，再继续下面的内容。</p></li>
<li><p>往 <code class="docutils literal notranslate"><span class="pre">PokerHand.py</span></code> 文件中添加叫做 <code class="docutils literal notranslate"><span class="pre">has_pair</span></code> 、 <code class="docutils literal notranslate"><span class="pre">has_twopair</span></code> 等方法，这些方法根据手牌是否满足相应的标准来返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。你的代码应该可以正确地处理包含任意卡牌数量（虽然 5 和 7 是最常见的数量）的手牌。</p></li>
<li><p>写一个叫 <code class="docutils literal notranslate"><span class="pre">classify</span></code> 的方法，计算出一个手牌的最高值分类，然后设置对应的 <code class="docutils literal notranslate"><span class="pre">label</span></code> 属性。例如，一个 7 张牌的手牌可能包含一个顺子和一个对子；那么它应该标注为“顺子”。</p></li>
<li><p>确信你的分类方法是正确的之后，下一步是估算这些不同手牌出现的几率。在 <code class="docutils literal notranslate"><span class="pre">PokerHand.py</span></code> 中编写一个函数，完成洗牌，分牌，对牌分类，然后记录每种分类出现的次数。</p></li>
<li><p>打印每种分类和对应频率的表格。运行你的程序，不断增加手牌的卡牌数量，直到输出的值保持在足够准确的范围。将你的结果和<a class="reference external" href="http://en.wikipedia.org/wiki/Hand_rankings">http://en.wikipedia.org/wiki/Hand_rankings</a> 页面中的的值进行比较。</p></li>
</ol>
<p>答案： <a class="reference external" href="code/PokerHandSoln.py">http://thinkpython2.com/code/PokerHandSoln.py</a> 。</p>
</div>
<div class="section" id="id17">
<h3><strong>贡献者</strong><a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="19-the-goodies.html" class="btn btn-neutral float-right" title="第十九章：进阶小技巧" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="17-classes-and-methods.html" class="btn btn-neutral" title="第十七章：类和方法" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>