

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第三章：函数 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第四章：案例研究：接口设计" href="04-case-study-interface-design.html"/>
        <link rel="prev" title="第二章：变量、表达式和语句" href="02-variables-expressions-and-statements.html"/> 

  
  <script src="static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第三章：函数</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">函数调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">数学函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">组合</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">新建函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">定义和使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">执行流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">形参和实参</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">变量和形参都是局部的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stackdiagram">堆栈图</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">有返回值函数和无返回值函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">为什么写函数？</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">习题 3-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">习题 3-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="04-case-study-interface-design.html">第四章：案例研究：接口设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-conditionals-and-recursion.html">第五章：条件和递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-files.html">第十四章：文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="17-classes-and-methods.html">第十七章：类和方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="18-inheritance.html">第十八章：继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第三章：函数</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第三章：函数<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>在编程的语境下，<strong>函数（function）</strong>指的是一个有命名的、执行某个计算的语句序列（sequence of statements）。
在定义一个函数的时候，你需要指定函数的名字和语句序列。
之后，你可以通过这个名字“调用（call）”该函数。</p>
<div class="section" id="id2">
<h2>函数调用<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>我们已经看见过一个<strong>函数调用（function call）</strong>的例子。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>这个函数的名字是 <code class="docutils literal notranslate"><span class="pre">type</span></code>。括号中的表达式被称为这个函数的 <strong>实参（argument）</strong>。这个函数执行的结果，就是实参的类型。</p>
<p>人们常说函数“接受（accept）”实参，然后“返回(return)”一个结果。
该结果也被称为<strong>返回值（return value）</strong>。</p>
<p>Python提供了能够将值从一种类型转换为另一种类型的内建函数。
函数 <code class="docutils literal notranslate"><span class="pre">int</span></code> 接受任意值，并在其能做到的情况下，将该值转换成一个整型数，
否则会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;32&#39;</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="go">ValueError: invalid literal for int(): Hello</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">int</span></code> 能将浮点数转换为整型数，但是它并不进行舍入；只是截掉了小数点部分：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="mf">3.99999</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mf">2.3</span><span class="p">)</span>
<span class="go">-2</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">float</span></code> 可以将整型数和字符串转换为浮点数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="go">32.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;3.14159&#39;</span><span class="p">)</span>
<span class="go">3.14159</span>
</pre></div>
</div>
<p>最后，<code class="docutils literal notranslate"><span class="pre">str</span></code> 可以将其实参转换成字符串：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="go">&#39;32&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span>
<span class="go">&#39;3.14159&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>数学函数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>Python中有一个数学模块（<code class="docutils literal notranslate"><span class="pre">math</span></code>），提供了大部分常用的数学函数。
<strong>模块（module）</strong>指的是一个含有相关函数的文件。</p>
<p>在使用模块之前，我们需要通过 <strong>导入语句（import statement）</strong> 导入该模块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
</pre></div>
</div>
<p>这条语句会生成一个名为 <code class="docutils literal notranslate"><span class="pre">math</span></code> 的<strong>模块对象（module object）</strong>。
如果你打印这个模块对象，你将获得关于它的一些信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">math</span>
<span class="go">&lt;module &#39;math&#39; (built-in)&gt;</span>
</pre></div>
</div>
<p>该模块对象包括了定义在模块内的所有函数和变量。
想要访问其中的一个函数，你必须指定该模块的名字以及函数名，
并以点号（也被叫做句号）分隔开来。 这种形式被称作<strong>点标记法（dot
notation）</strong>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="n">signal_power</span> <span class="o">/</span> <span class="n">noise_power</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decibels</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">radians</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">height</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个例子使用<code class="docutils literal notranslate"><span class="pre">math.log10</span></code>计算分贝信噪比（假设<code class="docutils literal notranslate"><span class="pre">signal_power</span></code>和<code class="docutils literal notranslate"><span class="pre">noise_power</span></code>已经被定义了）。
math模块也提供了 <code class="docutils literal notranslate"><span class="pre">log</span></code> 函数，用于计算以e为底的对数。</p>
<p>第二个例子计算radians的正弦值（sine）。
变量名暗示 <code class="docutils literal notranslate"><span class="pre">sin</span></code> 函数以及其它三角函数（<code class="docutils literal notranslate"><span class="pre">cos</span></code>、<code class="docutils literal notranslate"><span class="pre">tan</span></code> 等）接受弧度（radians）实参。
度数转换为弧度，需要除以180，并乘以 <span class="math">\pi</span>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">degrees</span> <span class="o">=</span> <span class="mi">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radians</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
<span class="go">0.707106781187</span>
</pre></div>
</div>
<p>表达式 <code class="docutils literal notranslate"><span class="pre">math.pi</span></code> 从 <code class="docutils literal notranslate"><span class="pre">math</span></code> 模块中获得变量 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 。
该变量的值是<span class="math">\pi</span>的一个浮点数近似值，精确到大约15位数。</p>
<p>如果你懂几何学（trigonometry），你可以将之前的结果和二分之根号二进行比较，检查是否正确：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="go">0.707106781187</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>组合<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>目前为止，我们已经分别介绍了程序的基本元素——变量、表达式和语句，但是还没有讨论如何将它们组合在一起。</p>
<p>编程语言的最有用特征之一，是能够将小块构建材料（building blocks）<strong>组合（compose）</strong>在一起。
例如，函数的实参可以是任意类型的表达式，包括算术运算符：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span> <span class="o">/</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>甚至是函数调用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>几乎任何你可以放值的地方，你都可以放一个任意类型的表达式，只有一个例外：
赋值语句的左侧必须是一个变量名。左侧放其他任何表达式都会产生语法错误
（后面我们会讲到这个规则的例外）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minutes</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>                 <span class="c1"># 正确</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">=</span> <span class="n">minutes</span>                 <span class="c1"># 错误！</span>
<span class="go">SyntaxError: can&#39;t assign to operator</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>新建函数<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>目前为止，我们只使用了Python自带的函数， 但是创建新函数也是可能的。
一个<strong>函数定义（function definition）</strong>指定了新函数的名称
以及当函数被调用时执行的语句序列。</p>
<p>下面是一个示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_lyrics</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I sleep all night and I work all day.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">def</span></code> 是一个关键字，表明这是一个函数定义。
这个函数的名字是 <code class="docutils literal notranslate"><span class="pre">print_lyrics</span></code>。
函数的命名规则与变量名相同：字母、数字以及下划线是合法的，
但是第一个字符不能是数字。不能使用关键字作为函数名，并应该避免
变量和函数同名。</p>
<p>函数名后面的圆括号是空的，表明该函数不接受任何实参。</p>
<p>函数定义的第一行被称作<strong>函数头（header）</strong>；
其余部分被称作<strong>函数体（body）</strong>。
函数头必须以冒号结尾，而函数体必须缩进。
按照惯例，缩进总是4个空格。 函数体能包含任意条语句。</p>
<p>打印语句中的字符串被括在双引号中。单引号和双引号的作用相同；大多数人使用单引号，上述代码中的情况除外，即单引号（同时也是撇号）出现在字符串中时。</p>
<p>所有引号（单引号和双引号）必须是“直引号（straight quotes）”，它们通常位于键盘上Enter键的旁边。像这句话中使用的‘弯引号（curly quotes）’，在Python语言中则是不合法的。</p>
<p>如果你在交互模式下键入函数定义，每空一行解释器就会打印三个句点（<em>…</em>），
让你知道定义并没有结束。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_lyrics</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I sleep all night and I work all day.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>为了结束函数定义，你必须输入一个空行。</p>
<p>定义一个函数会创建一个 <strong>函数对象（function object）</strong>，其类型是 <code class="docutils literal notranslate"><span class="pre">function</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">print_lyrics</span><span class="p">)</span>
<span class="go">&lt;function print_lyrics at 0xb7e99e9c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">print_lyrics</span><span class="p">)</span>
<span class="go">&lt;class &#39;function&#39;&gt;</span>
</pre></div>
</div>
<p>调用新函数的语法，和调用内建函数的语法相同：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_lyrics</span><span class="p">()</span>
<span class="go">I&#39;m a lumberjack, and I&#39;m okay.</span>
<span class="go">I sleep all night and I work all day.</span>
</pre></div>
</div>
<p>一旦你定义了一个函数，你就可以在另一个函数内部使用它。
例如，为了重复之前的叠句（refrain），我们可以编写一个名叫<code class="docutils literal notranslate"><span class="pre">repeat_lyrics</span></code>的函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat_lyrics</span><span class="p">():</span>
    <span class="n">print_lyrics</span><span class="p">()</span>
    <span class="n">print_lyrics</span><span class="p">()</span>
</pre></div>
</div>
<p>然后调用<code class="docutils literal notranslate"><span class="pre">repeat_lyrics</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">repeat_lyrics</span><span class="p">()</span>
<span class="go">I&#39;m a lumberjack, and I&#39;m okay.</span>
<span class="go">I sleep all night and I work all day.</span>
<span class="go">I&#39;m a lumberjack, and I&#39;m okay.</span>
<span class="go">I sleep all night and I work all day.</span>
</pre></div>
</div>
<p>不过，这首歌的歌词实际上不是这样的。</p>
</div>
<div class="section" id="id6">
<h2>定义和使用<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>将上一节的多个代码段组合在一起，整个程序看起来是这样的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_lyrics</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I&#39;m a lumberjack, and I&#39;m okay.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I sleep all night and I work all day.&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repeat_lyrics</span><span class="p">():</span>
    <span class="n">print_lyrics</span><span class="p">()</span>
    <span class="n">print_lyrics</span><span class="p">()</span>

<span class="n">repeat_lyrics</span><span class="p">()</span>
</pre></div>
</div>
<p>该程序包含两个函数定义：<code class="docutils literal notranslate"><span class="pre">print_lyrics</span></code>和<code class="docutils literal notranslate"><span class="pre">repeat_lyrics</span></code>。
函数定义和其它语句一样，都会被执行，但是其作用是创建函数对象。
函数内部的语句在函数被调用之前，是不会执行的，而且函数定义不会产生任何输出。</p>
<p>你可能猜到了，在运行函数之前，你必须先创建这个函数。换句话说，函数定义必须在其第一次被调用之前执行。</p>
<p>我们做个小练习，将程序的最后一行移到顶部，使得函数调用出现在函数定义之前。运行程序，看看会得到怎样的错误信息。</p>
<p>现在将函数调用移回底部，然后将<code class="docutils literal notranslate"><span class="pre">print_lyrics</span></code>的定义移到<code class="docutils literal notranslate"><span class="pre">repeat_lyrics</span></code>的定义之后。这次运行程序时会发生什么？</p>
</div>
<div class="section" id="id7">
<h2>执行流程<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>为了保证函数第一次使用之前已经被定义，你必须要了解语句执行的顺序，
这也被称作<strong>执行流程（flow of execution）</strong>。</p>
<p>执行流程总是从程序的第一条语句开始，自顶向下，每次执行一条语句。</p>
<p>函数定义不改变程序执行的流程，但是请记住，函数不被调用的话，函数内部的语句是不会执行的。</p>
<p>函数调用像是在执行流程上绕了一个弯路。
执行流程没有进入下一条语句，而是跳入了函数体，开始执行那里的语句，然后再回到它离开的位置。</p>
<p>这听起来足够简单，至少在你想起一个函数可以调用另一个函数之前。
当一个函数执行到中间的时候，程序可能必须执行另一个函数里的语句。
然后在执行那个新函数的时候，程序可能又得执行另外一个函数！</p>
<p>幸运的是，Python善于记录程序执行流程的位置，因此每次一个函数执行完成时，
程序会回到调用它的那个函数原来执行的位置。当到达程序的结尾时，程序才会终止。</p>
<p>总之，阅读程序时，你没有必要总是从上往下读。有时候，跟着执行流程阅读反而更加合理。</p>
</div>
<div class="section" id="id8">
<h2>形参和实参<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>我们之前接触的一些函数需要实参。例如，当你调用 <code class="docutils literal notranslate"><span class="pre">math.sin</span></code> 时，你传递一个数字作为实参。
有些函数接受一个以上的实参：<code class="docutils literal notranslate"><span class="pre">math.pow</span></code> 接受两个，底数和指数。</p>
<p>在函数内部，实参被赋给称作<strong>形参（parameters）</strong>的变量。
下面的代码定义了一个接受一个实参的函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_twice</span><span class="p">(</span><span class="n">bruce</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bruce</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">bruce</span><span class="p">)</span>
</pre></div>
</div>
<p>这个函数将实参赋给名为 <code class="docutils literal notranslate"><span class="pre">bruce</span></code> 的形参。当函数被调用的时候，它会打印形参（无论它是什么）的值两次。</p>
<p>该函数对任意能被打印的值都有效。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="s1">&#39;Spam&#39;</span><span class="p">)</span>
<span class="go">Spam</span>
<span class="go">Spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">3.14159265359</span>
<span class="go">3.14159265359</span>
</pre></div>
</div>
<p>组合规则不仅适用于内建函数，而且也适用于开发者自定义的函数（programmer-defined functions），因此我们可以使用任意类型的表达式作为<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>的实参：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="s1">&#39;Spam &#39;</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Spam Spam Spam Spam</span>
<span class="go">Spam Spam Spam Spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="go">-1.0</span>
<span class="go">-1.0</span>
</pre></div>
</div>
<p>在函数被调用之前，实参会先进行计算，因此在这些例子中，
表达式<code class="docutils literal notranslate"><span class="pre">'Spam</span> <span class="pre">'*4</span></code>和 <code class="docutils literal notranslate"><span class="pre">math.cos(math.pi)</span></code> 都只被计算了一次。</p>
<p>你也可以用变量作为实参：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">michael</span> <span class="o">=</span> <span class="s1">&#39;Eric, the half a bee.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_twice</span><span class="p">(</span><span class="n">michael</span><span class="p">)</span>
<span class="go">Eric, the half a bee.</span>
<span class="go">Eric, the half a bee.</span>
</pre></div>
</div>
<p>我们传递的实参名（<code class="docutils literal notranslate"><span class="pre">michael</span></code>）与形参的名字（<code class="docutils literal notranslate"><span class="pre">bruce</span></code>）没有任何关系。
这个值在传入函数之前叫什么都没有关系；只要传入了<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>函数，我们将所有人都称为 <code class="docutils literal notranslate"><span class="pre">bruce</span></code> 。</p>
</div>
<div class="section" id="id9">
<h2>变量和形参都是局部的<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>当你在函数里面创建变量时，这个变量是<strong>局部的（local）</strong>，
也就是说它只在函数内部存在。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cat_twice</span><span class="p">(</span><span class="n">part1</span><span class="p">,</span> <span class="n">part2</span><span class="p">):</span>
    <span class="n">cat</span> <span class="o">=</span> <span class="n">part1</span> <span class="o">+</span> <span class="n">part2</span>
    <span class="n">print_twice</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
</pre></div>
</div>
<p>该函数接受两个实参，拼接（concatenates）它们并打印结果两次。 下面是使用该函数的一个示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line1</span> <span class="o">=</span> <span class="s1">&#39;Bing tiddle &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">line2</span> <span class="o">=</span> <span class="s1">&#39;tiddle bang.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cat_twice</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">)</span>
<span class="go">Bing tiddle tiddle bang.</span>
<span class="go">Bing tiddle tiddle bang.</span>
</pre></div>
</div>
<p>当<code class="docutils literal notranslate"><span class="pre">cat_twice</span></code>结束时，变量 <code class="docutils literal notranslate"><span class="pre">cat</span></code> 被销毁了。
如果我们试图打印它，我们将获得一个异常：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
<span class="go">NameError: name &#39;cat&#39; is not defined</span>
</pre></div>
</div>
<p>形参也都是局部的。例如，在<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>函数的外部并没有 <code class="docutils literal notranslate"><span class="pre">bruce</span></code> 这个变量。</p>
</div>
<div class="section" id="stackdiagram">
<span id="id10"></span><h2>堆栈图<a class="headerlink" href="#stackdiagram" title="永久链接至标题">¶</a></h2>
<p>有时，画一个<strong>堆栈图（stack diagram）</strong>可以帮助你跟踪哪个变量能在哪儿用。
与状态图类似，堆栈图要说明每个变量的值，但是它们也要说明每个变量所属的函数。</p>
<p>每个函数用一个<strong>栈帧（frame）</strong>表示。
一个栈帧就是一个线框，函数名在旁边，形参以及函数内部的变量则在里面。
前面例子的堆栈图如图3-1所示。</p>
<div class="figure align-default" id="id19">
<img alt="堆栈图。" src="images/stack.png" />
<p class="caption"><span class="caption-text">图3-1：堆栈图。</span><a class="headerlink" href="#id19" title="永久链接至图片">¶</a></p>
</div>
<p>这些线框排列成栈的形式，说明了哪个函数调用了哪个函数等信息。
在此例中，<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>被<code class="docutils literal notranslate"><span class="pre">cat_twice</span></code>调用，
<code class="docutils literal notranslate"><span class="pre">cat_twice</span></code>又被<code class="docutils literal notranslate"><span class="pre">__main__</span></code>调用，<code class="docutils literal notranslate"><span class="pre">__main__</span></code>是一个表示最上层栈帧的特殊名字。
当你在所有函数之外创建一个变量时，它就属于<code class="docutils literal notranslate"><span class="pre">__main__</span></code>。</p>
<p>每个形参都指向其对应实参的值。
因此，<code class="docutils literal notranslate"><span class="pre">part1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">line1</span></code> 的值相同，<code class="docutils literal notranslate"><span class="pre">part2</span></code> 和 <code class="docutils literal notranslate"><span class="pre">line2</span></code> 的值相同， <code class="docutils literal notranslate"><span class="pre">bruce</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cat</span></code> 的值相同。</p>
<p>如果函数调用时发生错误，Python会打印出错函数的名字以及调用它的函数的名字，
以及调用 <em>后面这个函数</em> 的函数的名字，一直追溯到<code class="docutils literal notranslate"><span class="pre">__main__</span></code>为止。</p>
<p>例如，如果你试图在<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>里面访问 <code class="docutils literal notranslate"><span class="pre">cat</span></code> ，
你将获得一个 <code class="docutils literal notranslate"><span class="pre">NameError</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">innermost</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;test.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">13</span><span class="p">,</span> <span class="ow">in</span> <span class="n">__main__</span>
    <span class="n">cat_twice</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;test.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="n">cat_twice</span>
    <span class="n">print_twice</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&quot;test.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">9</span><span class="p">,</span> <span class="ow">in</span> <span class="n">print_twice</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
<span class="ne">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s1">&#39;cat&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</pre></div>
</div>
<p>这个函数列表被称作<strong>回溯（traceback）</strong>。
它告诉你发生错误的是哪个程序文件，错误在哪一行，以及当时在执行哪个函数。
它还会显示引起错误的那一行代码。</p>
<p>回溯中的函数顺序，与堆栈图中的函数顺序一致。出错时正在运行的那个函数则位于回溯信息的底部。</p>
</div>
<div class="section" id="id11">
<h2>有返回值函数和无返回值函数<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>有一些我们之前用过的函数，例如数学函数，会返回结果；
由于没有更好的名字，我姑且叫它们<strong>有返回值函数（fruitful functions）</strong>。
其它的函数，像<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>，执行一个动作但是不返回任何值。
我称它们为<strong>无返回值函数（void functions）</strong>。</p>
<p>当你调用一个有返回值函数时，你几乎总是想用返回的结果去做些什么；
例如，你可能将它赋值给一个变量，或者把它用在表达式里：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
<span class="n">golden</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>当你在交互模式下调用一个函数时，Python解释器会马上显示结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2.2360679774997898</span>
</pre></div>
</div>
<p>但是在脚本中，如果你单单调用一个有返回值函数， 返回值就永远丢失了！</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>该脚本计算5的平方根，但是因为它没保存或者显示这个结果，
这个脚本并没多大用处。</p>
<p>无返回值函数可能在屏幕上打印输出结果，或者产生其它的影响，
但是它们并没有返回值。如果你试图将无返回值函数的结果赋给一个变量，
你会得到一个被称作 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的特殊值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">print_twice</span><span class="p">(</span><span class="s1">&#39;Bing&#39;</span><span class="p">)</span>
<span class="go">Bing</span>
<span class="go">Bing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> 这个值和字符串<code class="docutils literal notranslate"><span class="pre">'None'</span></code>不同。这是一个自己有独立类型的特殊值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="go">&lt;class &#39;NoneType&#39;&gt;</span>
</pre></div>
</div>
<p>目前为止，我们写的函数都是无返回值函数。
我们将在几章之后开始编写有返回值函数。</p>
</div>
<div class="section" id="id12">
<h2>为什么写函数？<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>你可能还不明白为什么值得将一个程序分解成多个函数。 原因包括以下几点：</p>
<ul class="simple">
<li><p>创建一个新的函数可以让你给一组语句命名，
这可以让你的程序更容易阅读和调试。</p></li>
<li><p>通过消除重复的代码，函数精简了程序。
以后，如果你要做个变动，你只需在一处修改即可。</p></li>
<li><p>将一个长程序分解为多个函数，可以让你一次调试一部分，然后再将它们组合为一个可行的整体。</p></li>
<li><p>设计良好的函数经常对多个程序都有帮助。一旦你写出并调试好一个函数，你就可以重复使用它。</p></li>
</ul>
</div>
<div class="section" id="id13">
<h2>调试<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>调试，是你能获得的最重要的技能之一。
虽然调试会让人沮丧，但却是编程过程中最富含智慧、挑战以及乐趣的一部分。</p>
<p>在某些方面，调试像是侦探工作。
你面对一些线索，必须推理出是什么进程（processes）和事件（events）导致了你看到的结果。</p>
<p>调试也像是一门实验性科学。一旦你猜到大概哪里出错了，
你可以修改程序，再试一次。
如果你的假设是正确的，那么你就可以预测到修改的结果，并且离正常运行的程序又近了一步。
如果你的假设是错误的，你就不得不再提一个新的假设。
如夏洛克·福尔摩斯所指出的，“当你排除了所有的不可能，无论剩下的是什么，
不管多么难以置信，一定就是真相。”（阿瑟·柯南·道尔，<em>《四签名》</em>）</p>
<p>对某些人来说，编程和调试是同一件事。
也就是说，编程是逐步调试一个程序，直到它满足了你期待的过程。
这意味着，你应该从一个能<em>正常运行</em>（working） 的程序开始，每次只做一些小改动，并同步进行调试。</p>
<p>举个例子，Linux是一个有着数百万行代码的操作系统 但是它一开始，只是Linus
Torvalds写的一个用于研究Intel 80386芯片的简单程序。 根据Larry
Greenfield的描述，“Linus的早期项目中，有一个能够交替打印AAAA和BBBB的程序。
这个程序后来演变为了Linux。”（<em>Linux用户手册</em> Beta 版本1）。</p>
</div>
<div class="section" id="id14">
<h2>术语表<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<p>函数（function）：</p>
<blockquote>
<div><p>执行某种有用运算的命名语句序列。函数可以接受形参，也可以不接受；可以返回一个结果，也可以不返回。</p>
</div></blockquote>
<p>函数定义（function definition）：</p>
<blockquote>
<div><p>创建一个新函数的语句，指定了函数名、形参以及所包含的语句。</p>
</div></blockquote>
<p>函数对象（function object）：</p>
<blockquote>
<div><p>函数定义所创建的一个值。函数名是一个指向函数对象的变量。</p>
</div></blockquote>
<p>函数头（header）：</p>
<blockquote>
<div><p>函数定义的第一行。</p>
</div></blockquote>
<p>函数体（body）：</p>
<blockquote>
<div><p>函数定义内部的语句序列。</p>
</div></blockquote>
<p>形参（parameters）：</p>
<blockquote>
<div><p>函数内部用于指向被传作实参的值的名字。</p>
</div></blockquote>
<p>函数调用（function call）：</p>
<blockquote>
<div><p>运行一个函数的语句。它包括了函数名，紧随其后的实参列表，实参用圆括号包围起来。</p>
</div></blockquote>
<p>实参（argument）：</p>
<blockquote>
<div><p>函数调用时传给函数的值。这个值被赋给函数中相对应的形参。</p>
</div></blockquote>
<p>局部变量（local variable）：</p>
<blockquote>
<div><p>函数内部定义的变量。局部变量只能在函数内部使用。</p>
</div></blockquote>
<p>返回值（return value）：</p>
<blockquote>
<div><p>函数执行的结果。如果函数调用被用作表达式，其返回值是这个表达式的值。</p>
</div></blockquote>
<p>有返回值函数（fruitful function）：</p>
<blockquote>
<div><p>会返回一个值的函数。</p>
</div></blockquote>
<p>无返回值函数（void function）：</p>
<blockquote>
<div><p>总是返回None的函数。</p>
</div></blockquote>
<p>None：</p>
<blockquote>
<div><p>无返回值函数返回的一个特殊值。</p>
</div></blockquote>
<p>模块（module）：</p>
<blockquote>
<div><p>包含了一组相关函数及其他定义的的文件。</p>
</div></blockquote>
<p>导入语句（import statement）：</p>
<blockquote>
<div><p>读取一个模块文件，并创建一个模块对象的语句。</p>
</div></blockquote>
<p>模块对象（module object）：</p>
<blockquote>
<div><p>导入语句创建的一个值，可以让开发者访问模块内部定义的值。</p>
</div></blockquote>
<p>点标记法（dot notation）：</p>
<blockquote>
<div><p>调用另一个模块中函数的语法，需要指定模块名称，之后跟着一个点（句号）和函数名。</p>
</div></blockquote>
<p>组合（composition）：</p>
<blockquote>
<div><p>将一个表达式嵌入一个更长的表达式，或者是将一个语句嵌入一个更长语句的一部分。</p>
</div></blockquote>
<p>执行流程（flow of execution）：</p>
<blockquote>
<div><p>语句执行的顺序。</p>
</div></blockquote>
<p>堆栈图（stack diagram）：</p>
<blockquote>
<div><p>一种图形化表示堆栈的方法，堆栈中包括函数、函数的变量及其所指向的值。</p>
</div></blockquote>
<p>栈帧（frame）：</p>
<blockquote>
<div><p>堆栈图中一个栈帧，代表一个函数调用。其中包含了函数的局部变量和形参。</p>
</div></blockquote>
<p>回溯（traceback）：</p>
<blockquote>
<div><p>当出现异常时，解释器打印出的出错时正在执行的函数列表。</p>
</div></blockquote>
</div>
<div class="section" id="id15">
<h2>练习题<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<div class="section" id="id16">
<h3>习题 3-1<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>编写一个名为<code class="docutils literal notranslate"><span class="pre">right_justify</span></code>的函数，函数接受一个名为``s``的字符串作为形参，
并在打印足够多的前导空格（leading space）之后打印这个字符串，使得字符串的最后一个字母位于显示屏的第70列。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">right_justify</span><span class="p">(</span><span class="s1">&#39;monty&#39;</span><span class="p">)</span>
<span class="go">                                                                 monty</span>
</pre></div>
</div>
<p>提示：使用字符串拼接（string concatenation）和重复。另外，Python提供了一个名叫len的内建函数，可以返回一个字符串的长度，因此<code class="docutils literal notranslate"><span class="pre">len('allen')</span></code>的值是5。</p>
<p>函数对象是一个可以赋值给变量的值，也可以作为实参传递。例如，
<code class="docutils literal notranslate"><span class="pre">do_twice</span></code>函数接受函数对象作为实参，并调用这个函数对象两次：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">f</span><span class="p">()</span>
    <span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>下面这个示例使用<code class="docutils literal notranslate"><span class="pre">do_twice</span></code>来调用名为<code class="docutils literal notranslate"><span class="pre">print_spam</span></code>的函数两次。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_spam</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>

<span class="n">do_twice</span><span class="p">(</span><span class="n">print_spam</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>将这个示例写入脚本，并测试。</p></li>
<li><p>修改<code class="docutils literal notranslate"><span class="pre">do_twice</span></code>，使其接受两个实参，一个是函数对象，另一个是值。
然后调用这一函数对象两次，将那个值传递给函数对象作为实参。</p></li>
<li><p>从本章前面一些的示例中，将 <code class="docutils literal notranslate"><span class="pre">print_twice</span></code> 函数的定义复制到脚本中。</p></li>
<li><p>使用修改过的<code class="docutils literal notranslate"><span class="pre">do_twice</span></code>，调用<code class="docutils literal notranslate"><span class="pre">print_twice</span></code>两次，将<code class="docutils literal notranslate"><span class="pre">'spam'</span></code>传递给它作为实参。</p></li>
<li><p>定义一个名为<code class="docutils literal notranslate"><span class="pre">do_four</span></code>的新函数，其接受一个函数对象和一个值作为实参。
调用这个函数对象四次，将那个值作为形参传递给它。
函数体中应该只有两条语句，而不是四条。</p></li>
</ol>
<p>答案： <a class="reference external" href="code/do_four.py">http://thinkpython2.com/code/do_four.py</a> 。</p>
<p>注意：这一习题只能使用我们目前学过的语句和特性来完成。</p>
</div>
<div class="section" id="id17">
<h3>习题 3-2<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<ol class="arabic">
<li><p>编写一个能画出如下网格（grid）的函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>         <span class="o">|</span>
<span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">+</span>
</pre></div>
</div>
<p>提示：你可以使用一个用逗号分隔的值序列，在一行中打印出多个值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">print</span></code> 函数默认会自动换行，但是你可以阻止这个行为，只需要像下面这样将行结尾变成一个空格：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这两个语句的输出结果是 <code class="docutils literal notranslate"><span class="pre">'+</span> <span class="pre">-'</span></code>。</p>
<p>一个没有传入实参的 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语句会结束当前行，跳到下一行。</p>
</li>
<li><p>编写一个能够画出四行四列的类似网格的函数。</p></li>
</ol>
<p>答案： <a class="reference external" href="code/grid.py">http://thinkpython2.com/code/grid.py</a> 。致谢：这个习题基于 <em>Practical C Programming, Third
Edition</em> 一书中的习题改编，此书由O’Reilly出版社于1997年出版。</p>
</div>
<div class="section" id="id18">
<h3><strong>贡献者</strong><a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="04-case-study-interface-design.html" class="btn btn-neutral float-right" title="第四章：案例研究：接口设计" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="02-variables-expressions-and-statements.html" class="btn btn-neutral" title="第二章：变量、表达式和语句" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/language_data.js"></script>
      <script type="text/javascript" src="static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>