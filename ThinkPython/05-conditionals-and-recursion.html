

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第五章：条件和递归 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第六章：有返回值的函数" href="06-fruitful-functions.html"/>
        <link rel="prev" title="第四章：案例研究：接口设计" href="04-case-study-interface-design.html"/> 

  
  <script src="static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-functions.html">第三章：函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-case-study-interface-design.html">第四章：案例研究：接口设计</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第五章：条件和递归</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">地板除和求余</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">布尔表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">逻辑运算符</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-execution">有条件的执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">二选一执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">链式条件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">嵌套条件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">递归</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">递归函数的堆栈图</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">无限递归</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">键盘输入</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">习题 5-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">习题 5-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">习题 5-3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">习题 5-4</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">习题 5-５</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">习题 5-６</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-files.html">第十四章：文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="17-classes-and-methods.html">第十七章：类和方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="18-inheritance.html">第十八章：继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第五章：条件和递归</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第五章：条件和递归<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>这章的中心话题是能够根据程序的状态执行不同命令的if语句。但是首先我想介绍两个新的运算符 : 地板除（floor division）和求余（modulus）。</p>
<div class="section" id="id2">
<h2>地板除和求余<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p><strong>地板除</strong> 运算符(floor division operator) <code class="docutils literal notranslate"><span class="pre">//</span></code> 先做除法，然后将结果保留到整数。例如，如果一部电影时长105 分钟，你可能想知道这代表着多少小时。传统的除法操作会返回一个浮点数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minutes</span> <span class="o">=</span> <span class="mi">105</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minutes</span> <span class="o">/</span> <span class="mi">60</span>
<span class="go">1.75</span>
</pre></div>
</div>
<p>但是，用小时做单位的时候，我们通常并不写出小数部分。地板除丢弃除法运算结果的小数部分，返回整数个小时:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minutes</span> <span class="o">=</span> <span class="mi">105</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hours</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">//</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hours</span>
<span class="go">1</span>
</pre></div>
</div>
<p>如果你希望得到余数，你可以从除数中减去一个小时也就是60分钟:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remainder</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">-</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remainder</span>
<span class="go">45</span>
</pre></div>
</div>
<p>另一个方法就是使用 <strong>求余运算符(modulus operator)</strong>  <code class="docutils literal notranslate"><span class="pre">%</span></code> ，它会将两个数相除，返回余数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remainder</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">%</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remainder</span>
<span class="go">45</span>
</pre></div>
</div>
<p>求余运算符比看起来更加有用。例如，你可以查看一个数是否可以被另一个数整除——如果　<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code>　的结果是 0，那么 x 能被 y　整除。</p>
<p>此外，你也能获得一个数的最右边一位或多位的数字。 例如， <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span>
<span class="pre">10</span></code> 返回 x 最右边一位的数字（十进制）。 类似地，<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">100</span></code> 返回最后两位数字。</p>
<p>如果你正在使用　Python 2, 那么除法就会和前面的介绍有点不同。除法运算符 <code class="docutils literal notranslate"><span class="pre">/</span></code>　在被除数和除数都是整数的时候，会进行地板除，但是当被除数和除数中任意一个是浮点数的时候，则进行浮点数除法。(译者注：在 Python3 中，无论任何类型都会保持小数部分)</p>
</div>
<div class="section" id="id3">
<h2>布尔表达式<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p><strong>布尔表达式（boolean expression）</strong>的结果要么为真要么为假。
下面的例子使用 <code class="docutils literal notranslate"><span class="pre">==</span></code> 运算符。它比较两个运算数，
如果它们相等，则结果为 <code class="docutils literal notranslate"><span class="pre">True</span></code> ，否则结果为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">False</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> 和 <code class="docutils literal notranslate"><span class="pre">False</span></code> 是属于bool类型的特殊值；它们不是字符串。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;class &#39;bool&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;class &#39;bool&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">==</span></code> 运算符是<strong>关系运算符（relational operators）</strong>之一； 其他关系运算符还有：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>               <span class="c1"># x 不等于 y</span>
<span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>                <span class="c1"># x 大于 y</span>
<span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>                <span class="c1"># x 小于 y</span>
<span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>               <span class="c1"># x 大于或等于 y</span>
<span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>               <span class="c1"># x 小于或等于 y</span>
</pre></div>
</div>
<p>虽然这些运算符对你来说可能很熟悉，但是Python的符号与数学符号不相同。
一个常见的错误是使用单独一个等号（=）而不是双等号（==）。
请记住，<code class="docutils literal notranslate"><span class="pre">=</span></code> 是赋值运算符，<code class="docutils literal notranslate"><span class="pre">==</span></code> 是关系运算符。 没有类似 =&lt; 或 =&gt; 的东西。</p>
</div>
<div class="section" id="id4">
<h2>逻辑运算符<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>有三个<strong>逻辑运算符（logical operators）</strong>：<code class="docutils literal notranslate"><span class="pre">and</span></code> 、<code class="docutils literal notranslate"><span class="pre">or</span></code> 和 <code class="docutils literal notranslate"><span class="pre">not</span></code>。
这些运算符的含义和它们在英语的意思相似。例如，<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">and</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">10</span></code> 只在x大于0并且小于10时为真。</p>
<p><code class="docutils literal notranslate"><span class="pre">n%2</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">or</span> <span class="pre">n%3</span> <span class="pre">==</span> <span class="pre">0</span></code>中如果 <strong>一个或两个</strong> 条件为真，那么整个表达式即为真。也就是说，如果数字n能被2或者3整除，则为真。</p>
<p>最后，<code class="docutils literal notranslate"><span class="pre">not</span></code> 运算符对一个布尔表达式取反， 因此，如果 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span>
<span class="pre">y</span></code> 为假，也就是说x小于或等于y， 则 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">y)</span></code> 为真。</p>
<p>严格来讲，逻辑运算符的运算数应该是布尔表达式，
但是Python并不严格要求。任何非0的数字都被解释成为真（ <code class="docutils literal notranslate"><span class="pre">True</span></code> ）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">42</span> <span class="ow">and</span> <span class="kc">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>这种灵活性很有用，但有一些细节可能容易令人困惑。你可能需要避免这种用法（除非你知道你正在做什么）。</p>
</div>
<div class="section" id="conditional-execution">
<span id="id5"></span><h2>有条件的执行<a class="headerlink" href="#conditional-execution" title="永久链接至标题">¶</a></h2>
<p>为了写出有用的程序，我们几乎总是需要能够检测条件，并相应地改变程序行为。
<strong>条件语句（Conditional statements）</strong>给予了我们这一能力。
最简单的形式是 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is positive&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 之后的布尔表达式被称作<strong>条件（condition）</strong>。
如果它为真，则缩进的语句会被执行。 如果不是，则什么也不会发生。</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 语句和函数定义有相同的结构：一个语句头跟着一个缩进的语句体。
类似的语句被称作<strong>复合语句（compound statements）</strong>。</p>
<p>语句体中可出现的语句数目没有限制，但是至少得有一个。
有时候，一条语句都没有的语句体也是有用的（通常是为你还没写的代码占一个位子）。
这种情况下，你可以使用 <code class="docutils literal notranslate"><span class="pre">pass</span></code> 语句，它什么也不做。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">pass</span>          <span class="c1"># 待完成：需要处理负数值！</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>二选一执行<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 语句的第二种形式是<strong>二选一执行（alternative execution）</strong>，
此时有两个可能的选择，由条件决定执行哪一个。 语法看起来是这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is even&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is odd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果x除以2的余数是0，那么我们知道x是偶数，
然后程序会打印相应的信息。 如果条件为假，则执行第二部分语句。
由于条件要么为真要么为假，两个选择中只有一个会被执行。
这些选择被称作<strong>分支（branches）</strong>，因为它们是执行流程的分支。</p>
</div>
<div class="section" id="id7">
<h2>链式条件<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>有时有超过两个可能的情况，于是我们需要多于两个的分支。
表示像这样的计算的方法之一是<strong>链式条件（chained conditional）</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is less than y&#39;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is greater than y&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x and y are equal&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">elif</span></code> 是“else if”的缩写。同样地，这里只有一个分支会被执行。
<code class="docutils literal notranslate"><span class="pre">elif</span></code> 语句的数目没有限制。如果有一个 <code class="docutils literal notranslate"><span class="pre">else</span></code> 从句，
它必须是在最后，但这个语句并不是必须。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
    <span class="n">draw_a</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
    <span class="n">draw_b</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
    <span class="n">draw_c</span><span class="p">()</span>
</pre></div>
</div>
<p>程序将按顺序逐个检测条件，如果第一个为假，检测下一个，以此类推。
如果它们中有一个为真，相应的分支被执行，并且语句结束。
即便有不止一个条件为真，也只执行第一个为真的分支。</p>
</div>
<div class="section" id="id8">
<h2>嵌套条件<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>一个条件可以嵌到另一个里面。我们可以这样写前一节的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x and y are equal&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is less than y&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is greater than y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>外层的条件（outer conditional）包括两个分支。第一个分支包括一条简单的语句。
第二个分支又包括一个 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句，它有自己的两个分支。
那两个分支都是简单的语句，当然它们也可以是条件语句。</p>
<p>虽然语句的缩进使得结构很明显，但是仍然很难快速地阅读<strong>嵌套条件（nested conditionals）</strong> 。当你可以的时候，避免使用嵌套条件是个好办法。</p>
<p>逻辑运算符通常是一个简化嵌套条件语句的方法。
例如，我们可以用一个单一条件重写下面的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is a positive single-digit number.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>只有我们通过了两个条件检测的时候，print语句才被执行，
因此我们可以用 <code class="docutils literal notranslate"><span class="pre">and</span></code> 运算符得到相同的效果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is a positive single-digit number.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>对于这样的条件，Python 提供了一种更加简洁的写法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x is a positive single-digit number.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="recursion">
<span id="id9"></span><h2>递归<a class="headerlink" href="#recursion" title="永久链接至标题">¶</a></h2>
<p>一个函数调用另一个是合法的；一个函数调用它自己也是合法的。
这样的好处可能并不是那么明显，但它实际上成为了程序能做到的最神奇的事情之一。
例如，看一下这个程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Blastoff!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">countdown</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>如果n是0或负数，程序输出单词“Blastoff!”。
否则，它输出n然后调用一个名为 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 的函数—即它自己— 传递n-1作为实参。</p>
<p>如果我们像这样调用该函数会发生什么呢？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">countdown</span></code>开始以n=3执行，由于n大于0， 它输出值3，然后调用它自己…</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">countdown</span></code>开始以n=2执行，由于n大于0， 它输出值2，然后调用它自己…</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">countdown</span></code>开始以n=1执行，既然n大于0，
它输出值1，然后调用它自己…</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">countdown</span></code>开始以n=0执行，由于n不大于0，
它输出单词“Blastoff!”，然后返回。</p>
</div></blockquote>
<p>获得n=1的 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 返回。</p>
</div></blockquote>
<p>获得n=2的 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 返回。</p>
</div></blockquote>
<p>获得n=3的 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 返回。</p>
<p>然后你回到<code class="docutils literal notranslate"><span class="pre">__main__</span></code>中。因此整个输出类似于：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>3
2
1
Blastoff!
</pre></div>
</div>
<p>一个调用它自己的函数是<strong>递归的（recursive）</strong>；
这个过程被称作<strong>递归（recursion）</strong>。</p>
<p>再举一例，我们可以写一个函数，其打印一个字符串n次。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_n</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">print_n</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> ，<strong>return语句</strong> 退出函数。
执行流程马上返回到调用者，函数剩余的语句行不会被执行。</p>
<p>函数的其余部分和 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 相似： 它打印s的值，然后调用自身打印s <span class="math">n-1</span>次。 因此，输出的行数是 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code> ，加起来是n。</p>
<p>对于像这样简单的例子，使用for循环可能更容易。
但是我们后面将看到一些用for循环很难写，用递归却很容易的例子，
所以早点儿开始学习递归有好处。</p>
</div>
<div class="section" id="id10">
<h2>递归函数的堆栈图<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>在<a class="reference internal" href="03-functions.html#stackdiagram"><span class="std std-ref">堆栈图</span></a>一节中，我们用堆栈图表示了一个函数调用期间程序的状态。
这种图也能帮我们理解递归函数。</p>
<p>每当一个函数被调用时，Python生成一个新的栈帧，用于保存函数的局部变量和形参。
对于一个递归函数，在堆栈上可能同时有多个栈帧。</p>
<p><a class="reference internal" href="#fig-stack2"><span class="std std-ref">图5-1：堆栈图</span></a>展示了一个以n = 3调用 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 的堆栈图。</p>
<div class="figure align-default" id="id23">
<span id="fig-stack2"></span><img alt="图5-1：堆栈图" src="images/stack2.png" />
<p class="caption"><span class="caption-text">图5-1：堆栈图</span><a class="headerlink" href="#id23" title="永久链接至图片">¶</a></p>
</div>
<p>通常，堆栈的顶部是<code class="docutils literal notranslate"><span class="pre">__main__</span></code>栈帧。
因为我们在<code class="docutils literal notranslate"><span class="pre">__main__</span></code>中没有创建任何变量，也没有传递任何实参给它，
所以它是空的。</p>
<p>对于形参n，四个 <code class="docutils literal notranslate"><span class="pre">countdown</span></code> 栈帧有不同的值。
n=0的栈底，被称作<strong>基础情形（base case）</strong>。
它不再进行递归调用了，所以没有更多的栈帧了。</p>
<p>接下来练习一下，请画一个以<code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">'Hello'</span></code>和 <code class="docutils literal notranslate"><span class="pre">n=2</span></code> 调用<code class="docutils literal notranslate"><span class="pre">print_n</span></code>的堆栈图。
写一个名为<code class="docutils literal notranslate"><span class="pre">do_n</span></code>的函数，接受一个函数对象和一个数n作为实参，
能够调用指定的函数n次。</p>
</div>
<div class="section" id="id11">
<h2>无限递归<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>如果一个递归永不会到达基础情形，它将永远进行递归调用，
并且程序永远不会终止。这被称作<strong>无限递归（infinite recursion）</strong>，
通常这不是一个好主意。下面是一个最简单的无限递归程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recurse</span><span class="p">():</span>
    <span class="n">recurse</span><span class="p">()</span>
</pre></div>
</div>
<p>在大多数编程环境里，一个具有无限递归的程序并非永远不会终止。
当达到最大递归深度时，Python会报告一个错误信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
                  <span class="o">.</span>
                  <span class="o">.</span>
                  <span class="o">.</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">exceeded</span>
</pre></div>
</div>
<p>此回溯比我们在前面章节看到的长一些。
当错误出现的时候，在堆栈上有1000个递归栈帧！</p>
<p>如果你不小心遇到了无限递归，检查你的函数，确保基础情形没有继续调用递归。
同时如果确实有基础情形，请检查基础情形是不是能够出现这种情形。</p>
</div>
<div class="section" id="id12">
<h2>键盘输入<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>到目前为止，我们所写的程序都不接受来自用户的输入。
每次它们都只是做相同的事情。</p>
<p>Python 提供了一个内建函数 <code class="docutils literal notranslate"><span class="pre">input</span></code> ，可以暂停程序运行，并等待用户输入。
当用户按下回车键(Return or Enter)，程序恢复执行，<code class="docutils literal notranslate"><span class="pre">input</span></code>以字符串形式返回用户键入的内容。在Python 2中，这个函数的名字叫<code class="docutils literal notranslate"><span class="pre">raw_input</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="go">What are you waiting for?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span>
<span class="go">What are you waiting for?</span>
</pre></div>
</div>
<p>在从用户那儿获得输入之前，打印一个提示告诉用户输入什么是个好办法。
<code class="docutils literal notranslate"><span class="pre">input</span></code>接受提示语作为实参。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;What...is your name?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">What...is your name?</span>
<span class="go">Arthur, King of the Britons!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span>
<span class="go">Arthur, King of the Britons!</span>
</pre></div>
</div>
<p>提示语最后的<code class="docutils literal notranslate"><span class="pre">\n</span></code>表示一个<strong>新行（newline）</strong>，
它是一个特别的字符，会造成换行。
这也是用户的输入出现在提示语下面的原因。</p>
<p>如果你期望用户键入一个整型数，那么你可以试着将返回值转化为 <code class="docutils literal notranslate"><span class="pre">int</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prompt</span> <span class="o">=</span> <span class="s1">&#39;What...is the airspeed velocity of an unladen swallow?</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="go">What...is the airspeed velocity of an unladen swallow?</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
<span class="go">42</span>
</pre></div>
</div>
<p>但是，如果用户输入不是数字构成的字符串，你会获得一个错误：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">speed</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="go">What...is the airspeed velocity of an unladen swallow?</span>
<span class="go">What do you mean, an African or a European swallow?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
<span class="go">ValueError: invalid literal for int() with base 10</span>
</pre></div>
</div>
<p>我们后面将介绍处理这类错误的方法。</p>
</div>
<div class="section" id="id13">
<h2>调试<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>当出现语法错误和运行时错误的时候，错误信息中会包含了很多的信息，但是信息量有可能太大。通常，最有用的部分是：</p>
<ul class="simple">
<li><p>是哪类错误，以及</p></li>
<li><p>在哪儿出现。</p></li>
</ul>
<p>语法错误通常很容易被找到，但也有一些需要注意的地方。
空白分隔符错误很棘手，因为空格和制表符是不可见的，而且我们习惯于忽略它们。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="o">^</span>
<span class="gr">IndentationError</span>: <span class="n">unexpected indent</span>
</pre></div>
</div>
<p>在这个例子中，问题在于第二行缩进了一个空格。
但是错误信息指向y，这是个误导。 通常，错误信息指向发现错误的地方，
但是实际的错误可能发生在代码中更早的地方， 有时在前一行。</p>
<p>运行时错误也同样存在这个问题。假设你正试图计算分贝信噪比。
公式是<span class="math">SNR_{db} = 10 \log_{10} (P_{signal} / P_{noise})</span>。
在Python中，你可能会写出这样的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">signal_power</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">noise_power</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">ratio</span> <span class="o">=</span> <span class="n">signal_power</span> <span class="o">//</span> <span class="n">noise_power</span>
<span class="n">decibels</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decibels</span><span class="p">)</span>
</pre></div>
</div>
<p>但是，当你运行它的时候， 你却获得一个异常。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;snr.py&quot;, line 5, in ?
    decibels = 10 * math.log10(ratio)
ValueError: math domain error
</pre></div>
</div>
<p>该错误信息指向第5行，但是那一行没什么错误。
为了找到真正的错误，打印 <code class="docutils literal notranslate"><span class="pre">ratio</span></code> 的值也许会有用，结果发现它实际上是0。
那么问题是在第4行，使用了地板除而不是浮点数除法。</p>
<p>你应该花些时间仔细阅读错误信息，但是不要轻易地认为错误信息的提示都是准确的。</p>
</div>
<div class="section" id="id14">
<h2>术语表<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<p>地板除:</p>
<blockquote>
<div><p>一个操作符,用 // 表示，表示对两个数做除法同时向0取整。</p>
</div></blockquote>
<p>求余运算符:</p>
<blockquote>
<div><p>一个运算符，用百分号 % 表示，返回两个数相除的余数</p>
</div></blockquote>
<p>布尔表达式:</p>
<blockquote>
<div><p>一个值要么为真要么为假的表达式。</p>
</div></blockquote>
<p>关系运算符:</p>
<blockquote>
<div><p>对其运算符进行比较的运算符： ==，!=，&gt;，&lt;，&gt;=，&lt;=。</p>
</div></blockquote>
<p>逻辑运算符:</p>
<blockquote>
<div><p>将布尔表达式组合在一起的运算符: and，or，和 not。</p>
</div></blockquote>
<p>条件语句:</p>
<blockquote>
<div><p>一段根据某个条件决定程序执行流程的语句。</p>
</div></blockquote>
<p>条件:</p>
<blockquote>
<div><p>决定哪个分支会被执行的布尔表达式</p>
</div></blockquote>
<p>复合语句:</p>
<blockquote>
<div><p>由语句头和语句体组成的语句。语句头以 : 结尾，语句体相对语句头缩进。</p>
</div></blockquote>
<p>分支:</p>
<blockquote>
<div><p>条件语句中的选择性语句序列。</p>
</div></blockquote>
<p>链式条件:</p>
<blockquote>
<div><p>由一系列替代分支组成的条件语句。</p>
</div></blockquote>
<p>嵌套条件:</p>
<blockquote>
<div><p>出现另一个条件语句某个分支中的条件语句。</p>
</div></blockquote>
<dl class="simple">
<dt>返回语句：</dt><dd><p>结束函数执行并且将结果返回给调用者的语句。</p>
</dd>
</dl>
<p>递归:</p>
<blockquote>
<div><p>调用正在执行的函数本身的过程。</p>
</div></blockquote>
<p>基本情形:</p>
<blockquote>
<div><p>在递归函数中，不进行递归调用的条件分支。</p>
</div></blockquote>
<p>无限递归:</p>
<blockquote>
<div><p>没有基本情形或者无法出现基本情形的递归函数。最终无限递归会导致运行时错误。</p>
</div></blockquote>
</div>
<div class="section" id="id15">
<h2>练习题<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<div class="section" id="id16">
<h3>习题 5-1<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">time</span></code> 模块提供了一个可以返回当前格林威治标准时间的函数，名字也是time。这里的格林威治标准时间用纪元(the epoch)以来的秒数表示，
纪元是一个任意的参考点。在 Unix 系统中，纪元是1970年1月1号。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="go">1437746094.5735958</span>
</pre></div>
</div>
<p>请写一个脚本读取当前时间，并且将其转换为纪元以来经过了多少天、小时、分钟和秒。</p>
</div>
<div class="section" id="id17">
<h3>习题 5-2<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>费马大定理（Fermat’s Last Theorem ）称，没有任何整型数<span class="math">a</span>、<span class="math">b</span>和<span class="math">c</span>能够使</p>
<div class="math">
<p><span class="math">a^n + b^n = c^n</span></p>
</div><p>对于任何大于2的<span class="math">n</span>成立。</p>
<ol class="arabic">
<li><p>写一个名为<code class="docutils literal notranslate"><span class="pre">check_fermat</span></code>的函数，接受四个形参——a，b，c以及n
——检查费马大定理是否成立。 如果<span class="math">n</span>大于2且等式</p>
<div class="math">
<p><span class="math">a^n + b^n = c^n</span></p>
</div><p>成立，程序应输出“Holy smokes, Fermat was wrong!”。 否则程序应输出“No,
that doesn’t work.”。</p>
</li>
<li><p>写一个函数提示用户输入a，b，c以及n的值，将它们转换成整型数，
然后使用<code class="docutils literal notranslate"><span class="pre">check_fermat</span></code>检查他们是否会违反了费马大定理。</p></li>
</ol>
</div>
<div class="section" id="id18">
<h3>习题 5-3<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>如果你有三根棍子，你有可能将它们组成三角形，也可能不行。
比如，如果一根棍子是12英寸长，其它两根都是1英寸长，显然
你不可能让两根短的在中间接合。对于任意三个长度，有一个简单的测试
能验证它们能否组成三角形：</p>
<blockquote>
<div><p>如果三个长度中的任意一个超过了其它二者之和，就不能组成三角形。否则，可以组成。（如果两个长度之和等于第三个，它们就组成所谓“退化的”三角形。）</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>写一个名为<code class="docutils literal notranslate"><span class="pre">is_triangle</span></code>的函数，其接受三个整数作为形参，
能够根据给定的三个长度的棍子能否构成三角形来打印“Yes”或“No”。</p></li>
<li><p>写一个函数，提示用户输入三根棍子的长度，将它们转换成整型数，然后使用
<code class="docutils literal notranslate"><span class="pre">is_triangle</span></code>检查给定长度的棍子能否构成三角形。</p></li>
</ol>
</div>
<div class="section" id="id19">
<h3>习题 5-4<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>下面程序的输出是什么？画出展示程序每次打印输出时的堆栈图。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">recurse</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="n">s</span><span class="p">)</span>

<span class="n">recurse</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>如果你这样调用函数： <code class="docutils literal notranslate"><span class="pre">recurse(-1,0)</span></code> ，会有什么结果？</p></li>
<li><p>请写一个文档字符串，解释调用该函数时需要了解的全部信息（仅此而已）。</p></li>
</ol>
</div>
<div class="section" id="id20">
<h3>习题 5-５<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>后面的习题要用到第四章中的Turtle：</p>
<p>阅读如下的函数，看看你能否看懂它是做什么的。然后运行它（见第四章的例子）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">fd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
    <span class="n">lt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">bk</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>习题 5-６<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<div class="figure align-default" id="id24">
<img alt="图5-2：科赫曲线（Koch Curve）。" src="images/koch.png" />
<p class="caption"><span class="caption-text">图5-2：科赫曲线（Koch Curve）。</span><a class="headerlink" href="#id24" title="永久链接至图片">¶</a></p>
</div>
<p>科赫曲线（Koch Curve）是一个看起来类似图5-2的不规则碎片几何体（fractal）。要画一个长度为<span class="math">x</span>的科赫曲线，你只需要：</p>
<ol class="arabic simple">
<li><p>画一个长度为<span class="math">x/3</span>的科赫曲线。</p></li>
<li><p>左转60度。</p></li>
<li><p>画一个长度为<span class="math">x/3</span>的科赫曲线。</p></li>
<li><p>右转120度。</p></li>
<li><p>画一个长度为<span class="math">x/3</span>的科赫曲线。</p></li>
<li><p>左转60度。</p></li>
<li><p>画一个长度为<span class="math">x/3</span>的科赫曲线。</p></li>
</ol>
<p>例外情况是<span class="math">x</span>小于3的情形：此时，你只需要
画一道长度为<span class="math">x</span>的直线。</p>
<ol class="arabic">
<li><p>写一个名为 <code class="docutils literal notranslate"><span class="pre">koch</span></code> 的函数，接受一个海龟和一个长度作为形参，然后
使用海龟画一条给定长度的科赫曲线。</p></li>
<li><p>写一个名为 <code class="docutils literal notranslate"><span class="pre">snowflake</span></code> 的函数，画出三条科赫曲线，构成雪花的轮廓。</p>
<p>答案：<a class="reference external" href="http://thinkpython.com/code/koch.py">http://thinkpython.com/code/koch.py</a> 。</p>
</li>
<li><p>科赫曲线能够以多种方式泛化。
点击<a class="reference external" href="http://en.wikipedia.org/wiki/Koch_snowflake">http://en.wikipedia.org/wiki/Koch_snowflake</a> 查看例子，并实现你最喜欢的那种方式。</p></li>
</ol>
</div>
<div class="section" id="id22">
<h3><strong>贡献者</strong><a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/iphyer">&#64;iphyer</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="06-fruitful-functions.html" class="btn btn-neutral float-right" title="第六章：有返回值的函数" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="04-case-study-interface-design.html" class="btn btn-neutral" title="第四章：案例研究：接口设计" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/language_data.js"></script>
      <script type="text/javascript" src="static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>