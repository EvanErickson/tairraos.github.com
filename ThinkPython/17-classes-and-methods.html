

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十七章：类和方法 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第十八章：继承" href="18-inheritance.html"/>
        <link rel="prev" title="第十六章：类和函数" href="16-classes-and-functions.html"/> 

  
  <script src="static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-functions.html">第三章：函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-case-study-interface-design.html">第四章：案例研究：接口设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-conditionals-and-recursion.html">第五章：条件和递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-files.html">第十四章：文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第十七章：类和方法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">面向对象的特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">打印对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">再举一例</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">一个更复杂的例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="#init">init 方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#str">__str__ 方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">运算符重载</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-based-dispatch">类型分发（type-based dispatch）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">多态性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">接口和实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id12">习题17-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kangaroo">习题17-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="18-inheritance.html">第十八章：继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第十七章：类和方法</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第十七章：类和方法<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>虽然我们已经在使用部分 Python 面向对象的特性，前两个章节中的程序并不是真正面向对象的，
因为它们没有呈现出程序员自定义类型与对其进行操作的函数（functions）之间的关系。
下一步，我们将会把这些函数转换成明显突出这一关系的方法（methods）。</p>
<p>本章代码可以从<a class="reference external" href="code/Time2.py">http://thinkpython2.com/code/Time2.py</a> 获取，
练习题的答案位于<a class="reference external" href="code/Point2_soln.py">http://thinkpython2.com/code/Point2_soln.py</a> 。</p>
<div class="section" id="id2">
<h2>面向对象的特性<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>Python 是一门**面向对象的编程语言**，这意味它提供了能够支持面向对象编程的特性。
面向对象编程具有以下特征：</p>
<ul class="simple">
<li><p>程序包含类和方法定义。</p></li>
<li><p>大部分计算以对象上的操作表示。</p></li>
<li><p>对象通常代表现实世界的物体，方法对应现实世界中物体交互的方式。</p></li>
</ul>
<p>例如，第16章中定义的 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 类对应人们用来记录一天中的时间，其中定义的各种函数对应人们使用时间的方式。类似的，第15章中的 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 类和 <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code> 类对应数学中点和矩形的概念。</p>
<p>到目前为止，我们还没有利用Python提供的支持面向对象编程的特性。这些特性严格来说并不是必须的；大部分提供的是我们已经实现的功能的替代语法。但在很多情况下，这些替代语法更加简洁，更准确地表达了程序的结构。</p>
<p>例如，在 <code class="docutils literal notranslate"><span class="pre">Time1.py</span></code> 中，类定义与之后的函数定义之间没有明显的联系。仔细检查之后，才会发现每个函数都至少接受一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象作为参数。</p>
<p>从这个观察中我们发现了<strong>方法</strong>；方法是一个与特定的类相关联的函数。我们已经接触了字符串、列表、字典和元组的方法。在这章中，我们将会定义程序员自定义类型的方法。</p>
<p>方法和函数的语义相同，但是有两处句法的不同：</p>
<ul class="simple">
<li><p>方法在一个类定义内部声明，为的是显示地与类进行关联。</p></li>
<li><p>调用方法的语法和调用函数的语法不同。</p></li>
</ul>
<p>在接下来的几节中，我们会把前面两章中的函数转化为方法。这个转化是纯机械式的；你可以通
过一系列步骤完成。如果你能够轻松地将一种形式转换成另一种形式，就可以选择最适合目前需求的形式。</p>
</div>
<div class="section" id="id3">
<h2>打印对象<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>在第16章中，我们定义了一个名叫 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 的类，在<a class="reference internal" href="16-classes-and-functions.html#isafter"><span class="std std-ref">时间</span></a>一节中，你编写了一个叫做 <code class="docutils literal notranslate"><span class="pre">print_time</span></code> 的函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents the time of day.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</pre></div>
</div>
<p>想要调用这个函数，你必须把一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象作为一个参数传递给函数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="o">.</span><span class="n">minute</span> <span class="o">=</span> <span class="mi">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="mi">00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="go">09:45:00</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">print_time</span></code> 变成一个方法，我们只需要将函数定义移到类定义里面即可。注意缩进
的变化。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</pre></div>
</div>
<p>现在有两种方法可以调用<code class="docutils literal notranslate"><span class="pre">print_time</span></code>。第一种（也是不常用的）是使用函数的语法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Time</span><span class="o">.</span><span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="go">09:45:00</span>
</pre></div>
</div>
<p>在这个点标记法的用法中，<code class="docutils literal notranslate"><span class="pre">Time</span></code> 是类的名字，<code class="docutils literal notranslate"><span class="pre">print_time</span></code>是方法的名字。<code class="docutils literal notranslate"><span class="pre">start</span></code> 是传递的参数。</p>
<p>第二种语法（也更简洁）是使用方法语法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">09:45:00</span>
</pre></div>
</div>
<p>在这个点标记法的用法中，<code class="docutils literal notranslate"><span class="pre">print_time</span></code>是方法的名称，然后 <code class="docutils literal notranslate"><span class="pre">start</span></code> 是调用方法的对象
，被称为主语（<strong>subject</strong>）。就像一个句子的主语是句子的核心，方法的主语也是方
法作用的主要对象。</p>
<p>在方法中，主语被赋值为第一个参数，所以在这里 <code class="docutils literal notranslate"><span class="pre">start</span></code> 被赋值给 <code class="docutils literal notranslate"><span class="pre">time</span></code> 上了。</p>
<p>根据约定，方法的第一个参数写作 <code class="docutils literal notranslate"><span class="pre">self</span></code> ，所以<code class="docutils literal notranslate"><span class="pre">print_time</span></code>写成这样更常见：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</pre></div>
</div>
<p>使用该约定原因在于一种暗喻：</p>
<ul class="simple">
<li><p>在函数调用的语法中，<code class="docutils literal notranslate"><span class="pre">print_time(start)</span></code>表示函数是一个活跃的代理。就像是在
说“Hi, print_time! 这有一个对象需要你打印”。</p></li>
<li><p>在面向对象编程中，对象是活跃的代理。一个类似<code class="docutils literal notranslate"><span class="pre">start.print_time()</span></code>的方法
调用，就像是在说“Hi start! 请打印你自己”。</p></li>
</ul>
<p>视角的转换似乎让语气变得更文雅些了，但很难看出其好处。在前面的例子中，的确如此。
但是将职责从函数上面转移到对象上，可以更加容易地写出多样化的函数（或方法），并且代码将更加容易维护和复用。</p>
<p>我们做个练习，将 <code class="docutils literal notranslate"><span class="pre">time_to_int</span></code> （见 <a class="reference internal" href="16-classes-and-functions.html#prototype"><span class="std std-ref">原型 vs. 方案</span></a>）重写为方法。你或许也想将 <code class="docutils literal notranslate"><span class="pre">int_to_time</span></code> 改写为方法，但是那样做并没有什么意义，因为没有调用它的对象。</p>
</div>
<div class="section" id="id4">
<h2>再举一例<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>下面是 <code class="docutils literal notranslate"><span class="pre">increment</span></code> （见 <a class="reference internal" href="16-classes-and-functions.html#increment"><span class="std std-ref">修改器</span></a>）改写为方法后的代码版本：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
        <span class="n">seconds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</pre></div>
</div>
<p>这个版本假设<code class="docutils literal notranslate"><span class="pre">time_to_int</span></code>已经改成了方法。另外，注意这是一个纯函数，不是修改器。</p>
<p>下面是调用 <code class="docutils literal notranslate"><span class="pre">increment</span></code> 的方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">09:45:00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">10:07:17</span>
</pre></div>
</div>
<p>主语 <code class="docutils literal notranslate"><span class="pre">start</span></code> 被赋值给第一个形参 <code class="docutils literal notranslate"><span class="pre">self</span></code> 。实参 1337 被赋值给第二个形参 <code class="docutils literal notranslate"><span class="pre">seconds</span></code> 。</p>
<p>这个机制有时会把人弄晕，尤其是你犯错的时候。例如，如果你使用两个实参调用 <code class="docutils literal notranslate"><span class="pre">increment</span></code> ， 你会得到：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="mi">460</span><span class="p">)</span>
<span class="go">TypeError: increment() takes 2 positional arguments but 3 were given</span>
</pre></div>
</div>
<p>错误信息一开始让人很难理解，因为在括号内只有两个实参。但是主语也被认为是一个实参，所以加在一起共有三个实参。</p>
<p>另外，<strong>位置参数</strong> 是没有形参名的参数；也就是说，它不是一个关键字参数。在下面这个函数调用中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sketch</span><span class="p">(</span><span class="n">parrot</span><span class="p">,</span> <span class="n">cage</span><span class="p">,</span> <span class="n">dead</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">parrot</span></code>和 <code class="docutils literal notranslate"><span class="pre">cage</span></code>是位置参数，而 <code class="docutils literal notranslate"><span class="pre">dead</span></code> 是一个关键字参数。</p>
</div>
<div class="section" id="id5">
<h2>一个更复杂的例子<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>重写 <code class="docutils literal notranslate"><span class="pre">is_after</span></code> （见 <a class="reference internal" href="16-classes-and-functions.html#isafter"><span class="std std-ref">时间</span></a>一节）要更加复杂一些，因为它接受两个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象作为参数。在这个例子中，惯用的做法是将第一个形参命名为 <code class="docutils literal notranslate"><span class="pre">self</span></code> ，第二个形参命名为 <code class="docutils literal notranslate"><span class="pre">other</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="nf">is_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
</pre></div>
</div>
<p>要使用该方法的话，你必须在某个对象上调用它，并传入 <code class="docutils literal notranslate"><span class="pre">other</span></code> 的实参：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">end</span><span class="o">.</span><span class="n">is_after</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>这个语法有一个好处，就是它读起来很像英语：“end是出现在start之后吗？”</p>
</div>
<div class="section" id="init">
<h2>init 方法<a class="headerlink" href="#init" title="永久链接至标题">¶</a></h2>
<p>init 方法（“initialization”的简称）是一个特殊的方法，当一个对象初始化的时候调
用。它的全名是<code class="docutils literal notranslate"><span class="pre">__init__</span></code>（两个下划线后加init再加两个下划线）。
一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 类的 init 方法看起来像是这样的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">hour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minute</span> <span class="o">=</span> <span class="n">minute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>
</pre></div>
</div>
<p>通常<code class="docutils literal notranslate"><span class="pre">__init__</span></code>方法的参数和属性的名称一样。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">hour</span>
</pre></div>
</div>
<p>上面的语句把 <code class="docutils literal notranslate"><span class="pre">hour</span></code> 参数的值储存为 <code class="docutils literal notranslate"><span class="pre">self</span></code> 的一个属性。</p>
<p>参数是可选的，所以如果你不带参数的调用 <code class="docutils literal notranslate"><span class="pre">Time</span></code> ，你会得到默认值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">00:00:00</span>
</pre></div>
</div>
<p>如果你提供一个参数，它会覆盖 <code class="docutils literal notranslate"><span class="pre">hour</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">Time</span> <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">09:00:00</span>
</pre></div>
</div>
<p>如果你提供两个参数，他们会覆盖 <code class="docutils literal notranslate"><span class="pre">hour</span></code> 和 <code class="docutils literal notranslate"><span class="pre">minute</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="go">09:45:00</span>
</pre></div>
</div>
<p>如果你提供三个参数，它们会覆盖三个默认值。</p>
<p>我们做个练习，为 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 类写一个 init 方法，使用 <code class="docutils literal notranslate"><span class="pre">x</span></code> 和 <code class="docutils literal notranslate"><span class="pre">y</span></code> 作为可选参数，然后赋值给对应的属性。</p>
</div>
<div class="section" id="str">
<h2>__str__ 方法<a class="headerlink" href="#str" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">__str__</span></code>是一个和<code class="docutils literal notranslate"><span class="pre">__init__</span></code>方法类似的特殊方法，返回一个对象的字符串表现形式。</p>
<p>例如，下面是一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">str</span></code> 方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">:</span><span class="si">%.2d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
</pre></div>
</div>
<p>当你打印一个对象，Python 调用 str 方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
<span class="go">09:45:00</span>
</pre></div>
</div>
<p>写一个新类时，我总是从<code class="docutils literal notranslate"><span class="pre">__init__</span></code>开始，使得更容易实例化对象，接着就是写<code class="docutils literal notranslate"><span class="pre">__str__</span></code>方法，方便调试。</p>
<p>我们做个练习，为 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 类写一个 str 方法。然后创建一个 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 对象并打印。</p>
</div>
<div class="section" id="id6">
<h2>运算符重载<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>通过定义其它的一些特殊方法，你可以在程序员自定义类型上指定运算符的行为。
例如，如果你为 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 类定义了一个叫<code class="docutils literal notranslate"><span class="pre">__add__</span></code>的方法，你就可以在 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象上使用 + 运算符。</p>
<p>可以大致像这样定义：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">seconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</pre></div>
</div>
<p>下面是使用方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">duration</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
<span class="go">11:20:00</span>
</pre></div>
</div>
<p>当你在 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象上应用 + 运算符，Python 会调用<code class="docutils literal notranslate"><span class="pre">__add__</span></code>。
当你打印结果时，Python 会调用<code class="docutils literal notranslate"><span class="pre">__str__</span></code>。
所以实际上后台发生了很多有趣的事情！</p>
<p>改变一个运算符的行为，使其兼容程序员自定义类型，这被称为<strong>运算符重载（operator overloading）</strong>。
对于每一个运算符，Python 有一个类似<code class="docutils literal notranslate"><span class="pre">__add__</span></code>的对应的特殊方法。
更多的详情，请参考 <a class="reference external" href="http://docs.python.org/3/reference/datamodel.html#specialnames">http://docs.python.org/3/reference/datamodel.html#specialnames</a> 。</p>
<p>我们做个练习，为 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 类编写一个 add 方法。</p>
</div>
<div class="section" id="type-based-dispatch">
<h2>类型分发（type-based dispatch）<a class="headerlink" href="#type-based-dispatch" title="永久链接至标题">¶</a></h2>
<p>在上一节中，我们将两个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象相加，但是你还会想要将一个整数与 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象相加。下面这个版本的 <code class="docutils literal notranslate"><span class="pre">__add__</span></code> 会检查 <code class="docutils literal notranslate"><span class="pre">other</span></code> 的类型，并相应地调用 <code class="docutils literal notranslate"><span class="pre">add_time</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">increment</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">seconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
        <span class="n">seconds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</pre></div>
</div>
<p>内建函数 <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> 接受一个值和一个类对象，如果值是这个类的实例则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">other</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象，<code class="docutils literal notranslate"><span class="pre">__add__</span></code>调用<code class="docutils literal notranslate"><span class="pre">add_time</span></code>。
否则它假设参数是一个数字然后调用 <code class="docutils literal notranslate"><span class="pre">increment</span></code> 。
这个操作被称为<strong>类型分发（type-based dispatch）</strong>，因为它根据参数的
类型将计算任务分发给不同的方法。</p>
<p>下面是一些在不同类型上使用 + 运算符的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">duration</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
<span class="go">11:20:00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1337</span><span class="p">)</span>
<span class="go">10:07:17</span>
</pre></div>
</div>
<p>不幸的是，这个加法的实现没有交换性（commutative）。如果第一个运算数是一个整数，你会得到：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mi">1337</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
<span class="go">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;instance&#39;</span>
</pre></div>
</div>
<p>问题在于，我们不是让一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象去加一个整数，而是让一个整数去加一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对
象，但是Python不知道怎样去做。不过这个问题有一个优雅的解决方案：特殊方法 <code class="docutils literal notranslate"><span class="pre">__radd__</span></code> ，表示“右手加法”。当一个 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象在 + 运算符的右手边出现时，调用这个方法。下面是定义：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># inside class Time:</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</pre></div>
</div>
<p>接着是使用方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mi">1337</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
<span class="go">10:07:17</span>
</pre></div>
</div>
<p>我们做个练习，为 <code class="docutils literal notranslate"><span class="pre">Points</span></code> 编写一个 add 方法，使其既适用 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 对象，也适用元组：</p>
<ul class="simple">
<li><p>如果第二个运算数是一个 <code class="docutils literal notranslate"><span class="pre">Point</span></code> ，该方法将返回一个新的 <code class="docutils literal notranslate"><span class="pre">Point</span></code> ，
其<span class="math">x</span>坐标是两个运算数的<span class="math">x</span>的和，<span class="math">y</span> 以此类推。</p></li>
<li><p>如果第二个运算数是一个元组，该方法将把元组的第一个元素与<span class="math">x</span>相加，
第二个元素与<span class="math">y</span>相加，然后返回以相关结果为参数的新的 <code class="docutils literal notranslate"><span class="pre">Point</span></code> 。</p></li>
</ul>
</div>
<div class="section" id="id7">
<h2>多态性<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>类型分发在必要的时候非常有用，但是（幸运的是）它不是绝对必须的。
通常，你可以通过编写对不同参数类型都适用的函数，来避免这种情况。</p>
<p>许多我们为字符串写的函数，实际上也适用于其他序列类型。
例如，在<a class="reference internal" href="11-dictionaries.html#histogram"><span class="std std-ref">字典作为计数器集合</span></a>一节中，我们使用 <code class="docutils literal notranslate"><span class="pre">histogram</span></code> 计算了单词中每个字母出现的次数。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>
</div>
<p>这个函数也适用于列表、元组甚至是字典，只要 <code class="docutils literal notranslate"><span class="pre">s</span></code> 的元素是可哈希的，你就可以把
它用作 <code class="docutils literal notranslate"><span class="pre">d</span></code> 的键。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;egg&#39;</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">histogram</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">{&#39;bacon&#39;: 1, &#39;egg&#39;: 1, &#39;spam&#39;: 4}</span>
</pre></div>
</div>
<p>适用于多种类型的函数，被称为<strong>多态</strong>函数。
多态性有助于代码复用。例如，内建函数 <code class="docutils literal notranslate"><span class="pre">sum</span></code> 对一个序列的元素求和，只要序列中的元素支持加法即可。</p>
<p>因为 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象提供了一个 add 方法，<code class="docutils literal notranslate"><span class="pre">sum</span></code> 也可以应用于该对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">43</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t3</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">37</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="go">23:01:00</span>
</pre></div>
</div>
<p>通常，如果一个函数内所有的操作都适用于一个类型，那这个函数就能适用该类型。</p>
<p>最好的多态性是无心成柳柳成荫的，就是你发现你已经写的一个函数，在你没有预计的类型上也能使用。</p>
</div>
<div class="section" id="id8">
<h2>接口和实现<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>面向对象设计的一个目标是使得软件更容易维护，这意味着当系统的其它部分改变时程序还能正常运行，你可以修改程序满足新的需求。</p>
<p>有助于实现该目标的一个设计原则是，接口和实现分离。
对于对象，就意味着一个类提供的方法不应该依赖属性的形式。</p>
<p>例如，在本章中，我们设计了一个表示一天中时间的类。这个类提供的方法包括<code class="docutils literal notranslate"><span class="pre">time_to_int</span></code>，<code class="docutils literal notranslate"><span class="pre">is_after</span></code>和<code class="docutils literal notranslate"><span class="pre">add_time</span></code>。</p>
<p>我们有多种方式可以实现这些方法。实现的细节取决于我们如何表示时间。
在本章中，<code class="docutils literal notranslate"><span class="pre">Time</span></code> 对象的属性是 <code class="docutils literal notranslate"><span class="pre">hour</span></code> ，<code class="docutils literal notranslate"><span class="pre">minute</span></code> 和 <code class="docutils literal notranslate"><span class="pre">second</span></code> 。</p>
<p>另一种方式是，我们用一个整数表示从零点开始的秒数，来替代这些属性。
这个实现会使得一些方法（如<code class="docutils literal notranslate"><span class="pre">is_after</span></code>） 更容易编写，但也让编写其他方法变得更难。</p>
<p>在你完成一个新类后，你可能会发现有一个更好的实现。如果程序其他部分使用了你的类，
再来改变接口需要很多时间，而且容易出错。</p>
<p>但是如果你细心设计好接口，你可以改变实现而保持接口不变，这样程序的其它部分都不用改变。</p>
</div>
<div class="section" id="id9">
<h2>调试<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>在程序执行的任何时间，为一个对象添加属性都是合法的，
但是如果相同类型的对象拥有不同的属性，就会很容易出现错误。
通常一个好的做法是在 init 方法中初始化一个对象的所有属性。</p>
<p>如果你不确定一个对象是否应该有某个属性，你可以使用内建函数 <code class="docutils literal notranslate"><span class="pre">hasattr</span></code> (参见<a class="reference internal" href="15-classes-and-objects.html#hasattr"><span class="std std-ref">调试</span></a>一节)。</p>
<p>另一种访问对象属性的方法是使用内建函数 <code class="docutils literal notranslate"><span class="pre">vars</span></code> ，它接受一个对象，并返回一个将属性名称（字符串形式）到对应值的字典：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">{&#39;y&#39;: 4, &#39;x&#39;: 3}</span>
</pre></div>
</div>
<p>定义下面这段代码，可能对调试非常有用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print_attributes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">print_attributes</span></code>遍历一个对象的字典，然后打印每个属性的名称和对应的值。</p>
<p>内建函数 <code class="docutils literal notranslate"><span class="pre">getattr</span></code> 接受一个对象和一个属性名称（字符串）作为参数，然后返回该属性的值。</p>
</div>
<div class="section" id="id10">
<h2>术语表<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>面向对象的语言（object-oriented language）：</p>
<blockquote>
<div><p>提供有助于面向对象编程特性的语言，如程序员自定义类型和方法。</p>
</div></blockquote>
<p>面向对象编程（object-oriented programming）：</p>
<blockquote>
<div><p>一种编程风格，数据和处理数据的操作被组织成类和方法。</p>
</div></blockquote>
<p>方法（method）：</p>
<blockquote>
<div><p>在类定义内部定义的一个函数，必须在该类的实例上调用。</p>
</div></blockquote>
<p>主语（subject）：</p>
<blockquote>
<div><p>方法在该对象上调用。</p>
</div></blockquote>
<p>位置参数（positional argument）：</p>
<blockquote>
<div><p>不包括形参名的实参，所以不是关键字实参。</p>
</div></blockquote>
<p>运算符重载（operator overloading）：</p>
<blockquote>
<div><p>改变类似 + 的运算符，使其可以应用于程序员自定义类型。</p>
</div></blockquote>
<p>类型分发（type-based dispatch）：</p>
<blockquote>
<div><p>一种检查运算符的类型，并根据类型不同调用不同函数的编程模式。</p>
</div></blockquote>
<p>多态的（polymorphic）：</p>
<blockquote>
<div><p>描述一个可应用于多种类型的函数。</p>
</div></blockquote>
<p>信息隐藏（information hiding）：</p>
<blockquote>
<div><p>对象提供的接口不应依赖于其实现的原则，尤其是其属性的表示形式。</p>
</div></blockquote>
</div>
<div class="section" id="id11">
<h2>练习题<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<div class="section" id="id12">
<h3>习题17-1<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>可以从 <a class="reference external" href="code/Time2.py">http://thinkpython2.com/code/Time2.py</a> 下载本章的代码。修改 <code class="docutils literal notranslate"><span class="pre">Time</span></code> 类的属性，使用一个整数代表自午夜零点开始的秒数。然后修改类的方法（和 <code class="docutils literal notranslate"><span class="pre">int_to_time</span></code> 函数 ），使其适用于新的实现。你不用修改 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数中的测试代码。</p>
<p>完成之后，程序的输出应该和之前保持一致。答案： <a class="reference external" href="code/Time2_soln.py">http://thinkpython2.com/code/Time2_soln.py</a> 。</p>
</div>
<div class="section" id="kangaroo">
<span id="id13"></span><h3>习题17-2<a class="headerlink" href="#kangaroo" title="永久链接至标题">¶</a></h3>
<p>这道习题中包含了 Python 中最常见、最难找出来的错误。
编写一个叫 <code class="docutils literal notranslate"><span class="pre">Kangaroo</span></code> 的类，包含以下方法：</p>
<ol class="arabic simple">
<li><p>一个<code class="docutils literal notranslate"><span class="pre">__init__</span></code>方法，初始化一个叫<code class="docutils literal notranslate"><span class="pre">pounch_contents</span></code>的属性为空列表。</p></li>
<li><p>一个叫<code class="docutils literal notranslate"><span class="pre">put_in_pounch</span></code>的方法，将一个任意类型的对象加入<code class="docutils literal notranslate"><span class="pre">pounch_contents</span></code>
。</p></li>
<li><p>一个<code class="docutils literal notranslate"><span class="pre">__str__</span></code>方法，返回 <code class="docutils literal notranslate"><span class="pre">Kangaroo</span></code> 对象的字符串表示和 <code class="docutils literal notranslate"><span class="pre">pounch</span></code> 中的内容。</p></li>
</ol>
<p>创建两个 <code class="docutils literal notranslate"><span class="pre">Kangaroo</span></code> 对象，将它们命名为 <code class="docutils literal notranslate"><span class="pre">kanga</span></code> 和 <code class="docutils literal notranslate"><span class="pre">roo</span></code> ，然后将 <code class="docutils literal notranslate"><span class="pre">roo</span></code> 加入 <code class="docutils literal notranslate"><span class="pre">kanga</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pounch</span></code> 列表，以此测试你写的代码。</p>
<p>下载<a class="reference external" href="code/BadKangaroo.py">http://thinkpython2.com/code/BadKangaroo.py</a> 。其中有一个上述习题的答案，但是有一个又大又棘手的 bug 。找出并修正这个 bug 。</p>
<p>如果你找不到 bug ，可以下载 <a class="reference external" href="code/GoodKangaroo.py">http://thinkpython2.com/code/GoodKangaroo.py</a> ，里面解释了问题所在并提供了一个解决方案。</p>
</div>
<div class="section" id="id14">
<h3><strong>贡献者</strong><a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="18-inheritance.html" class="btn btn-neutral float-right" title="第十八章：继承" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="16-classes-and-functions.html" class="btn btn-neutral" title="第十六章：类和函数" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/language_data.js"></script>
      <script type="text/javascript" src="static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>