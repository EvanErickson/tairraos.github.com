

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十四章：文件 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第十五章：类和对象" href="15-classes-and-objects.html"/>
        <link rel="prev" title="第十三章：案例研究：数据结构选择" href="13-case-study-data-structure-selection.html"/> 

  
  <script src="static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-functions.html">第三章：函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-case-study-interface-design.html">第四章：案例研究：接口设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-conditionals-and-recursion.html">第五章：条件和递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第十四章：文件</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">持久化</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">读取和写入</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">格式化运算符</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">文件名和路径</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">捕获异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">序列化</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">管道</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">编写模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">习题14-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">习题14-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">习题14-3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="17-classes-and-methods.html">第十七章：类和方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="18-inheritance.html">第十八章：继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第十四章：文件</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第十四章：文件<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>本章将介绍“持久（persistent）”程序的概念，即永久储存数据的程序，并说明如何使用不同种类的永久存储形式，例如文件和数据库。</p>
<div class="section" id="id2">
<h2>持久化<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>目前我们所见到的大多数程序都是临时的（transient），
因为它们只运行一段时间并输出一些结果，但当它们结束时，数据也就消失了。
如果你再次运行程序，它将以全新的状态开始。</p>
<p>另一类程序是 <strong>持久（persistent）</strong> 的：它们长时间运行（或者一直在运行）；
它们至少将一部分数据记录在永久存储（如一个硬盘中）；
如果你关闭程序然后重新启动时，它们将从上次中断的地方开始继续。</p>
<p>持久程序的一个例子是操作系统，在一台电脑开机后的绝大多数时间系统都在运行。
另一个例子是网络服务器，不停地在运行，等待来自网络的请求。</p>
<p>程序保存其数据的一个最简单方法，就是读写文本文件。
我们已经接触过读取文本文件的程序；在本章，我们将接触写入文本的程序。</p>
<p>另一种方法是使用数据库保存程序的状态。本章我将介绍一个简单的数据库，
以及简化存储程序数据过程的 <code class="docutils literal notranslate"><span class="pre">pickle</span></code> 模块。</p>
</div>
<div class="section" id="id3">
<h2>读取和写入<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>文本文件是储存在类似硬盘、闪存、或者CD-ROM等永久介质上的字符序列。我们在<a class="reference internal" href="09-case-study-word-play.html#wordlist"><span class="std std-ref">读取单词列表</span></a>一节中接触了如何打开和读取文件。</p>
<p>要写入一个文件，你必须在打开文件时设置第二个参数来为 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 模式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;output.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果该文件已经存在，那么用写入模式打开它将会清空原来的数据并从新开始，所以要小心！
如果文件不存在，那么将创建一个新的文件。</p>
<p><code class="docutils literal notranslate"><span class="pre">open</span></code>会返回一个文件对象，该对象提供了操作文件的方法。<code class="docutils literal notranslate"><span class="pre">write</span></code> 方法将数据写入文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line1</span> <span class="o">=</span> <span class="s2">&quot;This here&#39;s the wattle,</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line1</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p>返回值是被写入字符的个数。文件对象将跟踪自身的位置，所以下次你调用 <code class="docutils literal notranslate"><span class="pre">write</span></code> 的时候，它会在文件末尾添加新的数据。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">line2</span> <span class="o">=</span> <span class="s2">&quot;the emblem of our land.</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line2</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p>完成文件写入后，你应该关闭文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>如果你不关闭这个文件，程序结束时它才会关闭。</p>
</div>
<div class="section" id="id4">
<h2>格式化运算符<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">write</span></code>的参数必须是字符串，所以如果想要在文件中写入其它值，
我们需要先将它们转换为字符串。最简单的法是使用 <code class="docutils literal notranslate"><span class="pre">str</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>另一个方法是使用 <strong>格式化运算符（format operator）</strong> ，即 <code class="docutils literal notranslate"><span class="pre">%</span></code>。
作用于整数时，<code class="docutils literal notranslate"><span class="pre">%</span></code> 是取模运算符，而当第一个运算数是字符串时，<code class="docutils literal notranslate"><span class="pre">%</span></code> 则是格式化运算符。</p>
<p>第一个运算数是 <strong>格式化字符串（format string）</strong> ，它包含一个或多个 <strong>格式化序列（format sequence）</strong> 。格式化序列指定了第二个运算数是如何格式化的。运算结果是一个字符串。</p>
<p>例如，格式化序列 <code class="docutils literal notranslate"><span class="pre">'%d'</span></code> 意味着第二个运算数应该被格式化为一个十进制整数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">camels</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">camels</span>
<span class="go">&#39;42&#39;</span>
</pre></div>
</div>
<p>结果是字符串 <code class="docutils literal notranslate"><span class="pre">'42'</span></code> ，需要和整数值 42 区分开来。</p>
<p>一个格式化序列可以出现在字符串中的任何位置，所以可以将一个值嵌入到一个语句中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;I have spotted </span><span class="si">%d</span><span class="s1"> camels.&#39;</span> <span class="o">%</span> <span class="n">camels</span>
<span class="go">&#39;I have spotted 42 camels.&#39;</span>
</pre></div>
</div>
<p>如果字符串中有多个格式化序列，那么第二个参数必须是一个元组。
每个格式化序列按顺序和元组中的元素对应。</p>
<p>下面的例子中使用 <code class="docutils literal notranslate"><span class="pre">'%d'</span></code> 来格式化一个整数， <code class="docutils literal notranslate"><span class="pre">'%g'</span></code> 来格式化一个浮点数，以及 <code class="docutils literal notranslate"><span class="pre">'%s'</span></code> 来格式化一个字符串：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;In </span><span class="si">%d</span><span class="s1"> years I have spotted </span><span class="si">%g</span><span class="s1"> </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;camels&#39;</span><span class="p">)</span>
<span class="go">&#39;In 3 years I have spotted 0.1 camels.&#39;</span>
</pre></div>
</div>
<p>元组中元素的个数必须等于字符串中格式化序列的个数。
同时，元素的类型也必须符合对应的格式化序列：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">TypeError: not enough arguments for format string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;dollars&#39;</span>
<span class="go">TypeError: %d format: a number is required, not str</span>
</pre></div>
</div>
<p>在第一个例子中，元组中没有足够的元素；在第二个例子中，元素的类型错误。</p>
<p>可以在 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting">https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting</a> 中了解关于格式化运算符的更多信息。
一个更为强大的方法是使用字符串的 <code class="docutils literal notranslate"><span class="pre">format</span></code> 方法，可以前往 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.format">https://docs.python.org/3/library/stdtypes.html#str.format</a> 中了解。</p>
</div>
<div class="section" id="id5">
<h2>文件名和路径<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>文件以 <strong>目录（directory）</strong> （也称为“文件夹（folder）”）的形式组织起来。
每个正在运行的程序都有一个“当前目录（current directory）”作为大多数操作的默认目录。
例如，当你打开一个文件来读取时，Python 会在当前目录下寻找这个文件。</p>
<p><code class="docutils literal notranslate"><span class="pre">os</span></code>模块提供了操作文件和目录的函数（“os”代表“operating system”）。<code class="docutils literal notranslate"><span class="pre">os.getcwd</span></code> 返回当前目录的名称：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cwd</span>
<span class="go">&#39;/home/dinsdale&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cwd</span></code>代表“current working directory”，即“当前工作目录”。
在本例中，返回的结果是 <code class="docutils literal notranslate"><span class="pre">/home/dinsdale</span></code> ，即用户名为 <code class="docutils literal notranslate"><span class="pre">dinsdale</span></code> 的主目录。</p>
<p>类似 <code class="docutils literal notranslate"><span class="pre">'/home/dinsdale'</span></code> 这样的字符串指明一个文件或者目录，叫做 <strong>路径（path）</strong> 。</p>
<p>一个简单的文件名，如 <code class="docutils literal notranslate"><span class="pre">memo.txt</span></code> ，同样被看做是一个路径，只不过是 <strong>相对路径（relative path）</strong> ，因为它是相对于当前目录而言的。如果当前目录是 <code class="docutils literal notranslate"><span class="pre">/home/dinsdale</span></code> ，那么文件名 <code class="docutils literal notranslate"><span class="pre">memo.txt</span></code> 就代表 <code class="docutils literal notranslate"><span class="pre">/home/dinsdale/memo.txt</span></code> 。</p>
<p>一个以 <code class="docutils literal notranslate"><span class="pre">/</span></code> 开头的路径和当前目录无关，叫做 <strong>绝对路径（absolute path）</strong>。要获得一个文件的绝对路径，你可以使用 <code class="docutils literal notranslate"><span class="pre">os.path.abspath</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;memo.txt&#39;</span><span class="p">)</span>
<span class="go">&#39;/home/dinsdale/memo.txt&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">os.path</span></code>还提供了其它函数来对文件名和路径进行操作。例如，<code class="docutils literal notranslate"><span class="pre">os.path.exists</span></code> 检查一个文件或者目录是否存在：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;memo.txt&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>如果存在，可以通过 <code class="docutils literal notranslate"><span class="pre">os.path.isdir</span></code> 检查它是否是一个目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;memo.txt&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s1">&#39;/home/dinsdale&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>类似的，<code class="docutils literal notranslate"><span class="pre">os.path.isfile</span></code> 检查它是否是一个文件。</p>
<p><code class="docutils literal notranslate"><span class="pre">os.listdir</span></code>返回给定目录下的文件列表（以及其它目录）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span>
<span class="go">[&#39;music&#39;, &#39;photos&#39;, &#39;memo.txt&#39;]</span>
</pre></div>
</div>
<p>接下来演示下以上函数的使用。下面的例子“遍历”一个目录，打印所有文件的名字，并且针对其中所有的目录递归的调用自身。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">walk</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">os.path.join</span></code>接受一个目录和一个文件名，并把它们合并成一个完整的路径。</p>
<p>os模块提供了一个叫做 <code class="docutils literal notranslate"><span class="pre">walk</span></code> 的函数，和我们上面写的类似，但是功能更加更富。
作为练习，阅读文档并且使用 <code class="docutils literal notranslate"><span class="pre">walk</span></code> 打印出给定目录下的文件名和子目录。
你可以从 <a class="reference external" href="code/walk.py">http://thinkpython2.com/code/walk.py</a> 下载我的答案。</p>
</div>
<div class="section" id="id6">
<h2>捕获异常<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>试图读写文件时，很多地方可能会发生错误。如果你试图打开一个不存在的文件夹，
会得到一个输入输出错误（IOError）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fin</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;bad_file&#39;</span><span class="p">)</span>
<span class="go">IOError: [Errno 2] No such file or directory: &#39;bad_file&#39;</span>
</pre></div>
</div>
<p>如果你没有权限访问一个文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="go">PermissionError: [Errno 13] Permission denied: &#39;/etc/passwd&#39;</span>
</pre></div>
</div>
<p>如果你试图打开一个目录来读取，你会得到：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fin</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/home&#39;</span><span class="p">)</span>
<span class="go">IsADirectoryError: [Errno 21] Is a directory: &#39;/home&#39;</span>
</pre></div>
</div>
<p>为了避免这些错误，你可以使用类似 <code class="docutils literal notranslate"><span class="pre">os.path.exists</span></code> 和 <code class="docutils literal notranslate"><span class="pre">os.path.isfile</span></code> 的函数来检查，但这将会耗费大量的时间和代码去检查所有的可能性（从“Errno 21”这个错误信息来看，至少有21种可能出错的情况）。</p>
<p>更好的办法是在问题出现的时候才去处理，而这正是 <code class="docutils literal notranslate"><span class="pre">try</span></code> 语句做的事情。
它的语法类似 <code class="docutils literal notranslate"><span class="pre">if...else</span></code> 语句：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">fin</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;bad_file&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Something went wrong.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Python 从 <code class="docutils literal notranslate"><span class="pre">try</span></code> 子句（clause）开始执行。
如果一切正常，那么 <code class="docutils literal notranslate"><span class="pre">except</span></code> 子句将被跳过。
如果发生异常，则跳出 <code class="docutils literal notranslate"><span class="pre">try</span></code> 子句，执行 <code class="docutils literal notranslate"><span class="pre">except</span></code> 子句。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">try</span></code> 语句处理异常被称为是 <strong>捕获（catching）</strong> 异常。
在本例中，<code class="docutils literal notranslate"><span class="pre">except</span></code> 子句打印出一个并非很有帮助的错误信息。
一般来说，捕获异常后你可以选择是否解决这个问题，或者继续尝试运行，又或者至少优雅地结束程序。</p>
</div>
<div class="section" id="id7">
<h2>数据库<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p><strong>数据库</strong>是一个用来存储数据的文件。
大多数的数据库采用类似字典的形式，即将键映射到值。
数据库和字典的最大区别是，数据库是存储在硬盘上（或者其他永久存储中），
所以即使程序结束，它们依然存在。</p>
<p><code class="docutils literal notranslate"><span class="pre">dbm</span></code>模块提供了一个创建和更新数据库文件的接口。
举个例子，我接下来创建建一个包含图片文件标题的数据库。</p>
<p>打开数据库和打开其它文件的方法类似：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dbm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span> <span class="o">=</span> <span class="n">dbm</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;captions&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>模式 <code class="docutils literal notranslate"><span class="pre">'c'</span></code> 代表如果数据库不存在则创建该数据库。
这个操作返回的是一个数据库对象，可以像字典一样使用它（对于大多数操作）。</p>
<p>当你创建一个新项时，<code class="docutils literal notranslate"><span class="pre">dbm</span></code> 将更新数据库文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;cleese.png&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Photo of John Cleese.&#39;</span>
</pre></div>
</div>
<p>当你访问某个项时，<code class="docutils literal notranslate"><span class="pre">dbm</span></code> 将读取文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;cleese.png&#39;</span><span class="p">]</span>
<span class="go">b&#39;Photo of John Cleese.&#39;</span>
</pre></div>
</div>
<p>返回的结果是一个 <strong>字节对象（bytes object）</strong> ，这就是为什么结果以 <code class="docutils literal notranslate"><span class="pre">b</span></code> 开头。
一个字节对象在很多方面都和一个字符串很像。但是当你深入了解 Python 时，
它们之间的差别会变得很重要，但是目前我们可以忽略掉那些差别。</p>
<p>如果你对已有的键再次进行赋值，<code class="docutils literal notranslate"><span class="pre">dbm</span></code> 将把旧的值替换掉：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;cleese.png&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Photo of John Cleese doing a silly walk.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="p">[</span><span class="s1">&#39;cleese.png&#39;</span><span class="p">]</span>
<span class="go">b&#39;Photo of John Cleese doing a silly walk.&#39;</span>
</pre></div>
</div>
<p>一些字典方法，例如 <code class="docutils literal notranslate"><span class="pre">keys</span></code> 和 <code class="docutils literal notranslate"><span class="pre">items</span></code> ，不适用于数据库对象，但是 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环依然适用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">db</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">db</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</pre></div>
</div>
<p>与其它文件一样，当你完成操作后需要关闭文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">db</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>序列化<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">dbm</span></code> 的一个限制在于键和值必须是字符串或者字节。
如果你尝试去用其它数据类型，你会得到一个错误。</p>
<p><code class="docutils literal notranslate"><span class="pre">pickle</span></code>模块可以解决这个问题。它能将几乎所有类型的对象转化为适合在数据库中存储的字符串，以及将那些字符串还原为原来的对象。</p>
<p><code class="docutils literal notranslate"><span class="pre">pickle.dumps</span></code>读取一个对象作为参数，并返回一个字符串表示（<code class="docutils literal notranslate"><span class="pre">dumps</span></code> 是“dump string”的缩写）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">b&#39;\x80\x03]q\x00(K\x01K\x02K\x03e.&#39;</span>
</pre></div>
</div>
<p>这个格式对人类来说不是很直观，但是对 <code class="docutils literal notranslate"><span class="pre">pickle</span></code> 来说很容易去解释。<code class="docutils literal notranslate"><span class="pre">pickle.loads</span></code> （“load string”）可以重建对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>尽管新对象和旧对象有相同的值，但它们（一般来说）不是同一个对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="ow">is</span> <span class="n">t2</span>
<span class="go">False</span>
</pre></div>
</div>
<p>换言之，序列化然后反序列化等效于复制一个对象。</p>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">pickle</span></code> 将非字符串对象存储在数据库中。
事实上，这个组合非常常用，已经被封装进了模块 <code class="docutils literal notranslate"><span class="pre">shelve</span></code> 中。</p>
</div>
<div class="section" id="id9">
<h2>管道<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>大多数的操作系统提供了一个命令行的接口，也被称为 <strong>shell</strong> 。
shell通常提供浏览文件系统和启动程序的命令。
例如，在Unix系统中你可以使用 <code class="docutils literal notranslate"><span class="pre">cd</span></code> 改变目录，使用 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 显示一个目录的内容，
通过输入 <code class="docutils literal notranslate"><span class="pre">firefox</span></code> （举例来说）来启动一个网页浏览器。</p>
<p>任何可以在shell中启动的程序，也可以在 Python 中通过使用 <strong>管道对象（pipe object）</strong> 来启动。一个管道代表着一个正在运行的程序。</p>
<p>例如，Unix 命令 <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">-l</span></code> 将以详细格式显示当前目录下的内容。
你可以使用 <code class="docutils literal notranslate"><span class="pre">os.popen</span></code> 来启动 <code class="docutils literal notranslate"><span class="pre">ls</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;ls -l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
</pre></div>
</div>
<p>实参是一个包含shell命令的字符串。返回值是一个行为类似已打开文件的对象。
你可以使用 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 来每次从 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 进程的输出中读取一行，或者使用 <code class="docutils literal notranslate"><span class="pre">read</span></code> 来一次读取所有内容：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<p>当你完成操作后，像关闭一个文件一样关闭管道：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>返回值是 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 进程的最终状态。<code class="docutils literal notranslate"><span class="pre">None</span></code> 表示正常结束（没有出现错误）。</p>
<p>例如，大多数 Unix 系统提供了一个叫做 <code class="docutils literal notranslate"><span class="pre">md5sum</span></code> 的命令，来读取一个文件的内容并计算出一个“校验和（checksum）”。
你可以在 <a class="reference external" href="http://en.wikipedia.org/wiki/Md5">http://en.wikipedia.org/wiki/Md5</a> 中了解更多MD5的信息。不同的内容产生相同校验和的概率非常小（也就是说，在宇宙坍塌之前是不可能的）。</p>
<p>你可以使用一个管道来从 Python 中运行 <code class="docutils literal notranslate"><span class="pre">md5sum</span></code> ，并得到计算结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;book.tex&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;md5sum &#39;</span> <span class="o">+</span> <span class="n">filename</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="go">1e0033f0ed0656636de0d75144ba32e0  book.tex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>编写模块<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>任何包含 Python 代码的文件，都可以作为模块被导入。
例如，假设你有包含以下代码的文件 <code class="docutils literal notranslate"><span class="pre">wc.py</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linecount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span>

<span class="nb">print</span><span class="p">(</span><span class="n">linecount</span><span class="p">(</span><span class="s1">&#39;wc.py&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>如果你运行这个程序，它将读取自身并打印文件的行数，结果是 7 。
你也可以这样导入模块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wc</span>
<span class="go">7</span>
</pre></div>
</div>
<p>现在你有了一个模块对象 <code class="docutils literal notranslate"><span class="pre">wc</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wc</span>
<span class="go">&lt;module &#39;wc&#39; from &#39;wc.py&#39;&gt;</span>
</pre></div>
</div>
<p>这个模块对象提供了 <code class="docutils literal notranslate"><span class="pre">linecount</span></code> 函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wc</span><span class="o">.</span><span class="n">linecount</span><span class="p">(</span><span class="s1">&#39;wc.py&#39;</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>以上就是如何编写 Python 模块的方法。</p>
<p>这个例子中唯一的问题在于，当你导入模块后，它将自动运行最后面的测试代码。
通常当导入一个模块时，它将定义一些新的函数，但是并不运行它们。</p>
<p>作为模块的程序通常写成以下结构：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">linecount</span><span class="p">(</span><span class="s1">&#39;wc.py&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__name__</span></code>是一个在程序开始时设置好的内建变量。
如果程序以脚本的形式运行，<code class="docutils literal notranslate"><span class="pre">__name__</span></code> 的值为 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> ，这时其中的代码将被执行。否则当被作为模块导入时，其中的代码将被跳过。</p>
<p>我们做个练习，将例子输入到文件 <code class="docutils literal notranslate"><span class="pre">wc.py</span></code> 中，然后以脚本形式运行它。
接着，打开 Python 解释器并导入 <code class="docutils literal notranslate"><span class="pre">wc</span></code> 。当模块被导入后， <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 的值是什么？</p>
<p>警示：如果你导入一个已经被导入了的模块，Python 将不会做任何事情。它并不会重新读取文件，即使文件的内容已经发生了改变。</p>
<p>如果你要重载一个模块，可以使用内建函数 <code class="docutils literal notranslate"><span class="pre">reload</span></code> ，但它可能会出错。因此最安全的方法是重启解释器，然后重新导入模块。</p>
</div>
<div class="section" id="id11">
<h2>调试<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>当你读写文件时，可能会遇到空白带来的问题。这些问题会很难调试，因为空格、制表符和换行符通常是看不见的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;1 2</span><span class="se">\t</span><span class="s1"> 3</span><span class="se">\n</span><span class="s1"> 4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">1 2  3</span>
<span class="go"> 4</span>
</pre></div>
</div>
<p>内建函数 <code class="docutils literal notranslate"><span class="pre">repr</span></code> 可以用来解决这个问题。它接受任意一个对象作为参数，然后返回一个该对象的字符串表示。对于空白符号，它将用反斜杠序列表示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="go">&#39;1 2\t 3\n 4&#39;</span>
</pre></div>
</div>
<p>这个对于调试会很有用。</p>
<p>另一个你可能会遇到的问题是，不同的的系统使用不同的符号来表示一行的结束。
有些系统使用换行符 <code class="docutils literal notranslate"><span class="pre">\n</span></code> ，有的使用返回符号 <code class="docutils literal notranslate"><span class="pre">\r</span></code> ，有些两者都使用。
如果你在不同的系统中移动文件，这些差异会导致问题。</p>
<p>对大多数的系统，有一些转换不同格式文件的应用。
你可以在 <a class="reference external" href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a> 中找到这些应用的信息（并阅读更多相关内容）。当然，你也可以自己编写一个转换程序。</p>
</div>
<div class="section" id="id12">
<h2>术语表<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>持久性（persistent）：</p>
<blockquote>
<div><p>用于描述长期运行并至少将一部分自身的数据保存在永久存储中的程序。</p>
</div></blockquote>
<p>格式化运算符（format operator）：</p>
<blockquote>
<div><p>运算符 %。读取一个格式化字符串和一个元组，生成一个包含元组中元素的字符串，按照格式化字符串的要求格式化。</p>
</div></blockquote>
<p>格式化字符串（format string）：</p>
<blockquote>
<div><p>一个包含格式化序列的字符串，和格式化运算符一起使用。</p>
</div></blockquote>
<p>格式化序列（format sequence）：</p>
<blockquote>
<div><p>格式化字符串中的一个字符序列，例如 %d ，指定了一个值的格式。</p>
</div></blockquote>
<p>文本文件（text file）：</p>
<blockquote>
<div><p>保存在类似硬盘的永久存储设备上的字符序列。</p>
</div></blockquote>
<p>目录（directory）：</p>
<blockquote>
<div><p>一个有命名的文件集合，也叫做文件夹。</p>
</div></blockquote>
<p>路径（path）：</p>
<blockquote>
<div><p>一个指定一个文件的字符串。</p>
</div></blockquote>
<p>相对路径（relative path）：</p>
<blockquote>
<div><p>从当前目录开始的路径。</p>
</div></blockquote>
<p>绝对路径（absolute path）：</p>
<blockquote>
<div><p>从文件系统顶部开始的路径。</p>
</div></blockquote>
<p>捕获（catch）：</p>
<blockquote>
<div><p>为了防止程序因为异常而终止，使用 <code class="docutils literal notranslate"><span class="pre">try</span></code> 和 <code class="docutils literal notranslate"><span class="pre">except</span></code> 语句来捕捉异常。</p>
</div></blockquote>
<p>数据库（database）：</p>
<blockquote>
<div><p>一个内容结构类似字典的文件，将键映射至对应的值。</p>
</div></blockquote>
<p>字节对象（bytes object）：</p>
<blockquote>
<div><p>和字符串类的对象。</p>
</div></blockquote>
<p>shell：</p>
<blockquote>
<div><p>一个允许用户输入命令，并通过启用其它程序执行命令的程序。</p>
</div></blockquote>
<p>管道对象（pipe object）：</p>
<blockquote>
<div><p>一个代表某个正在运行的程序的对象，允许一个 Python 程序去运行命令并得到运行结果。</p>
</div></blockquote>
</div>
<div class="section" id="id13">
<h2>练习题<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>习题14-1<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>编写一个叫做 <code class="docutils literal notranslate"><span class="pre">sed</span></code> 的函数，它的参数是一个模式字符串（pattern string），一个替换字符串和两个文件名。
它应该读取第一个文件，并将内容写入到第二个文件（需要时创建它）。
如果在文件的任何地方出现了模式字符串，就用替换字符串替换它。</p>
<p>如果在打开、读取、写入或者关闭文件时出现了错误，你的程序应该捕获这个异常，打印一个错误信息，并退出。</p>
<p>答案： <a class="reference external" href="code/sed.py">http://thinkpython2.com/code/sed.py</a> 。</p>
</div>
<div class="section" id="id15">
<h3>习题14-2<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>如果你从 <a class="reference external" href="code/anagram_sets.py">http://thinkpython2.com/code/anagram_sets.py</a> 下载了<a class="reference internal" href="12-tuples.html#anagrams"><span class="std std-ref">习题12-2</span></a>的答案，你会看到答案中创建了一个字典，
将从一个由排序后的字母组成的字符串映射到一个可以由这些字母拼成的单词组成的列表。例如， <code class="docutils literal notranslate"><span class="pre">'opst'</span></code> 映射到列表 <code class="docutils literal notranslate"><span class="pre">['opts',</span> <span class="pre">'post',</span> <span class="pre">'pots',</span> <span class="pre">'spot',</span> <span class="pre">'stop',</span> <span class="pre">'tops']</span></code> 。</p>
<p>编写一个模块，导入 <code class="docutils literal notranslate"><span class="pre">anagram_sets</span></code> 并提供两个新函数：函数 <code class="docutils literal notranslate"><span class="pre">store_anagrams</span></code> 在将 <code class="docutils literal notranslate"><span class="pre">anagram</span></code> 字典保存至 <code class="docutils literal notranslate"><span class="pre">shelf``中；</span> <span class="pre">``read_anagrams</span></code> 查找一个单词，并返回它的 <code class="docutils literal notranslate"><span class="pre">anagrams</span></code> 列表。</p>
<p>答案： <a class="reference external" href="code/anagram_db.py">http://thinkpython2.com/code/anagram_db.py</a> 。</p>
</div>
<div class="section" id="id16">
<h3>习题14-3<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>在一个很大的MP3文件集合中，或许会有同一首歌的不同拷贝，
它们存放在不同的目录下或者有不同的名字。这个练习的目的是检索出这些拷贝。</p>
<ol class="arabic simple">
<li><p>编写一个程序，搜索一个目录和它的所有子目录，并返回一个列表，列表中包含所有的有给定后缀（例如.mp3）的文件的完整路径。提示：<code class="docutils literal notranslate"><span class="pre">os.path</span></code> 提供了一些可以操作文件和路径名的函数。</p></li>
<li><p>为了识别出重复的文件，你可以使用 <code class="docutils literal notranslate"><span class="pre">md5sum</span></code> 来计算每个文件的“校验和”。如果两个文件的校验和相同，它们很可能有相同的内容。</p></li>
<li><p>你可以使用Unix命令 <code class="docutils literal notranslate"><span class="pre">diff</span></code> 再确认一下。</p></li>
</ol>
<p>答案: <a class="reference external" href="code/find_duplicates.py">http://thinkpython2.com/code/find_duplicates.py</a> 。</p>
</div>
<div class="section" id="id17">
<h3><strong>贡献者</strong><a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/obserthinker">&#64;obserthinker</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="15-classes-and-objects.html" class="btn btn-neutral float-right" title="第十五章：类和对象" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="13-case-study-data-structure-selection.html" class="btn btn-neutral" title="第十三章：案例研究：数据结构选择" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="static/jquery.js"></script>
      <script type="text/javascript" src="static/underscore.js"></script>
      <script type="text/javascript" src="static/doctools.js"></script>
      <script type="text/javascript" src="static/language_data.js"></script>
      <script type="text/javascript" src="static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>