

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第四章：案例研究：接口设计 &mdash; 《Think Python 2e》中译本 1.0 文档</title>
  

  
    <meta name="keywords" content="《Think Python》第二版中译文, Python 3版入门教材, Allen Downey, EarlGrey, 编程派">
    <meta name="description" content="编程派翻译的《Think Python 2ed》中文版，为最新支持Python 3版的教材。">
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="genindex.html"/>
        <link rel="search" title="搜索" href="search.html"/>
    <link rel="top" title="《Think Python 2e》中译本 1.0 文档" href="index.html"/>
        <link rel="next" title="第五章：条件和递归" href="05-conditionals-and-recursion.html"/>
        <link rel="prev" title="第三章：函数" href="03-functions.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

    
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1a54d19172d7819c009872071839bfe3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69612020-1', 'auto');
  ga('send', 'pageview');

</script>

    
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 《Think Python 2e》中译本
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00-preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-the-way-of-the-program.html">第一章：程序之道</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-variables-expressions-and-statements.html">第二章：变量、表达式和语句</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-functions.html">第三章：函数</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第四章：案例研究：接口设计</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#turtle">turtle模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="#repetition">简单的重复</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">封装</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">泛化</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">接口设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="#refactoring">重构</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">开发方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">文档字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id10">调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id11">术语表</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">练习题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">习题 4-1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">习题 4-2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">习题 4-3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">习题 4-4</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">习题 4-5</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18"><strong>贡献者</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="05-conditionals-and-recursion.html">第五章：条件和递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-fruitful-functions.html">第六章：有返回值的函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-iteration.html">第七章：迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-strings.html">第八章：字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-case-study-word-play.html">第九章：文字游戏</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-lists.html">第十章：列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-dictionaries.html">第十一章：字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-tuples.html">第十二章：元组</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-case-study-data-structure-selection.html">第十三章：案例研究：数据结构选择</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-files.html">第十四章：文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-classes-and-objects.html">第十五章：类和对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-classes-and-functions.html">第十六章：类和函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="17-classes-and-methods.html">第十七章：类和方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="18-inheritance.html">第十八章：继承</a></li>
<li class="toctree-l1"><a class="reference internal" href="19-the-goodies.html">第十九章：进阶小技巧</a></li>
<li class="toctree-l1"><a class="reference internal" href="20-debugging.html">第二十章：调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="21-analysis-of-algorithms.html">第二十一章：算法分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="foreword.html">译者序</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">《Think Python 2e》中译本</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>第四章：案例研究：接口设计</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第四章：案例研究：接口设计<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>本章将通过一个案例研究，介绍如何设计出相互配合的函数。</p>
<p>本章会介绍 <code class="docutils literal notranslate"><span class="pre">turtle</span></code> 模块，它可以让你使用海龟图形（turtle graphics）绘制图像。大部分的Python安装环境下都包含了这个模块，但是如果你是在PythonAnywhere上运行Python的，你将无法运行本章中的代码示例（至少在我写这章时是做不到的）。</p>
<p>如果你已经在自己的电脑上安装了Python，那么不会有问题。如果没有，现在就是安装Python的好时机。我在 <a class="reference external" href="http://tinyurl.com/thinkpython2e">http://tinyurl.com/thinkpython2e</a> 这个页面上发布了相关指南。</p>
<p>本章的示例代码可以从<a class="reference external" href="code/polygon.py">http://thinkpython2.com/code/polygon.py</a> 获得。</p>
<div class="section" id="turtle">
<h2>turtle模块<a class="headerlink" href="#turtle" title="永久链接至标题">¶</a></h2>
<p>打开Python解释器，输入以下代码，检查你是否安装了 <code class="docutils literal notranslate"><span class="pre">turltle</span></code> 模块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">turtle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bob</span> <span class="o">=</span> <span class="n">turtle</span><span class="o">.</span><span class="n">Turtle</span><span class="p">()</span>
</pre></div>
</div>
<p>上述代码运行后，应该会新建一个窗口，窗口中间有一个小箭头，代表的就是海龟。现在关闭窗口。</p>
<p>新建一个名叫  <code class="docutils literal notranslate"><span class="pre">mypolygon.py</span></code> 的文件，输入以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">turtle</span>
<span class="n">bob</span> <span class="o">=</span> <span class="n">turtle</span><span class="o">.</span><span class="n">Turtle</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span>
<span class="n">turtle</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">turtle</span></code> 模块（小写的t）提供了一个叫作 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 的函数（大写的T），这个函数会创建一个 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 对象，我们将其赋值给名为 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 的变量。打印 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 的话，会输出下面这样的结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">turtle</span><span class="o">.</span><span class="n">Turtle</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0xb7bfbf4c</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>这意味着，<code class="docutils literal notranslate"><span class="pre">bob</span></code> 指向一个类型为Turtle的对象，这个类型是由 <code class="docutils literal notranslate"><span class="pre">turtle</span></code> 模块定义的。</p>
<p><code class="docutils literal notranslate"><span class="pre">mainloop</span></code> 告诉窗口等待用户操作，尽管在这个例子中，用户除了关闭窗口之外，并没有其他可做的事情。</p>
<p>创建了一个 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 对象之后，你可以调用 <strong>方法（method）</strong> 来在窗口中移动该对象。方法与函数类似，但是其语法略有不同。例如，要让海龟向前走：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>方法 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 与我们称之为 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 的对象是相关联的。调用方法就像提出一个请求：你在请求 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 往前走。</p>
<p><code class="docutils literal notranslate"><span class="pre">fd</span></code> 方法的实参是像素距离，所以实际前进的距离取决于你的屏幕。</p>
<p><code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 对象中你能调用的其他方法还包括：让它向后走的 <code class="docutils literal notranslate"><span class="pre">bk</span></code> ，向左转的 <code class="docutils literal notranslate"><span class="pre">lt</span></code> ，向右转的 <code class="docutils literal notranslate"><span class="pre">rt</span></code> 。 <code class="docutils literal notranslate"><span class="pre">lt</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rt</span></code> 这两个方法接受的实参是角度。</p>
<p>另外，每个 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 都握着一支笔，不是落笔就是抬笔；如果落笔了，<code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 就会在移动时留下痕迹。<code class="docutils literal notranslate"><span class="pre">pu</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pd</span></code> 这两个方法分别代表“抬笔（pen up）”和“落笔（pen down）”。</p>
<p>如果要画一个直角（right angle），请在程序中添加以下代码（放在创建 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 之后，调用 <code class="docutils literal notranslate"><span class="pre">mainloop</span></code> 之前）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">bob</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>当你运行此程序时，你应该会看到 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 先朝东移动，然后向北移动，同时在身后留下两条线段（line segment）。</p>
<p>现在修改程序，画一个正方形。在没有成功之前，不要继续往下看。</p>
</div>
<div class="section" id="repetition">
<span id="id2"></span><h2>简单的重复<a class="headerlink" href="#repetition" title="永久链接至标题">¶</a></h2>
<p>很有可能你刚才写了像下面这样的一个程序：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">bob</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

<span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">bob</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

<span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">bob</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

<span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以利用一个 <code class="docutils literal notranslate"><span class="pre">for</span></code> 语句，以更简洁的代码来做相同的事情。
将下面的示例代码加入 <code class="docutils literal notranslate"><span class="pre">mypolygon.py</span></code> ，并重新运行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello!&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>你应该会看到如下输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Hello!
Hello!
Hello!
Hello!
</pre></div>
</div>
<p>这是 <code class="docutils literal notranslate"><span class="pre">for</span></code> 语句最简单的用法；后面我们会介绍更多的用法。
但是这对于让你重写画正方形的程序已经足够了。 如果没有完成，请不要往下看。</p>
<p>下面是一个画正方形的 <code class="docutils literal notranslate"><span class="pre">for</span></code> 语句：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">bob</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">bob</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
</pre></div>
</div>
<p>for语句的语法和函数定义类似。
它有一个以冒号结尾的语句头（header）以及一个缩进的语句体（body）。
语句体可以包含任意条语句。</p>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> 语句有时也被称为<strong>循环（loop）</strong>，因为执行流程会贯穿整个语句体，然后再循环回顶部。
在此例中，它将运行语句体四次。</p>
<p>这个版本事实上和前面画正方形的代码有所不同，因为它在画完正方形的最后一条边后，
又多转了一下。这个额外的转动多花了些时间，
但是如果我们每次都通过循环来做这件事情，这样反而是简化了代码。
这个版本还让海龟回到了初始位置，朝向也与出发时一致。</p>
</div>
<div class="section" id="id3">
<h2>练习<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>下面是一系列学习使用 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 的练习。
这些练习虽说是为了好玩，但是也有自己的目的。
你在做这些练习的时候，想一想它们的目的是什么。</p>
<blockquote>
<div><p>译者注：原文中使用的还是 <code class="docutils literal notranslate"><span class="pre">TurtleWorld</span></code> ，应该是作者忘了修改。</p>
</div></blockquote>
<p>后面几节中介绍了这些练习的答案，因此如果你还没完成（或者至少试过），请不要看答案。</p>
<ol class="arabic">
<li><p>写一个名为 <code class="docutils literal notranslate"><span class="pre">square</span></code> 的函数，接受一个名为 <code class="docutils literal notranslate"><span class="pre">t</span></code> 的形参，<code class="docutils literal notranslate"><span class="pre">t</span></code> 是一个海龟。
这个函数应用这只海龟画一个正方形。</p>
<p>写一个函数调用，将 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 作为实参传给 <code class="docutils literal notranslate"><span class="pre">square</span></code> ，然后再重新运行程序。</p>
</li>
<li><p>给 <code class="docutils literal notranslate"><span class="pre">square</span></code> 增加另一个名为 <code class="docutils literal notranslate"><span class="pre">length</span></code> 的形参。
修改函数体，使得正方形边的长度是 <code class="docutils literal notranslate"><span class="pre">length</span></code> ，然后修改函数调用，提供第二个实参。
重新运行程序。用一系列 <code class="docutils literal notranslate"><span class="pre">length</span></code> 值测试你的程序。</p></li>
<li><p>复制 <code class="docutils literal notranslate"><span class="pre">square</span></code> ，并将函数改名为 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 。
增加另外一个名为 <code class="docutils literal notranslate"><span class="pre">n</span></code> 的形参并修改函数体，让它画一个正n边形（n-sided regular polygon）。
提示：正n边形的外角是<span class="math">360/n</span>度。</p></li>
<li><p>编写一个名为 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 的函数，它接受一个海龟t和半径r作为形参，
然后以合适的边长和边数调用 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> ，画一个近似圆形。
用一系列r值测试你的函数。</p>
<p>提示：算出圆的周长，并确保 <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">circumference</span></code> 。</p>
</li>
<li><p>完成一个更泛化（general）的 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 函数，称其为 <code class="docutils literal notranslate"><span class="pre">arc</span></code> ，接受一个额外的参数 <code class="docutils literal notranslate"><span class="pre">angle</span></code> ，确定画多完整的圆。<code class="docutils literal notranslate"><span class="pre">angle</span></code> 的单位是度，因此当 <code class="docutils literal notranslate"><span class="pre">angle=360</span></code> 时， <code class="docutils literal notranslate"><span class="pre">arc</span></code>
应该画一个完整的圆。</p></li>
</ol>
</div>
<div class="section" id="id4">
<h2>封装<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>第一个练习要求你将画正方形的代码放到一个函数定义中,然后调用该函数，
将海龟作为形参传递给它。下面是一个解法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

<span class="n">square</span><span class="p">(</span><span class="n">bob</span><span class="p">)</span>
</pre></div>
</div>
<p>最内层的语句 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lt</span></code> 被缩进两次，以显示它们处在 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环内，
而该循环又在函数定义内。下一行 <code class="docutils literal notranslate"><span class="pre">square(bob)</span></code> 和左边界（left margin）对齐，
表示 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环和函数定义结束。</p>
<p>在函数内部，<code class="docutils literal notranslate"><span class="pre">t</span></code> 指的是同一只海龟 <code class="docutils literal notranslate"><span class="pre">bob</span></code> ， 所以 <code class="docutils literal notranslate"><span class="pre">t.lt(90)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bob.lt(90)</span></code> 的效果相同。
那么既然这样，为什么不将形参命名为 <code class="docutils literal notranslate"><span class="pre">bob</span></code> 呢？ 因为 <code class="docutils literal notranslate"><span class="pre">t</span></code> 可以是任何海龟而不仅仅是 <code class="docutils literal notranslate"><span class="pre">bob</span></code> ，
也就是说你可以创建第二只海龟，并且将它作为实参传递给 <code class="docutils literal notranslate"><span class="pre">square</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alice</span> <span class="o">=</span> <span class="n">Turtle</span><span class="p">()</span>
<span class="n">square</span><span class="p">(</span><span class="n">alice</span><span class="p">)</span>
</pre></div>
</div>
<p>将一部分代码包装在函数里被称作 <strong>encapsulation（封装）</strong>。
封装的好处之一，为这些代码赋予一个名字，
这充当了某种文档说明。另一个好处是，如果你重复使用这些代码，
调用函数两次比拷贝粘贴函数体要更加简洁！</p>
</div>
<div class="section" id="id5">
<h2>泛化<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>下一个练习是给 <code class="docutils literal notranslate"><span class="pre">square</span></code> 增加一个 <code class="docutils literal notranslate"><span class="pre">length</span></code> 形参。下面是一个解法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>

<span class="n">square</span><span class="p">(</span><span class="n">bob</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>为函数增加一个形参被称作<strong>泛化（generalization）</strong>，
因为这使得函数更通用：在前面的版本中，
正方形的边长总是一样的；此版本中，它可以是任意大小。</p>
<p>下一个练习也是泛化。泛化之后不再是只能画一个正方形，<code class="docutils literal notranslate"><span class="pre">polygon</span></code> 可以画任意的正多边形。
下面是一个解法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

<span class="n">polygon</span><span class="p">(</span><span class="n">bob</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
<p>这个示例代码画了一个边长为70的七边形。</p>
<p>如果你在使用Python 2，<code class="docutils literal notranslate"><span class="pre">angle</span></code> 的值可能由于整型数除法（integer division）出现偏差。一个简单的解决办法是这样计算 <code class="docutils literal notranslate"><span class="pre">angle</span></code> ：<code class="docutils literal notranslate"><span class="pre">angle</span> <span class="pre">=</span> <span class="pre">360.0</span> <span class="pre">/</span> <span class="pre">n</span></code>。因为分子（numerator）是一个浮点数，最终的结果也会是一个浮点数。</p>
<p>如果一个函数有几个数字实参，很容易忘记它们是什么或者它们的顺序。在这种情况下，
在实参列表中加入形参的名称是通常是一个很好的办法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polygon</span><span class="p">(</span><span class="n">bob</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
<p>这些被称作<strong>关键字实参（keyword arguments）</strong>，
因为它们加上了形参名作为“关键字”（不要和Python的关键字搞混了，如 <code class="docutils literal notranslate"><span class="pre">while</span></code> 和 <code class="docutils literal notranslate"><span class="pre">def</span></code> ）。</p>
<p>这一语法使得程序的可读性更强。它也提醒了我们实参和形参的工作方式：
当你调用函数时，实参被赋给形参。</p>
</div>
<div class="section" id="id6">
<h2>接口设计<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>下一个练习是编写接受半径r作为形参的 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 函数。
下面是一个使用 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 画一个50边形的简单解法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">circumference</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">circumference</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">polygon</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>函数的第一行通过半径r计算圆的周长，公式是<span class="math">2 \pi r</span>。
由于用了 <code class="docutils literal notranslate"><span class="pre">math.pi</span></code> ，我们需要导入 <code class="docutils literal notranslate"><span class="pre">math</span></code> 模块。
按照惯例，<code class="docutils literal notranslate"><span class="pre">import</span></code> 语句通常位于脚本的开始位置。</p>
<p>n是我们的近似圆中线段的条数， <code class="docutils literal notranslate"><span class="pre">length</span></code> 是每一条线段的长度。
这样 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 画出的就是一个50边形，近似一个半径为r的圆。</p>
<p>这种解法的一个局限在于，n是一个常量，意味着对于非常大的圆，
线段会非常长，而对于小圆，我们会浪费时间画非常小的线段。
一个解决方案是将n作为形参，泛化函数。
这将给用户（调用 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 的人）更多的掌控力， 但是接口就不那么干净了。</p>
<p>函数的<strong>接口（interface）</strong>是一份关于如何使用该函数的总结：
形参是什么？函数做什么？返回值是什么？
如果接口让调用者避免处理不必要的细节，直接做自己想做的事，那么这个接口就是“干净的”。</p>
<p>在这个例子中，<code class="docutils literal notranslate"><span class="pre">r</span></code> 属于接口的一部分，因为它指定了要画多大的圆。
n就不太合适，因为它是关于 <strong>如何</strong> 画圆的细节。</p>
<p>与其把接口弄乱，不如根据周长（circumference）选择一个合适的n值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">circumference</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">circumference</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">circumference</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">polygon</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>现在线段的数量，是约为周长三分之一的整型数，
所以每条线段的长度（大概）是3，小到足以使圆看上去逼真，
又大到效率足够高，对任意大小的圆都能接受。</p>
</div>
<div class="section" id="refactoring">
<span id="id7"></span><h2>重构<a class="headerlink" href="#refactoring" title="永久链接至标题">¶</a></h2>
<p>当我写 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 程序的时候，我能够复用 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> ，
因为一个多边形是与圆形非常近似。
但是 <code class="docutils literal notranslate"><span class="pre">arc</span></code> 就不那么容易实现了；我们不能使用 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">circle</span></code> 来画一个弧。</p>
<p>一种替代方案是从复制 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 开始，
然后将它转化为 <code class="docutils literal notranslate"><span class="pre">arc</span></code> 。最后的函数看上去可像这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">arc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="n">arc_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">angle</span> <span class="o">/</span> <span class="mi">360</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arc_length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">step_length</span> <span class="o">=</span> <span class="n">arc_length</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">step_angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">/</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">step_length</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">step_angle</span><span class="p">)</span>
</pre></div>
</div>
<p>该函数的后半部分看上去很像 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> ，
但是在不改变接口的条件下，我们无法复用 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 。
我们可以泛化 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 来接受一个角度作为第三个实参，
但是这样 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 就不再是一个合适的名字了！
让我们称这个更通用的函数为 <code class="docutils literal notranslate"><span class="pre">polyline</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polyline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p>现在，我们可以用 <code class="docutils literal notranslate"><span class="pre">polyline</span></code> 重写 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 和 <code class="docutils literal notranslate"><span class="pre">arc</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mf">360.0</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">polyline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">arc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="n">arc_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">angle</span> <span class="o">/</span> <span class="mi">360</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arc_length</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">step_length</span> <span class="o">=</span> <span class="n">arc_length</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">step_angle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">polyline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">step_length</span><span class="p">,</span> <span class="n">step_angle</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，我们可以用 <code class="docutils literal notranslate"><span class="pre">arc</span></code> 重写 <code class="docutils literal notranslate"><span class="pre">circle</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">arc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">360</span><span class="p">)</span>
</pre></div>
</div>
<p>重新整理一个程序以改进函数接口和促进代码复用的这个过程，
被称作<strong>重构（refactoring）</strong>。
在此例中，我们注意到 <code class="docutils literal notranslate"><span class="pre">arc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">polygon</span></code> 中有相似的代码，
因此，我们“将它分解出来”（factor it out），放入 <code class="docutils literal notranslate"><span class="pre">polyline</span></code> 函数。</p>
<p>如果我们提前已经计划好了，我们可能会首先写 <code class="docutils literal notranslate"><span class="pre">polyline</span></code> 函数，避免重构，
但是在一个项目开始的时候，你常常并不知道那么多，不能设计好全部的接口。
一旦你开始编码后，你才能更好地理解问题。
有时重构是一个说明你已经学到某些东西的预兆。</p>
</div>
<div class="section" id="id8">
<h2>开发方案<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p><strong>开发计划（development plan）</strong>是一种编写程序的过程。
此例中我们使用的过程是“封装和泛化”。 这个过程的具体步骤是：</p>
<ol class="arabic simple">
<li><p>从写一个没有函数定义的小程序开始。</p></li>
<li><p>一旦该程序运行正常，找出其中相关性强的部分，将它们封装进一个函数并给它一个名字。</p></li>
<li><p>通过增加适当的形参，泛化该函数。</p></li>
<li><p>重复1–3步，直到你有一些可正常运行的函数。
复制粘贴有用的代码，避免重复输入（和重新调试）。</p></li>
<li><p>寻找机会通过重构改进程序。
例如，如果在多个地方有相似的代码，考虑将它分解到一个合适的通用函数中。</p></li>
</ol>
<p>这个过程也有一些缺点。后面我们将介绍其他替代方案，
但是如果你事先不知道如何将程序分解为函数，这是个很有用办法。
该方法可以让你一边编程，一边设计。</p>
</div>
<div class="section" id="id9">
<h2>文档字符串<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p><strong>文档字符串（docstring）</strong>是位于函数开始位置的一个字符串，
解释了函数的接口（“doc”是“documentation”的缩写）。 下面是一个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polyline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draws n line segments with the given length and</span>
<span class="sd">    angle (in degrees) between them.  t is a turtle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p>按照惯例，所有的文档字符串都是三重引号（triple-quoted）字符串，也被称为多行字符串，
因为三重引号允许字符串超过一行。</p>
<p>它很简要（terse），但是包括了他人使用此函数时需要了解的关键信息。
它扼要地说明该函数做什么（不介绍背后的具体细节）。
它解释了每个形参对函数的行为有什么影响，以及每个形参应有的类型
（如果它不明显的话）。</p>
<p>写这种文档是接口设计中很重要的一部分。 一个设计良好的接口应该很容易解释，
如果你很难解释你的某个函数，那么你的接口也许还有改进空间。</p>
</div>
<div class="section" id="id10">
<h2>调试<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>接口就像是函数和调用者之间的合同。
调用者同意提供合适的参数，函数同意完成相应的工作。</p>
<p>例如，<code class="docutils literal notranslate"><span class="pre">polyline</span></code> 函数需要4个实参：<code class="docutils literal notranslate"><span class="pre">t</span></code> 必须是一个 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> ；
<code class="docutils literal notranslate"><span class="pre">n</span></code> 必须是一个整型数； <code class="docutils literal notranslate"><span class="pre">length</span></code> 应该是一个正数；
<code class="docutils literal notranslate"><span class="pre">angle</span></code> 必须是一个数，单位是度数。</p>
<p>这些要求被称作<strong>先决条件（preconditions）</strong>，
因为它们应当在函数开始执行之前成立（true）。
相反，函数结束时的条件是<strong>后置条件（postconditions）</strong>。
后置条件包括函数预期的效果（如画线段）以及任何其他附带效果
（如移动 <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 或者做其它改变）。</p>
<p>先决条件由调用者负责满足。如果调用者违反一个（已经充分记录文档的！）
先决条件，导致函数没有正确工作，则故障（bug）出现在调用者一方，而不是函数。</p>
<p>如果满足了先决条件，没有满足后置条件，故障就在函数一方。如果你的先决条件和后置条件都很清楚，将有助于调试。</p>
</div>
<div class="section" id="id11">
<h2>术语表<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>方法（method）：</p>
<blockquote>
<div><p>与对象相关联的函数，并使用点标记法（dot notation）调用。</p>
</div></blockquote>
<p>循环（loop）：</p>
<blockquote>
<div><p>程序中能够重复执行的那部分代码。</p>
</div></blockquote>
<p>封装（encapsulation）：</p>
<blockquote>
<div><p>将一个语句序列转换成函数定义的过程。</p>
</div></blockquote>
<p>泛化（generalization）：</p>
<blockquote>
<div><p>使用某种可以算是比较通用的东西（像变量和形参），替代某些没必要那么具体的东西（像一个数字）的过程。</p>
</div></blockquote>
<p>关键字实参（keyword argument）：</p>
<blockquote>
<div><p>包括了形参名称作为“关键字”的实参。</p>
</div></blockquote>
<p>接口（interface）：</p>
<blockquote>
<div><p>对如何使用一个函数的描述，包括函数名、参数说明和返回值。</p>
</div></blockquote>
<p>重构（refactoring）：</p>
<blockquote>
<div><p>修改一个正常运行的函数，改善函数接口及其他方面代码质量的过程。</p>
</div></blockquote>
<p>开发计划（development plan）：</p>
<blockquote>
<div><p>编写程序的一种过程。</p>
</div></blockquote>
<p>文档字符串（docstring）：</p>
<blockquote>
<div><p>出现在函数定义顶部的一个字符串，用于记录函数的接口。</p>
</div></blockquote>
<p>先决条件（preconditions）：</p>
<blockquote>
<div><p>在函数运行之前，调用者应该满足的要求。
ends.</p>
</div></blockquote>
<p>后置条件（postconditions）：</p>
<blockquote>
<div><p>函数终止之前应该满足的条件。</p>
</div></blockquote>
</div>
<div class="section" id="id12">
<h2>练习题<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="section" id="id13">
<h3>习题 4-1<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>可从<a class="reference external" href="code/polygon.py">http://thinkpython2.com/code/polygon.py</a> 下载本章的代码。</p>
<ol class="arabic simple">
<li><p>画一个执行 <code class="docutils literal notranslate"><span class="pre">circle(bob,</span> <span class="pre">radius)</span></code> 时的堆栈图（stack diagram），说明程序的各个状态。你可以手动进行计算，也可以在代码中加入打印语句。</p></li>
<li><p>“重构”一节中给出的 <code class="docutils literal notranslate"><span class="pre">arc</span></code> 函数版本并不太精确，因为圆形的线性近似（linear approximation）永远处在真正的圆形之外。因此，<code class="docutils literal notranslate"><span class="pre">Turtle</span></code> 总是和正确的终点相差几个像素。我的答案中展示了降低这个错误影响的一种方法。阅读其中的代码，看看你是否能够理解。如果你画一个堆栈图的话，你可能会更容易明白背后的原理。</p></li>
</ol>
</div>
<div class="section" id="id14">
<h3>习题 4-2<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<div class="figure align-default" id="id19">
<img alt="使用Turtle绘制的花朵。" src="_images/flowers.png" />
<p class="caption"><span class="caption-text">图4-1：使用Turtle绘制的花朵。</span><a class="headerlink" href="#id19" title="永久链接至图片">¶</a></p>
</div>
<p>编写比较通用的一个可以画出像图4-1中那样花朵的函数集。</p>
<p>答案： <a class="reference external" href="code/flower.py">http://thinkpython2.com/code/flower.py</a> ，还要求使用这个模块
<a class="reference external" href="code/polygon.py">http://thinkpython2.com/code/polygon.py</a>.</p>
</div>
<div class="section" id="id15">
<h3>习题 4-3<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<div class="figure align-default" id="id20">
<img alt="图4-2：使用Turtle画的饼状图。" src="_images/pies.png" />
<p class="caption"><span class="caption-text">图4-2：使用Turtle画的饼状图。</span><a class="headerlink" href="#id20" title="永久链接至图片">¶</a></p>
</div>
<p>编写比较通用的一个可以画出图4-2中那样图形的函数集，。</p>
<p>答案： <a class="reference external" href="code/pie.py">http://thinkpython2.com/code/pie.py</a> 。</p>
</div>
<div class="section" id="id16">
<h3>习题 4-4<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>字母表中的字母可以由少量基本元素构成，例如竖线和横线，以及一些曲线。
设计一种可用由最少的基本元素绘制出的字母表，然后编写能画出各个字母的函数。</p>
<p>你应该为每个字母写一个函数，起名为<code class="docutils literal notranslate"><span class="pre">draw_a</span></code>，<code class="docutils literal notranslate"><span class="pre">draw_b</span></code>等等，
然后将你的函数放在一个名为 <code class="docutils literal notranslate"><span class="pre">letters.py</span></code> 的文件里。
你可以从<a class="reference external" href="code/typewriter.py">http://thinkpython2.com/code/typewriter.py</a>
下载一个“海龟打字员”来帮你测试代码。</p>
<p>你可以在 <a class="reference external" href="code/letters.py">http://thinkpython2.com/code/letters.py</a> 中找到答案；这个解法还要求使用 <a class="reference external" href="code/polygon.py">http://thinkpython2.com/code/polygon.py</a> 。</p>
</div>
<div class="section" id="id17">
<h3>习题 4-5<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>前往<a class="reference external" href="http://en.wikipedia.org/wiki/Spiral">http://en.wikipedia.org/wiki/Spiral</a> 阅读螺线（spiral）的相关知识；
然后编写一个绘制阿基米德螺线（或者其他种类的螺线）的程序。</p>
<p>答案：<a class="reference external" href="code/spiral.py">http://thinkpython2.com/code/spiral.py</a> 。</p>
</div>
<div class="section" id="id18">
<h3><strong>贡献者</strong><a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li><p>翻译：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>校对：<a class="reference external" href="https://github.com/bingjin">&#64;bingjin</a></p></li>
<li><p>参考：<a class="reference external" href="https://github.com/carfly">&#64;carfly</a></p></li>
</ol>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="05-conditionals-and-recursion.html" class="btn btn-neutral float-right" title="第五章：条件和递归" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="03-functions.html" class="btn btn-neutral" title="第三章：函数" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, EarlGrey et.al@codingpy.com.
      最后更新于 5月 31, 2020.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>