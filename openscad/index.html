<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>OpenSCAD语法参考</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div id="content">
    <h1><a name="openscad语法参考"></a>OpenSCAD语法参考</h1>
    <ol start=''>
        <li> OpenSCAD 语言
            <ol start=''>
                <li><a href="#openscad用户手册综述">综述</a> - 先行阅读 - <a href="#注释">注释</a>, <a href="#数值与数据类型">数值与数据类型</a>, <a href="#变量">变量</a>, <ahref="#向量">向量</a>,
                    <a href="#获取输入">获取输入</a></li>
            </ol>
        </li>
        <li> 3D 模型
            <ol start=''>
                <li><a href="#openscad用户手册3d-基础模型">3D 基础模型</a> - <a href="#立方体">立方体</a>, <a href="#球体">球体</a>, <a href="#圆柱体">圆柱体</a>, <ahref="#多面体">多面体</a></li>
                <li><a href="#openscad用户手册3d-到-2d-投射">3D 到 2D 投射</a></li>
            </ol>
        </li>
        <li> 2D 模型
            <ol start=''>
                <li><a href="#openscad用户手册二维基础图形">2D 基础模型</a> - <a href="#方形">方形</a>, <a href="#圆形">圆形</a>, <a href="#多边形">多边形</a></li>
                <li><a href="#openscad用户手册文本">文本</a> - 利用已安装或用户指定的字体文件生成文本。</li>
                <li><a href="#openscad用户手册2d-到-3d-拉伸">2D 到 3D 拉伸</a></li>
            </ol>
        </li>
        <li> 变换
            <ol start=''>
                <li><a href="#color">color</a></li>
                <li><a href="#rotate">rotate</a>, <a href="#translate">translate</a>, <a href="#mirror">mirror</a>, <a href="#multmatrix">multmatrix</a>
                </li>
                <li><a href="#scale">scale</a>, <a href="#resize">resize</a></li>
                <li><a href="#offset">offset</a>, <a href="#minkowski">minkowski</a>, <a href="#hull">hull</a></li>
                <li><a href="#组合变换">组合变换</a></li>
            </ol>
        </li>
        <li> 逻辑组合
            <ol start=''>
                <li><a href="#union">union</a>, <a href="#difference">difference</a>, <a href="#intersection">intersection</a>, <a href="#render">render</a>
                </li>
            </ol>
        </li>
        <li> 其他函数与运算
            <ol start=''>
                <li>
                    <p><a href="#openscad用户手册条件与迭代函数">条件与迭代</a> - <a href="#for循环">for</a>,<a href="#intersectionfor循环"> intersection_for</a>,
                        <a href="#if语句">if</a>, <a href="#条件语句-">conditional ? :</a>,
                        <a href="#assign语句">assign</a></p>
                </li>
                <li>
                    <p><a href="#openscad用户手册数学运算符">数学运算</a> - <a href="#openscad用户手册数学运算符">常见算符</a>, <a href="#向量运算符">向量运算符</a>, <a href="#矩阵乘法">矩阵乘法</a>
                    </p>
                </li>
                <li><a href="#openscad用户手册数学函数">数学函数</a>
                    <ol start=''>
                        <li><a href="#三角函数">三角函数</a> (cos sin tan acos asin atan atan2)</li>
                        <li><a href="#其他数学函数">其他数学函数</a> (abs ceil concat cross exp floor ln len let log lookup max min norm pow rands round sign sqrt)</li>
                    </ol>
                </li>
                <li>
                    <p><a href="#openscad用户手册字符串函数">字符串函数</a> - <a href="#str">str</a>, <a href="#chr">chr</a></p>
                </li>
                <li>
                    <p><a href="#openscad用户手册其他语言特性">其他语言特性</a> - <a href="#特殊变量">以&#39;$&#39;开头的特殊变量</a>,
                        <a href="#echo语句">echo</a>，<a href="#render">render</a>，<a href="#surface">surface</a>，<a href="#search">search</a>，<ahref="#openscad版本">version(), version_num()</a>，<a href="#parentmodulen-与-parentmodules">parent_module(n) 与 $parent_modules</a>
                    </p>
                </li>
            </ol>
        </li>
        <li>
            <p><a href="#openscad用户手册用户自定义函数及模块">用自户定义函数及模块</a> - <a href="#函数">Functions</a>, <a href="#模块">Modules</a>, <a href="#children">Children</a>
            </p>
        </li>
        <li>
            <p><a href="#openscad用户手册svg导入">SVG导入</a> / <a href="#openscad用户手册stl导出">STL导出</a></p>
        </li>
    </ol>
    <hr />
    <h1><a name="openscad用户手册综述"></a>OpenSCAD用户手册/综述</h1>
    <h3><a name="目录"></a>目录</h3>
    <ul>
        <li><a href="#简介">1 简介</a></li>
        <li><a href="#注释">2 注释</a></li>
        <li><a href="#数值与数据类型">3 数值与数据类型</a>
            <ul>
                <li><a href="#数">3.1 数</a></li>
                <li><a href="#布尔值">3.2 布尔值</a></li>
                <li><a href="#字符串">3.3 字符串</a></li>
                <li><a href="#范围">3.4 范围</a></li>
                <li><a href="#未定义值">3.5 未定义值</a></li>
            </ul>
        </li>
        <li><a href="#变量">4 变量</a>
            <ul>
                <li><a href="#未定义变量">4.1 未定义变量</a></li>
                <li><a href="#变量的作用域">4.2 变量的作用域</a></li>
                <li><a href="#设置变量发生在编译时，而非运行时">4.3 设置变量发生在编译时，而非运行时</a></li>
                <li><a href="#特殊变量">4.4 特殊变量</a></li>
            </ul>
        </li>
        <li><a href="#向量">5 向量</a>
            <ul>
                <li><a href="#向量操作符">5.1 向量操作符</a>
                    <ul>
                        <li><a href="#concat">5.1.1 concat</a></li>
                        <li><a href="#len">5.1.2 len</a></li>
                    </ul>
                </li>
                <li><a href="#矩阵">5.2 矩阵</a></li>
            </ul>
        </li>
        <li><a href="#获取输入">6 获取输入</a></li>
    </ul>
    <h3><a name="简介"></a>简介</h3>
    <hr />
    <p>OpenSCAD是一款<a target="wikibook" href="https://zh.wikipedia.org/wiki/2D_computer_graphics">2D</a>/<a target="wikibook"href="https://zh.wikipedia.org/wiki/3D_computer_graphics_software">3D</a>与<a target="wikibook"href="https://zh.wikipedia.org/wiki/Solid_modeling">实体建模</a>程序，它基于<a target="wikibook"href="https://zh.wikipedia.org/wiki/Functional_programming">函数式编程</a><a target="wikibook"href="https://zh.wikipedia.org/wiki/Procedural_modeling">语言</a>来创建<a target="wikibook"href="https://zh.wikipedia.org/wiki/Polygonal_modeling">模型</a>并为之提供屏幕预览，又能将其渲染为3D<a target="wikibook"href="https://zh.wikipedia.org/wiki/Polygon_mesh">网格</a>，借此可将模型以各种2D/3D文件格式导出。</p>
    <p>OpenSCAD用一种脚本来创建2D或3D模型。该脚本实质是一系列动作语句的自由格式列表。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> object();</div>
        <div class="codeLine"> variable = value;</div>
        <div class="codeLine"> operator() &nbsp; action();</div>
        <div class="codeLine"> operator() { action(); &nbsp; action(); }</div>
        <div class="codeLine"> operator() &nbsp; operator() { action(); action(); }</div>
        <div class="codeLine"> operator() { operator() &nbsp; action();</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator() { action(); action(); } }</div>
    </div>
    <p>对象（object）是模型的基本组成单元，由2D与3D图元（primitive）创建而成。对象以分号&#39;;&#39;结尾。</p>
    <p>动作（action）语句包括利用图元创建对象以及为变量赋值。动作语句同样以分号&#39;;&#39;作为结尾。</p>
    <p>运算符（operator）或称变换（transformation），用于修改对象的位置、颜色以及其他属性。当运算符的工作域中存在一个以上的动作，就要用大括号&#39;{}&#39;将其圈定起来。多个运算符可执行相同的动作，也可构成一组不同的动作。多个运算符按由右至左的顺序处理，即，离动作最近的运算符率先执行。运算符结尾不加分号&#39;;&#39;，但是不同的动作间要加分号。
    </p>
    <div class="CodeMirror-code">
        <div class="codeLine"> 示例</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> &nbsp; cube(5);</div>
        <div class="codeLine"> &nbsp; x = 4+y;</div>
        <div class="codeLine"> &nbsp; rotate(40) square(5,10);</div>
        <div class="codeLine"> &nbsp; translate([10,5]) { circle(5); square(4); }</div>
        <div class="codeLine"> &nbsp; rotate(60) color("red") { circle(5); square(4); }</div>
        <div class="codeLine"> &nbsp; color("blue") { translate([5,3,0]) sphere(5); rotate([45,0,45]) { cylinder(10); cube([5,6,7]); } }</div>
    </div>
    <h3><a name="注释"></a>注释</h3>
    <hr />
    <p>注释是一种在脚本或代码中（为你自己或未来研究代码的程序员）撰写备注的方式，可用它来描述代码的工作流程或具体行为。编译器会跳过注释，且用户也不应为逻辑一目了然的代码添加注释。</p>
    <p>OpenSCAD采用C++-风格的注释</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 这是一行注释</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">myvar = 10; // 本行的后续部分是一条注释</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">/*</div>
        <div class="codeLine"> &nbsp; 多行注释</div>
        <div class="codeLine"> &nbsp; 可跨多行</div>
        <div class="codeLine">*/</div>
    </div>
    <h3><a name="数值与数据类型"></a>数值与数据类型</h3>
    <hr />
    <p>OpenSCAD中，一个数值的类型可能是一个数Number (如42), 一个布尔值Boolean (如true), 一个字符串String (如&quot;foo&quot;), 一个范围Range (如[0: 1: 10]), 一个向量Vector (如[1,2,3]),或未定义值Undefined value (undef)。值可存于变量之中，随之作为参数传入函数，再以函数计算结果返回。</p>
    <p>[OpenSCAD是一种有着固定数据类型集的动态类型语言。不存在类型名，也没有用户定义类型。Functions are not values. 事实上，变量与函数各占据着无交集的命名空间。]</p>
    <h3><a name="数"></a>数</h3>
    <p>数（number）是OpenSCAD中最重要的数值类型，其书写方式与其他语言中常用的十进制表示法相同。例如，-1, 42, 0.5, 2.99792458e+8。[OpenSCAD不支持数的八进制与十六进制表示法。]</p>
    <p>除了十进制数以外，下列名称定义的是一些特殊值：</p>
    <ul>
        <li>PI</li>
    </ul>
    <p>OpenSCAD仅支持一种数型，即64位的IEEE浮点数。[OpenSCAD既非将整数与浮点数区分开来，也不支持复数]由于OpenSCAD采用IEEE浮点数标准，因此在数学计算上就会有少量偏差：</p>
    <ul>
        <li>我们使用二进制浮点数计算法。对于分数而言，只有分母是2的次方时，才能精确地表示出来。例如，0.2 (2/10)的内部表示并不精准，但0.25 (1/4)与0.125 (1/8)却可以精确表示出来。</li>
        <li>可表示的最大数约为1e308。如果计算的数值结果过大，那么将视之为正无穷（打印的反馈结果为inf）。</li>
        <li>可表示的最小数约为-1e308。如果计算的数值结果过小，那么将视之为负无穷（打印的反馈结果为-inf）。</li>
        <li>如果数值的计算结果无效，那么其结果可能是非数值（打印的反馈结果为nan）</li>
        <li>如果一个非零的计算数值结果过于接近0而无法表示，那么当结果为负值时其值为-0，否则其值为0。在一些数学计算中，零(0)与负零(-0)是两种截然不同的数。而且尽管两者比较起来相等，但是打印的反馈结果却不相同。</li>
    </ul>
    <p>请注意，尽管能够通过计算数值从打印的反馈结果中看到&#39;inf&#39;与&#39;nan&#39;，但是，在OpenSCAD中并不支持这两种数值常量。您可以按以下方式，用这些数值来定义变量：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">inf = 1e200 * 1e200;</div>
        <div class="codeLine">nan = 0 / 0;</div>
        <div class="codeLine">echo(inf,nan);</div>
    </div>
    <p>请注意，&#39;nan&#39;是OpenSCAD中唯一一种不等于其他任意值的值（包括它自己在内）。尽管您可以通过&#39;x == undef&#39;来检测变量&#39;x&#39;是否为未定义值，但是却不能利用&#39;x ==0/0&#39;来检测x是否并非一个数。对此，您必须要通过&#39;x != x&#39;来检测x是否为一个nan。</p>
    <h3><a name="布尔值"></a>布尔值</h3>
    <p>布尔值皆为真值。OpenSCAD中支持两种布尔值，分别名为<code>true</code>与<code>false</code>。 一个布尔值能以参数的形式传入条件语句&#39;if()&#39;、条件运算符&#39;?:&#39;以及逻辑运算符&#39;!&#39;(非)、&#39;&amp;&amp;&#39;(与)、&#39;||&#39;(或)。事实上，在上述所有的结构中，您都可以传入任意量值。大多数数值都会转换为布尔值下的&#39;true&#39;，而将值视作&#39;false&#39;的情况有：
    </p>
    <ul>
        <li>false</li>
        <li>0 and -0</li>
        <li>&quot;&quot;</li>
        <li>[]</li>
        <li>undef</li>
    </ul>
    <p>请注意，<code>&quot;false&quot;</code> (此字符串), <code>[0]</code> (一个数值向量), <code>[ [] ]</code> (内含一个空向量的向量),
        <code>[false]</code> (内含布尔值false的向量)与0/0 (并非一个数)都计作true。</p>
    <h3><a name="字符串"></a>字符串</h3>
    <p>一个字符串为0个或多个unicode字符所构成的序列。字符串值常用于在导入文件时确定文件名，以及为调试目的而在使用echo()时显示文本。字符串亦可与<strong>2015.03</strong>版加入的<ahref="#openscad用户手册文本">新式<strong>text()</strong>图元</a>配合使用。</p>
    <p>通过双引号<code>&quot;</code>围起字符序列来编写一个字符串字面值, 就像这样: <code>&quot;&quot;</code> (一个空字符串), 或者<code>&quot;this is a string&quot;</code>.</p>
    <p>为了将<code>&quot;</code>字符包括在字符串字面值里，要这样写<code>\&quot;</code>。为了将<code>\</code>字符包括在字符串字面值里, 要这样写<code>\\</code>。下列以<code>\</code>开头的转义序列即可用在字符串字面值里：
    </p>
    <ul>
        <li>&quot; &quot;</li>
        <li>\ \</li>
        <li>\t 水平制表符（tab）</li>
        <li>\n 换行（newline）</li>
        <li>\r 回车（carriage return）</li>
        <li>\u03a9 Ω - 关于unicode字符的进一步信息请参见<strong>text()</strong></li>
    </ul>
    <p>请注意: 这是自OpenSCAD-2011.04版开始新加入的行为。您可以通过下列sed命令来更新旧文件: <code>sed &#39;s/\\/\\\\/g&#39; non-escaped.scad &gt; escaped.scad</code></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> 示例:</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> echo("The quick brown fox \tjumps \"over\" the lazy dog.\rThe quick brown fox.\nThe \\lazy\\ dog.");</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> 结果</div>
        <div class="codeLine">​</div>
        <div class="codeLine"> &nbsp; ECHO: "The quick brown fox &nbsp; &nbsp; jumps "over" the lazy dog.</div>
        <div class="codeLine"> &nbsp; The quick brown fox.</div>
        <div class="codeLine"> &nbsp; The \lazy\ dog."</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> 旧结果</div>
        <div class="codeLine"> &nbsp; ECHO: "The quick brown fox \tjumps \"over\" the lazy dog.</div>
        <div class="codeLine"> &nbsp; The quick brown fox.\nThe \\lazy\\ dog."</div>
    </div>
    <h3><a name="范围"></a>范围</h3>
    <p>范围（Range）常用于<a href="#for循环">for()循环</a>与<a href="#children">children()</a>。它们有两种变体形式:</p>
    <p>尽管由方括号[]包裹，它们却并非向量。这是因为它们用冒号:作为分隔符，而非句号。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">r1 = [0:10];</div>
        <div class="codeLine">r2 = [0.5:2.5:20];</div>
        <div class="codeLine">echo(r1); // ECHO: [0: 1: 10]</div>
        <div class="codeLine">echo(r2); // ECHO: [0.5: 2.5: 20]</div>
    </div>
    <p>您应当避免采用不能被表示为精确二进制浮点数的步长值（step）。使用整数没有问题，因为其分数中分母部分都为2的次方。例如，0.25 (1/4) 与 0.125 (1/8)都是安全的，但是应避免使用0.2(2/10)这类值。若使用不能精确表示的步长值，由于计算误差的原因，将导致您所使用的范围内可能存在比预期更多或更少的元素。</p>
    <p>若不填写&lt;<em>increment</em>&gt;，其默认值为1。若采用[&lt;<em>start</em>&gt;:&lt;<em>end</em>&gt;]形式表示范围，且&lt;<em>start</em>&gt;值大于&lt;<em>end</em>&gt;值，这将生成一个警告，而其实际逻辑则等价于[&lt;<em>end</em>&gt;:1:&lt;<em>start</em>&gt;]。若采用[&lt;<em>start</em>&gt;:1:&lt;<em>end</em>&gt;]形式表示范围，且&lt;<em>start</em>&gt;值大于&lt;<em>end</em>&gt;值，这将生成一个警告，而实际逻辑则等价于[]。对于OpenSCAD2014之后的版本而言，范围中的&lt;<em>increment</em>&gt;可取负值。</p>
    <h3><a name="未定义值"></a>未定义值</h3>
    <p>未定义值是一种记作<strong>undef</strong>的特殊值。它是未被赋值的变量的初始值，常用作传有非法参数的函数或运算所返回的结果。最后要提到的是，可将<code>undef</code>用作一个空（null）值，这等价于其他编程语言中的<code>null</code>或<code>NULL</code>。
    </p>
    <p>一切含有<code>undef</code>值的算数表达式的运算结果皆为<code>undef</code>。在逻辑表达式中，<code>undef</code>等价于<code>false</code>。除了<code>undef==undef</code>的计算结果为<code>true</code>以外，其他有<code>undef</code>参与的关系运算符表达的计算结果皆为<code>false</code>。
    </p>
    <p>请注意，数值计算也可能会返回&#39;nan&#39; (并非一个数值) 来表示存在非法参数。例如，<code>0/false</code>为<code>undef</code>, 而<code>0/0</code>为&#39;nan&#39;。如果向&lt; 与&gt;等关系运算符传入非法参数，将返回<code>false</code>。尽管<code>undef</code>是OpenSCAD语言中定义的值，但&#39;nan&#39;却不是。</p>
    <h3><a name="变量"></a>变量</h3>
    <hr />
    <p>利用带有变量名或<a target="wikibook" href="https://zh.wikipedia.org/wiki/Identifier_(computer_programming)">标识符</a>的语句来创建OpenSCAD变量,通过以分号为结尾的表达式来为之赋值。在许多命令式语言中数组所担当的角色，在OpenSCAD中由向量来扮演。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">var = 25;</div>
        <div class="codeLine">xx = 1.25 * cos(50);</div>
        <div class="codeLine">y = 2*xx+var;</div>
        <div class="codeLine">logic = true;</div>
        <div class="codeLine">MyString = "This is a string";</div>
        <div class="codeLine">a_vector = [1,2,3];</div>
        <div class="codeLine">rr = a_vector[2]; &nbsp; &nbsp; // 向量中的成员</div>
        <div class="codeLine">range1 = [-1.5:0.5:3]; // for()循环范围</div>
        <div class="codeLine">xx = [0:5]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 替代for()循环范围</div>
    </div>
    <p>OpenSCAD是一种<a target="wikibook" href="https://zh.wikipedia.org/wiki/Functional_programming">函数式</a>编程语言，因此<a target="wikibook"href="https://zh.wikipedia.org/wiki/Variable_(computer_science)">变量</a>都与表达式相绑定，且在整个生命周期中保持为一个恒定的值，这是因为它需要满足<a target="wikibook"href="https://zh.wikipedia.org/wiki/Referential_transparency_(computer_science)">引用透明性</a>这项需求。在类似于C这样的<a target="wikibook"href="https://zh.wikipedia.org/wiki/Imperative_programming">命令式编程语言</a>中，上述变量行为就如同常量一般，与其中的普通变量形成鲜明对比。</p>
    <p>换言之，OpenSCAD中的变量更像是常量，但仍有一点重要的不同之处。如果多次为变量赋值，则在整个代码中此变量仅存有最后一次所赋的值。这一点可参见进一步的讨论<a href="#设置变量发生在编译时，而非运行时">设置变量发生在编译时，而非运行时</a>。此行为的原因是需要通过使用<em>-Dvariable=value</em>选项，才能在<a target="wikibook"href="https://zh.wikibooks.org/wiki/OpenSCAD用户手册/在命令行环境下使用OpenSCAD">命令行</a>中输入变量。OpenSCAD当前将赋值过程置于源代码的结尾处，这样，一定可使变量的值以上述方式发生改变。</p>
    <p>在编译期变量保留其最后一次赋值结果，这与<a target="wikibook" href="https://zh.wikipedia.org/wiki/Functional_programming">函数式</a>编程语言的行为相符。与C这样的<a target="wikibook"href="https://zh.wikipedia.org/wiki/Imperative_programming">命令式</a>编程语言不同，OpenSCAD并不是一种支持迭代的语言，像<em>x = x +1</em>这样的语句是不合法的，如果理解了这个概念，您将领略OpenSCAD之美。</p>
    <p>除文件顶层（file top-level）与模块顶层（module top-level）之外，不能在任意作用域内进行赋值。在<em>if/else</em>语句或<em>for</em>循环语句中，需要使用assign()。</p>
    <p>可在任何作用域内进行赋值。请注意，只有在定义变量的作用域内对其进行赋值才是有效的——您仍然不能将数值“泄露”到外层的作用域中。参见<a href="#变量的作用域">变量的作用域</a>来获得更多详情。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">a=0;</div>
        <div class="codeLine">if (a==0) </div>
        <div class="codeLine"> {</div>
        <div class="codeLine"> a=1; // 在2015.03版之前，本行将造成一条编译错误</div>
        <div class="codeLine"> &nbsp; &nbsp; // 自2015.03版开始，将不再出现错误信息，但是值a=1却被限制在括号{}之内</div>
        <div class="codeLine"> }</div>
    </div>
    <h3><a name="未定义变量"></a>未定义变量</h3>
    <p>未赋值变量具有一种特殊值<strong>undef</strong>。 此值可作为条件语句的测试对象，且可由函数作为返回值。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> 示例</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> echo("Variable a is ", a); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Variable a is undef （变量a为undef）</div>
        <div class="codeLine"> if (a==undef) {</div>
        <div class="codeLine"> &nbsp; echo("Variable a is tested undefined"); // Variable a is tested undefined （变量a是被测试的未定义变量）</div>
        <div class="codeLine"> }</div>
    </div>
    <h3><a name="变量的作用域"></a>变量的作用域</h3>
    <p>当如translate()与color()这样的运算符需要囊括一个以上的动作时(动作以;结尾), 就要用大括号{}来将动作打包成组，创建一个新的内部作用域。 如果组中仅有一个分号，那么大括号可有可无。</p>
    <p>每对大括号都在其所在的作用域中创建了一个新的作用域。<strong>自2015.03版开始</strong>, 可将新变量创建在此新作用域之内。另外，还可以为外部域中创建的变量指定新值。这些变量及其值可存在于创建它们的作用域的内部作用域中，但是却<strong>不存在</strong>于创建它们的作用域的外部域中。变量仍然仅保留作用域中最后一次所赋的值。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 作用域1</div>
        <div class="codeLine"> a = 6; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 创建变量a</div>
        <div class="codeLine"> echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6, undef</div>
        <div class="codeLine"> translate([5,0,0]){ &nbsp;// 作用域1.1</div>
        <div class="codeLine"> &nbsp; a= 10;</div>
        <div class="codeLine"> &nbsp; b= 16; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 创建变量b</div>
        <div class="codeLine"> &nbsp; echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100, 16 &nbsp; a=10;在后面被a=100;覆盖
        </div>
        <div class="codeLine"> &nbsp; color("blue") { &nbsp; &nbsp;// 作用域1.1.1</div>
        <div class="codeLine"> &nbsp; &nbsp; echo(a,b); &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100, 20</div>
        <div class="codeLine"> &nbsp; &nbsp; cube();</div>
        <div class="codeLine"> &nbsp; &nbsp; b=20;</div>
        <div class="codeLine"> &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回作用域1,1</div>
        <div class="codeLine"> &nbsp; echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100, 16</div>
        <div class="codeLine"> &nbsp; a=100; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 在作用域1.1中覆盖a </div>
        <div class="codeLine"> } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回作用域1 &nbsp; </div>
        <div class="codeLine"> echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6, undef</div>
        <div class="codeLine"> color("red"){ &nbsp; &nbsp; &nbsp; &nbsp;// 作用域1.2</div>
        <div class="codeLine"> &nbsp; cube();</div>
        <div class="codeLine"> &nbsp; echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6, undef</div>
        <div class="codeLine"> &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回作用域1</div>
        <div class="codeLine"> echo(a,b); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6, undef</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> // 在本例中，作用域1与作用域1.1都为作用域1.1.1的外部域，而作用域1.2却不是。</div>
        <div class="codeLine"> {</div>
        <div class="codeLine"> &nbsp; angle = 45;</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> rotate(angle) square(10);</div>
    </div>
    <p>对于上述变量规则而言，For()循环也不例外，其中的变量各仅有一个值。OpenSCAD会为每趟循环中的内容创建一个副本。因而每趟循环中都有其自己的作用域，以此令对应循环过程中的变量有其唯一值。所以，您仍然不能使用a=a+1;语句。</p>
    <h3><a name="设置变量发生在编译时而非运行时"></a>设置变量发生在编译时，而非运行时</h3>
    <p>由于OpenSCAD在编译时计算其变量值，而非运行时，因此，只有最后一次变量赋值才会在其所在作用域或其内部域中生效。这样想也许会更有助于理解：即OpenSCAD中的变量是一种可重写（override-able）的常量而非传统意义上的“变量”。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 'a'的值反映了仅最后一次的赋值才会生效</div>
        <div class="codeLine"> &nbsp; a = 0;</div>
        <div class="codeLine"> &nbsp; echo(a); // 5</div>
        <div class="codeLine"> &nbsp; a = 3;</div>
        <div class="codeLine"> &nbsp; echo(a); // 5</div>
        <div class="codeLine"> &nbsp; a = 5;</div>
    </div>
    <p>上述示例表现出了一种“反直觉”的执行效果，这使您可以做一些有趣的事情：例如，如果您建立了自己的共享库文件，并在其顶层定义了具有默认值的变量，当您将此文件用于自己的项目中时，就可以简单地通过为之赋予新值的方法来“重新定义”或覆盖（override）那些常量。</p>
    <h3><a name="特殊变量"></a>特殊变量</h3>
    <p>特殊变量提供了另一种向模块或函数传递参数的方式。 所有以一个&#39;$&#39;开头的变量均为特殊变量，这与lisp中的特殊变量很相似。 特殊变量较普通变量而言更为灵活（dynamic动态）。 (对于更多细节可参考<a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/其他语言特性&amp;action=edit&amp;redlink=1">其他语言特性</a>)</p>
    <h3><a name="向量"></a>向量</h3>
    <hr />
    <p>向量是由0或更多的OpenSCAD值按序构成的。因此，向量实为一种由数字、布尔值、变量、向量、字符串或它们之间任意组合而成的集合(或称列表或表)。They can also be expressions which evaluate to one of these.向量在OpenSCAD中扮演的角色就相当于大多命令式语言中的数组。 The information here also applies to lists and tables which use vectors for their data.</p>
    <p>向量的表示是由中括号（方括号）[]围起的0或多个项（或称元素或成员），其间由逗号隔开。向量也能以向量作为元素，而向量元素中还可以包含更多的向量，诸如此类。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; [1,2,3]</div>
        <div class="codeLine"> &nbsp; [a,5,b]</div>
        <div class="codeLine"> &nbsp; []</div>
        <div class="codeLine"> &nbsp; [5.643]</div>
        <div class="codeLine"> &nbsp; ["a","b","string"]</div>
        <div class="codeLine"> &nbsp; [[1,r],[x,y,z,4,5]]</div>
        <div class="codeLine"> &nbsp; [3, 5, [6,7], [[8,9],[10,[11,12],13], c, "string"]</div>
        <div class="codeLine"> &nbsp; [4/3, 6*1.5, cos(60)]</div>
    </div>
    <p>在OpenSCAD中使用向量：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> cube( [width,depth,height] ); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 空格可选，这里为方便阅读而设</div>
        <div class="codeLine"> translate( [x,y,z] )</div>
        <div class="codeLine"> polygon( [ [x0,y0], [x1,y1], [x2,y2] ] );</div>
    </div>
    <p>创建向量要列出其中元素，以逗号分隔，并用方括号包围起来。变量元素会以它们的实际值来代替。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> cube([10,15,20]);</div>
        <div class="codeLine"> a1 = [1,2,3];</div>
        <div class="codeLine"> a2 = [4,5];</div>
        <div class="codeLine"> a3 = [6,7,8,9];</div>
        <div class="codeLine"> b = [a1,a2,a3]; &nbsp; // [ [1,2,3], [4,5], [6,7,8,9] ] 请注意，这里增加了嵌套的深度（层数）</div>
    </div>
    <p>向量中的元素从0至n-1进行编号，其中的n是<a href="#len">len()</a>函数返回的向量长度值。 通过下列方式来定位向量中的元素：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">e[5] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 元素5 (第6个元素) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 第1层嵌套</div>
        <div class="codeLine">e[5][2] &nbsp; &nbsp; &nbsp; // 元素5中的第2个元素 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第2层嵌套</div>
        <div class="codeLine">e[5][2][0] &nbsp; &nbsp; // 元素5中的第2个元素中的第0个元素 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第3层嵌套</div>
        <div class="codeLine">e[5][2][0][1] // 元素5中的第2个元素中的第0个元素的第1个元素 第4层嵌套</div>
    </div>
    <p>利用len()函数得到元素长度的示例</p>
    <div class="CodeMirror-code">
        <div class="codeLine">e = [ [1], [], [3,4,5], "string", "x", [[10,11],[12,13,14],[[15,16],[17]]] ]; // e的长度为6</div>
        <div class="codeLine">地址 &nbsp; &nbsp; &nbsp; &nbsp; 长度 &nbsp; 元素</div>
        <div class="codeLine">e[0] &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; [1]</div>
        <div class="codeLine">e[1] &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; []</div>
        <div class="codeLine">e[5] &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; [ [10,11], [12,13,14], [[15,16],[17]] ]</div>
        <div class="codeLine">e[5][1] &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; [ 12, 13, 14 ]</div>
        <div class="codeLine">e[5][2] &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; [ [15,16], [17] ]</div>
        <div class="codeLine">e[5][2][0] &nbsp; 2 &nbsp; &nbsp; &nbsp; [ 15, 16 ]</div>
        <div class="codeLine">e[5][2][0][1] undef &nbsp; 16</div>
        <div class="codeLine"> &nbsp; &nbsp;</div>
        <div class="codeLine">e[3] &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; "string"</div>
        <div class="codeLine">e[3][2] &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; "r"</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">s = [2,0,5]; a = 2;</div>
        <div class="codeLine">s[a] &nbsp; &nbsp; &nbsp; &nbsp; undef &nbsp; 5</div>
        <div class="codeLine">e[s[a]] &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; [ [10,11], [12,13,14], [[15,16],[17]] ]</div>
    </div>
    <p>向量中的前三个元素可用另一种点表示法进行访问：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">e.x &nbsp; // 等价于e[0]</div>
        <div class="codeLine">e.y &nbsp; // 等价于e[1]</div>
        <div class="codeLine">e.z &nbsp; // 等价于e[2]</div>
    </div>
    <h3><a name="向量操作符"></a>向量操作符</h3>
    <hr />
    <h3><a name="concat"></a>concat</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>concat()将两个或两个以上向量中的元素合并至单个向量。同时并不改变原向量的嵌套层次。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> vector1 = [1,2,3]; vector2 = [4]; vector3 = [5,6];</div>
        <div class="codeLine"> new_vector = concat(vector1, vector2, vector3); // [1,2,3,4,5,6]</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> string_vector = concat("abc","def"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ["abc", "def"]</div>
        <div class="codeLine"> one_string = str(string_vector[0],string_vector[1]); // "abcdef"</div>
    </div>
    <h3><a name="len"></a>len</h3>
    <p>len()是一个返回向量或字符串长度的函数。 元素的索引值范围为由[0]至[length-1]。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> a = [1,2,3]; echo(len(a)); &nbsp; // 3</div>
    </div>
    <a href="#example1">参见有不同长度的向量元素示例</a>
    <h3><a name="矩阵"></a>矩阵</h3>
    <p>向量中的元素为向量是谓矩阵。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">定义了一个2D旋转矩阵的示例</div>
        <div class="codeLine">mr = [</div>
        <div class="codeLine"> &nbsp; &nbsp; [cos(angle), -sin(angle)],</div>
        <div class="codeLine"> &nbsp; &nbsp; [sin(angle), cos(angle)]</div>
        <div class="codeLine"> &nbsp; ];</div>
    </div>
    <h3><a name="获取输入"></a>获取输入</h3>
    <hr />
    <p>我们现在已掌握了变量，可以用它方便地获取用户的输入，而不仅从代码中对其进行设置。OpenSCAD中提供了一些函数用于从DXF文件中国读取数据，或者您可以在命令行中通过-D开关来设置变量。</p>
    <p><strong>从图纸中获取一点</strong></p>
    <p>获取点功能便于您从技术制图中的2D视图内获取一原始点数据。dxf_cross函数将读取并返回某层中您指定的两条线的交点。这意味着必须指定DXF文件中的两条线才能获取相应交点，而并非指定对应的点实体。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">OriginPoint = dxf_cross(file="drawing.dxf", layer="SCAD.Origin", </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origin=[0, 0], scale=1);</div>
    </div>
    <p><strong>获取标注值</strong></p>
    <p>您可以从技术制图中读取其标注。这对于读取旋转角、挤压（extrusion）高度或零件间的空间是很有用处的。在图纸中，所创建的标注并不能反映其标注值，而仅是一种标识符。为读取此值，您要在自己的程序中指定此标识符：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">TotalWidth = dxf_dim(file="drawing.dxf", name="TotalWidth",</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layer="SCAD.Origin", origin=[0, 0], scale=1);
        </div>
    </div>
    <p>对于这两个函数的更佳示例，可参考Example009，其效果图位于<a target="wikibook" href="http://www.openscad.org/">OpenSCAD主页</a>。</p>
    <hr />
    <h1><a name="openscad用户手册3d-基础模型"></a>OpenSCAD用户手册/3D 基础模型</h1>
    <h3><a name="目录-n3075"></a>目录</h3>
    <ul>
        <li><a href="#立方体">1 立方体</a></li>
        <li><a href="#球体">2 球体</a></li>
        <li><a href="#圆柱体">3 圆柱体</a></li>
        <li> 4 多面体
            <ul>
                <li><a href="#debugging-polyhedra">4.1 Debugging polyhedra</a></li>
                <li><a href="#mis-ordered-faces">4.2 Mis-ordered faces</a></li>
                <li><a href="#point-repetitions-in-a-polyhedron-point-list">4.3 Point repetitions in a polyhedron point list</a></li>
            </ul>
        </li>
    </ul>
    <h3><a name="立方体"></a>立方体</h3>
    <hr />
    <p>在第一卦限中创建一个立方体。当center参数为true, 立方体中心点位于原点。如果按下列顺序输入参数，则参数名可写可不写。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">cube(size = [x,y,z], center = true/false);</div>
        <div class="codeLine">cube(size = x , &nbsp; &nbsp; center = true/false);</div>
        <div class="codeLine">默认值: cube(); &nbsp; 等效实现: cube(size = [1, 1, 1], center = false);</div>
    </div>
    <p><img src="img/150px-OpenSCAD_example_Cube.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">本例的几种等效实现脚本</div>
        <div class="codeLine"> cube(size = 18);</div>
        <div class="codeLine"> cube(18);</div>
        <div class="codeLine"> cube([18,18,18]);</div>
        <div class="codeLine"> .</div>
        <div class="codeLine"> cube(18,false);</div>
        <div class="codeLine"> cube([18,18,18],false);</div>
        <div class="codeLine"> cube([18,18,18],center=false);</div>
        <div class="codeLine"> cube(size = [18,18,18], center = false);</div>
        <div class="codeLine"> cube(center = false,size = [18,18,18] );</div>
    </div>
    <p><img src="img/150px-OpenSCAD_example_Box.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">本例的几种等效实现脚本</div>
        <div class="codeLine"> cube([18,28,8],true);</div>
        <div class="codeLine"> box=[18,28,8];cube(box,true);</div>
    </div>
    <h3><a name="球体"></a>球体</h3>
    <hr />
    <p>在坐标系的原点处创建一个球体。参数名r可写可不写。若要以（直径）d取代（半径）r, 则必须写参数名d。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> r - 半径。此为球体的半径。球体的分辨率基于球体的大小与$fa、$fs、$fn三个变量。至于这些特殊变量的更多信息请查阅: <a target="wikibook"href="https://zh.wikibooks.org/wiki/OpenSCAD用户手册/其他语言特性">OpenSCAD用户手册/其他语言特性</a></p>
        </li>
        <li> d - 直径。此为球体的直径。</li>
        <li> $fa - 以度数来表示的片段角度。</li>
        <li> $fs - 以毫米（mm）表示的片段尺寸。</li>
        <li> $fn - 分辨率</li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine"> 默认值: sphere(); &nbsp; 等效实现: &nbsp; sphere($fn = 0, $fa = 12, $fs = 2, r = 1);</div>
    </div>
    <p><strong>用例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">sphere(r = 1);</div>
        <div class="codeLine">sphere(r = 5);</div>
        <div class="codeLine">sphere(r = 10);</div>
        <div class="codeLine">sphere(d = 2);</div>
        <div class="codeLine">sphere(d = 10);</div>
        <div class="codeLine">sphere(d = 20);</div>
        <div class="codeLine">// 这将创建半径为2mm的高分辨率球体</div>
        <div class="codeLine">sphere(2, $fn=100); </div>
        <div class="codeLine">// 这同样将创建半径为2mm的高分辨率球体，</div>
        <div class="codeLine">// 但是此球体的极点上却没有那么多的小三角形</div>
        <div class="codeLine">sphere(2, $fa=5, $fs=0.1); </div>
    </div>
    <p><img src="img/Openscad-sphere.jpg"></p>
    <h3><a name="圆柱体"></a>圆柱体</h3>
    <hr />
    <p>绕z轴创建一个圆柱体或一个圆锥体。当center为true时，它将垂直居中于z轴。</p>
    <p>如果将参数按如下顺序给出，则参数名可写可不写。如果填写了其中一个参数名，那么也要列出位于其后的参数名。</p>
    <p>请注意: 如果要使用r, d, d1或d2，就一定要列出其参数名。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false);</div>
        <div class="codeLine">默认值: cylinder(); 等效实现: cylinder($fn = 0, $fa = 12, $fs = 2, h = 1, r1 = 1, r2 = 1, center = false);</div>
    </div>
    <p><img src="img/200px-OpenSCAD_Cone_15x10x20.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">等效脚本</div>
        <div class="codeLine"> cylinder(h=15, r1=9.5, r2=19.5, center=false);</div>
        <div class="codeLine"> cylinder( 15, &nbsp; 9.5, &nbsp; 19.5, false);</div>
        <div class="codeLine"> cylinder( 15, &nbsp; 9.5, &nbsp; 19.5);</div>
        <div class="codeLine"> cylinder( 15, &nbsp; 9.5, d2=39 );</div>
        <div class="codeLine"> cylinder( 15, d1=19, d2=39 );</div>
        <div class="codeLine"> cylinder( 15, d1=19, r2=19.5);</div>
    </div>
    <p><img src="img/200px-OpenSCAD_Cone_15x10x0.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">等效脚本</div>
        <div class="codeLine"> cylinder(h=15, r1=10, r2=0, center=true);</div>
        <div class="codeLine"> cylinder( 15, &nbsp; 10, &nbsp; 0, &nbsp; &nbsp; &nbsp; true);</div>
        <div class="codeLine"> cylinder(h=15, d1=20, d2=0, center=true);</div>
    </div>
    <ul>
        <li>
            <p><img src="img/112px-OpenSCAD_Cylinder_20x10_false.jpg"></p>
            <p>center = false</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/100px-OpenSCAD_Cylinder_20x10_true.jpg"></p>
            <p>center = true</p>
        </li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine">等效脚本</div>
        <div class="codeLine"> cylinder(h=20, r=10, center=true);</div>
        <div class="codeLine"> cylinder( 20, &nbsp; 10, 10,true);</div>
        <div class="codeLine"> cylinder( 20, d=20, center=true);</div>
        <div class="codeLine"> cylinder( 20,r1=10, d2=20, center=true);</div>
        <div class="codeLine"> cylinder( 20,r1=10, d2=2*10, center=true);</div>
    </div>
    <p>$fn值越大，创建的表面就越圆滑，当然，渲染花费的时间也就越长。在开发过程中为了渲染更快可取适中值，待最终渲染（F6）时再采用较大值。</p>
    <p>然而，在取较小值时，却会生成一些有意思的非圆形对象。以下几个示例会演示这一点：</p>
    <ul>
        <li><img src="img/120px-3_sided_fiqure.jpg"></li>
        <li></li>
        <li><img src="img/120px-4_sided_pyramid.jpg"></li>
        <li></li>
        <li><img src="img/120px-4_sided_part_pyramid.jpg"></li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine">scripts for these examples</div>
        <div class="codeLine"> cylinder(20,20,20,$fn=3);</div>
        <div class="codeLine"> cylinder(20,20,00,$fn=4);</div>
        <div class="codeLine"> cylinder(20,20,10,$fn=4);</div>
    </div>
    <p>When using cylinder() with difference() to place holes in objects, the holes will be undersized. This is because circular paths are approximated withpolygons inscribed within in a circle. The points of the polygon are on the circle, but straight lines between are inside. To have all of the holelarger than the true circle, the polygon must lie wholly outside of the circle (circumscribed). <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/undersized_circular_objects&amp;action=edit&amp;redlink=1">Modules forcircumscribed holes</a></p>
    <ul>
        <li><img src="img/120px-OpenSCAD_Under_size_hole.jpg"></li>
    </ul>
    <p><strong>精确度的相关注解</strong> 圆形对象都是以近似方式表示的。The algorithm for doing this matters when you want 3d printed holes to be the right size. Current behavioris <a target="wikibook"href="https://camo.githubusercontent.com/533961dfae3fd5643f3474345e4179a8a328dcf9/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313937323936312f313930353837342f34323261383738322d376361352d313165332d383035612d3531303633613361306531322e4a5047">illustratedin a diagram</a> . Discussion regarding optionally changing this behavior happening in a <a target="wikibook"href="https://github.com/openscad/openscad/pull/599">Pull Request</a></p>
    <h3><a name="多面体"></a>多面体</h3>
    <hr />
    <p>多面体是一种最常用的3D图元实体。可用它来创建任意具有凸凹（concave as well as convex）特性的规则或不规则形状几何体。而曲面则是由一系列平面近似构成。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], triangles = [ [P0, P1, P2], ... ], convexity = N); &nbsp; //2014.03版本以前</div>
        <div class="codeLine">polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N); &nbsp; //2014.03及其后续版本</div>
        <div class="codeLine"> 默认值: polyhedron(); 等效实现: polyhedron(points = undef, faces = undef, convexity = 1);</div>
    </div>
    <p>All faces must have points ordered in the same direction . OpenSCAD prefers <strong>clockwise</strong> when looking at each face from outside
        <strong>inwards</strong>. The back is viewed from the back, the bottom from the bottom, etc..</p>
    <p><img src="img/Cube_numbers.jpg"></p>
    <p>立方体上的顶点数</p>
    <p><img src="img/Cube_flat.jpg"></p>
    <p>拆开的立方体面</p>
    <div class="CodeMirror-code">
        <div class="codeLine">CubePoints = [</div>
        <div class="codeLine"> [ 0, 0, 0 ], //0</div>
        <div class="codeLine"> [ 10, 0, 0 ], //1</div>
        <div class="codeLine"> [ 10, 7, 0 ], //2</div>
        <div class="codeLine"> [ 0, 7, 0 ], //3</div>
        <div class="codeLine"> [ 0, 0, 5 ], //4</div>
        <div class="codeLine"> [ 10, 0, 5 ], //5</div>
        <div class="codeLine"> [ 10, 7, 5 ], //6</div>
        <div class="codeLine"> [ 0, 7, 5 ]]; //7</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">CubeFaces = [</div>
        <div class="codeLine"> [0,1,2,3], // 底面</div>
        <div class="codeLine"> [4,5,1,0], // 前面</div>
        <div class="codeLine"> [7,6,5,4], // 顶面</div>
        <div class="codeLine"> [5,6,2,1], // 右面</div>
        <div class="codeLine"> [6,7,3,2], // 背面</div>
        <div class="codeLine"> [7,4,0,3]]; // 左面</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">polyhedron( CubePoints, CubeFaces );</div>
        <div class="codeLine">立方体底面的等价描述</div>
        <div class="codeLine"> [0,1,2,3],</div>
        <div class="codeLine"> [0,1,2,3,0],</div>
        <div class="codeLine"> [1,2,3,0],</div>
        <div class="codeLine"> [2,3,0,1],</div>
        <div class="codeLine"> [3,0,1,2],</div>
        <div class="codeLine"> // 两个未重叠的三角形</div>
        <div class="codeLine"> [0,1,2],[2,3,0], &nbsp; </div>
        <div class="codeLine"> [1,2,3],[3,0,1],</div>
        <div class="codeLine"> [1,2,3],[0,1,3],</div>
    </div>
    <p><img src="img/Openscad-polyhedron-squarebasepyramid.png"></p>
    <p>一个简单的多面体——正方形底座的四棱锥</p>
    <div class="CodeMirror-code">
        <div class="codeLine">polyhedron(</div>
        <div class="codeLine"> points=[ [10,10,0],[10,-10,0],[-10,-10,0],[-10,10,0], // 底座上的4个顶点</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0,0,10] ], &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 锥体顶点 </div>
        <div class="codeLine"> faces=[ [0,1,4],[1,2,4],[2,3,4],[3,0,4], &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 每个三角形面</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1,0,3],[2,1,3] ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; // 正方形底座上的两个三角形</div>
        <div class="codeLine"> );</div>
    </div>
    <p><img src="img/Polyhedron_Prism.png"></p>
    <p>一个多边形示例——三棱柱</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; module prism(l, w, h){</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; polyhedron(</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; points=[[0,0,0], [l,0,0], [l,w,0], [0,w,0], [0,w,h], [l,w,h]],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; faces=[[0,1,2,3],[5,4,3,2],[0,4,5,1],[0,3,4],[5,2,1]]</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; // preview unfolded (do not include in your function</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; z = 0.08;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; separation = 2;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; border = .2;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0,w+separation,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube([l,w,z]);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0,w+separation+w+border,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube([l,h,z]);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0,w+separation+w+border+h+border,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube([l,sqrt(w*w+h*h),z]);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([l+border,w+separation+w+border+h+border,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; polyhedron(</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; points=[[0,0,0],[h,0,0],[0,sqrt(w*w+h*h),0],[0,0,z],[h,0,z],[0,sqrt(w*w+h*h),z]],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; faces=[[0,1,2], [3,5,4], [0,3,4,1], [1,4,5,2], [2,5,3,0]]
        </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0-border,w+separation+w+border+h+border,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; polyhedron(</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; points=[[0,0,0],[0-h,0,0],[0,sqrt(w*w+h*h),0],[0,0,z],[0-h,0,z],[0,sqrt(w*w+h*h),z]],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; faces=[[1,0,2],[5,3,4],[0,1,4,3],[1,2,5,4],[2,0,3,5]]</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine"> &nbsp; prism(10, 5, 3);</div>
    </div>
    <h3><a name="debugging-polyhedra"></a>Debugging polyhedra</h3>
    <hr />
    <p>Mistakes in defining polyhedra include not having all faces with the same order, overlap of faces and missing faces or portions of faces. As ageneral rule, the polyhedron faces should also satisfy (manifold conditions):</p>
    <ul>
        <li>exactly two faces should meet at any polyhedron edge.</li>
        <li>if two faces have a vertex in common, they should be in the same cycle face-edge around the vertex.</li>
    </ul>
    <p>The first rule eliminates polyhedron like two cubes with a common edge and not watertight models; the second excludes polyhedron like two cubes witha common vertex.</p>
    <p>When viewed from the outside, the points describing each face must be in the same order . OpenSCAD prefers CW, and provides a mechanism for detectingCCW. When the thrown together view (F12) is used with F5, CCW faces are shown in pink. Reorder the points for incorrect faces. Rotate the object toview all faces. The pink view can be turned off with F10.</p>
    <p>OpenSCAD allows, temporarily, commenting out part of the face descriptions so that only the remaining faces are displayed. Use // to comment out therest of the line. Use /* and */ to start and end a comment block. This can be part of a line or extend over several lines. Viewing only part of thefaces can be helpful in determining the right points for an individual face. Note that a solid is not shown, only the faces. If using F12, all faceshave one pink side. Commenting some faces helps also to show any internal face.</p>
    <p><img src="img/Cube_2_face.jpg"></p>
    <p>example 1 showing only 2 faces</p>
    <div class="CodeMirror-code">
        <div class="codeLine">CubeFaces = [</div>
        <div class="codeLine">/* [0,1,2,3], // bottom</div>
        <div class="codeLine"> &nbsp; [4,5,1,0], // front */</div>
        <div class="codeLine"> &nbsp; [7,6,5,4], // top</div>
        <div class="codeLine">/* [5,6,2,1], // right</div>
        <div class="codeLine"> &nbsp; [6,7,3,2], // back */</div>
        <div class="codeLine"> &nbsp; [7,4,0,3]]; // left</div>
    </div>
    <p>After defining a polyhedron, its preview may seem correct. The polyhedron alone may even render fine. However to be sure it is a valid manifold andthat it will generate a valid STL file, union it with any cube and render it (F6). If the polyhedron disappears, it means that it is not correct.Revise the winding order of all faces and the two rules stated above.</p>
    <h3><a name="mis-ordered-faces"></a>Mis-ordered faces</h3>
    <hr />
    <p>When you select &#39;Thrown together&#39; from the view menu and <strong>compile</strong> the design (<strong>not</strong> compile and render!) youwill see a preview with the mis-oriented polygons highlighted. Unfortunately this highlighting is not possible in the OpenCSG preview mode becauseit would interfere with the way the OpenCSG preview mode is implemented.)</p>
    <p>Below you can see the code and the picture of such a problematic polyhedron, the bad polygons (faces or compositions of faces) are in pink.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// Bad polyhedron</div>
        <div class="codeLine">polyhedron</div>
        <div class="codeLine"> &nbsp; (points = [</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; ], </div>
        <div class="codeLine"> &nbsp; &nbsp; faces = [</div>
        <div class="codeLine"> [0,2,3], &nbsp; [0,1,2], [0,4,5], [0,5,1], &nbsp; [5,4,2], [2,4,3],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [6,8,9], [6,7,8], [6,10,11], [6,11,7], [10,8,11],</div>
        <div class="codeLine"> [10,9,8], [0,3,9], [9,0,6], [10,6, 0], [0,4,10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [3,9,10], [3,10,4], [1,7,11], [1,11,5], [1,7,8], &nbsp;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1,8,2], [2,8,11], [2,11,5]</div>
        <div class="codeLine"> ]</div>
        <div class="codeLine"> &nbsp; &nbsp; );</div>
    </div>
    <p><img src="img/Openscad-bad-polyhedron.png"></p>
    <p>Polyhedron with badly oriented polygons</p>
    <p>A correct polyhedron would be the following:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">polyhedron</div>
        <div class="codeLine"> &nbsp; (points = [</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; ], </div>
        <div class="codeLine"> &nbsp; &nbsp; faces = [</div>
        <div class="codeLine"> [0,3,2], [0,2,1], [4,0,5], [5,0,1], [5,2,4], [4,2,3],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [6,8,9], [6,7,8], [6,10,11],[6,11,7], [10,8,11],</div>
        <div class="codeLine"> [10,9,8], [3,0,9], [9,0,6], [10,6, 0],[0,4,10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [3,9,10], [3,10,4], [1,7,11], [1,11,5], [1,8,7], &nbsp;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [2,8,1], [8,2,11], [5,11,2]</div>
        <div class="codeLine"> ]</div>
        <div class="codeLine"> &nbsp; &nbsp; );</div>
    </div>
    <p>Beginner&#39;s tip:</p>
    <p>If you don&#39;t really understand &quot;orientation&quot;, try to identify the mis-oriented pink faces and then invert the sequence of thereferences to the points vectors until you get it right. E.g. in the above example, the third triangle (<em>[0,4,5]</em>) was wrong and we fixed itas <em>[4,0,5]</em>. Remember that a face list is a circular list. In addition, you may select &quot;Show Edges&quot; from the &quot;ViewMenu&quot;, print a screen capture and number both the points and the faces. In our example, the points are annotated in black and the faces inblue. Turn the object around and make a second copy from the back if needed. This way you can keep track.</p>
    <p>Clockwise Technique:</p>
    <p>Orientation is determined by clockwise circular indexing. This means that if you&#39;re looking at the triangle (in this case [4,0,5]) from theoutside you&#39;ll see that the path is clockwise around the center of the face. The winding order [4,0,5] is clockwise and therefore good. Thewinding order [0,4,5] is counter-clockwise and therefore bad. Likewise, any other clockwise order of [4,0,5] works: [5,4,0] &amp; [0,5,4] are goodtoo. If you use the clockwise technique, you&#39;ll always have your faces outside (outside of OpenSCAD, other programs do use counter-clockwise asthe outside though).</p>
    <p>Think of it as a Left Hand Rule:</p>
    <p>If you hold the face and the fingers of your right hand curls is the same order as the points, then your thumb points outwards.</p>
    <p><img src="img/Openscad-bad-polyhedron-annotated.png"></p>
    <p>Polyhedron with badly oriented polygons</p>
    <p>Succinct description of a &#39;Polyhedron&#39;</p>
    <div class="CodeMirror-code">
        <div class="codeLine">* Points define all of the points/vertices in the shape.</div>
        <div class="codeLine">* Faces is a list of flat polygons that connect up the points/vertices. </div>
    </div>
    <p>Each point, in the point list, is defined with a 3-tuple x,y,z position specification. Points in the point list are automatically enumerated startingfrom zero for use in the faces list (0,1,2,3,... etc).</p>
    <p>Each face, in the faces list, is defined by selecting 3 or more of the points (using the point order number) out of the point list.</p>
    <p>e.g. faces=[ [0,1,2] ] defines a triangle from the first point (points are zero referenced) to the second point and then to the third point.</p>
    <p>When looking at any face from the outside, the face must list all points in a clockwise order.</p>
    <h3><a name="point-repetitions-in-a-polyhedron-point-list"></a>Point repetitions in a polyhedron point list</h3>
    <p>The point list of the polyhedron definition may have repetitions. When two or more points have the same coordinates they are considered the samepolyhedron vertex. So, the following polyhedron:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">points = [[ 0, 0, 0], [10, 0, 0], [ 0,10, 0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [ 0, 0, 0], [10, 0, 0], [ 0,10, 0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [ 0,10, 0], [10, 0, 0], [ 0, 0,10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [ 0, 0, 0], [ 0, 0,10], [10, 0, 0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [ 0, 0, 0], [ 0,10, 0], [ 0, 0,10]];</div>
        <div class="codeLine">polyhedron(points, [[0,1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14]]);</div>
    </div>
    <p>define the same tetrahedron as:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">points = [[0,0,0], [0,10,0], [10,0,0], [0,0,10]];</div>
        <div class="codeLine">polyhedron(points, [[0,2,1], [0,1,3], [1,2,3], [0,3,2]]);</div>
    </div>
    <hr />
    <h1><a name="openscad用户手册3d-到-2d-投射"></a>OpenSCAD用户手册/3D 到 2D 投射</h1>
    <p>利用<code>projection()</code>函数即可根据3D模型创建对应的2D图形，并将它们以dxf格式导出。此函数的工作原理是将3D模型投影至z = 0的(x,y)平面。如果<code>cut=true</code>，仅对z=0的3D对象点进行投影(也就是对象在此平面的“切片”)；若
        <code>cut=false</code>(<em>即，默认值</em>)，会对z=0上下的平面全都进行投影(即，为3D对象整体创建投影)。</p>
    <p><strong>示例</strong>：现在来考虑example002.scad，将其导入OpenSCAD中。</p>
    <p><img src="img/Openscad_projection_example_2x.png"></p>
    <p>您现在就可以做一次&#39;裁剪&#39;投影，OpenSCAD将为您绘制出一幅z=0时x-y平面的切片。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">projection(cut = true) example002();</div>
    </div>
    <p><img src="img/Openscad_projection_example_3x.png"></p>
    <p>您也可以做一次&#39;常规&#39;投影，也就是将3D对象的&#39;阴影&#39;投射至xy平面。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">projection(cut = false) example002();</div>
    </div>
    <p><img src="img/Openscad_example_projection_8x.png"></p>
    <p><em>另一个示例&#39;</em></p>
    <p>您还可以利用投影为3D对象制作一份&#39;侧视图&#39;。还是利用example002，将其沿z轴正方向移动，离开x-y平面，再令它进行旋转：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">translate([0,0,25]) rotate([90,0,0]) example002();</div>
    </div>
    <p><img src="img/Openscad_projection_example_4x.png"></p>
    <p>现在，我们就能利用projection()函数获取此对象的侧视图：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">projection() translate([0,0,25]) rotate([90,0,0]) example002();</div>
    </div>
    <p><img src="img/Openscad_projection_example_5x.png"></p>
    <p>链接:</p>
    <ul>
        <li><a target="wikibook" href="http://svn.clifford.at/openscad/trunk/examples/example021.scad">出自Clifford Wolf站点的example021.scad</a>。</li>
        <li><a target="wikibook" href="http://www.gilesbathgate.com/2010/06/extracting-2d-mendel-outlines-using-openscad/">更加复杂的示例</a>出自Giles Bathgate的博客
        </li>
    </ul>
    <hr />
    <h1><a name="openscad用户手册二维基础图形"></a>OpenSCAD用户手册/二维基础图形</h1>
    <p>所有二维基础图形都可以进行三维变换，通常是作为三维拉伸的部件。虽然它无限薄，但它们会以厚度1进行渲染。</p>
    <h3><a name="目录-n3260"></a>目录</h3>
    <ul>
        <li><a href="#方形">1 方形</a></li>
        <li> 2 圆形
            <ul>
                <li><a href="#椭圆形">2.1 椭圆形</a></li>
                <li><a href="#正多边形">2.2 正多边形</a></li>
            </ul>
        </li>
        <li><a href="#多边形">3 多边形</a></li>
        <li><a href="#importdxf">4 import_dxf</a></li>
    </ul>
    <h2><a name="方形"></a>方形</h2>
    <p>直接创建的方块（或者说长方形）会在第一象限，把 center 设为 true 则其中心会在原点上。如果按所示顺序给出参数，则参数名称可不给出。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> square(size = [x, y], center = true/false);</div>
        <div class="codeLine"> square(size = x &nbsp; &nbsp; , center = true/false);</div>
        <div class="codeLine">缺省使用： square(); &nbsp; 得到： square(size = [1, 1], center = false);</div>
    </div>
    <p><img src="img/OpenScad_Square_10_x_10.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> square(size = 10);</div>
        <div class="codeLine"> square(10);</div>
        <div class="codeLine"> square([10, 10]);</div>
        <div class="codeLine"> square(10, false);</div>
        <div class="codeLine"> square([10, 10], false);</div>
        <div class="codeLine"> square([10, 10], center = false);</div>
        <div class="codeLine"> square(size = [10, 10], center = false);</div>
        <div class="codeLine"> square(center = false, size = [10, 10]);</div>
    </div>
    <p><img src="img/150px-OpenScad_Square_20x10.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> square([20,10],true);</div>
        <div class="codeLine"> a=[20,10];square(a,true);</div>
    </div>
    <h2><a name="圆形"></a>圆形</h2>
    <p>直接创建会是一个圆心在原点的圆形。除 r 外的所有参数都 <strong>必须</strong> 给出名称。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">circle(r=radius | d=diameter);</div>
        <div class="codeLine">scale([1/100, 1/100, 1/100]) circle(200); // 创建一个半径为 2 的高分辨率圆形</div>
        <div class="codeLine">circle(2, $fn=50); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 同上，另一种方法</div>
        <div class="codeLine">缺省使用： circle(); &nbsp; 得到： circle($fn = 0, $fa = 12, $fs = 2, r = 1);</div>
    </div>
    <p><img src="img/OpenSCAD_Circle_10.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> circle(10);</div>
        <div class="codeLine"> circle(r=10);</div>
        <div class="codeLine"> circle(d=20);</div>
        <div class="codeLine"> circle(d=2+9*2);</div>
    </div>
    <h3><a name="椭圆形"></a>椭圆形</h3>
    <p>椭圆形可以从圆形得来，用 scale() 或 resize() 使得 x 和 y 维度不相等即可。 参看 <a target="wikibook" href="https://zh.wikibooks.org/wiki/OpenSCAD用户手册/变换">OpenSCAD用户手册/变换</a>
    </p>
    <p><img src="img/OpenScad_Ellipse_from_circle.jpg"> <img src="img/OpenScad_Ellipse_from_circle_top_view.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> resize([30,10])circle(d=20);</div>
        <div class="codeLine"> scale([1.5,.5])circle(d=20);</div>
    </div>
    <h3><a name="正多边形"></a>正多边形</h3>
    <p>把 $n 设置为想要的边数（3或以上），即可通过 circle() 得到正多边形。它是所指定圆的内接多边形，各边各角均相等，且有一个顶点在 x 轴正方向上。对于非正多边形，请参看下文中的多边形基础图形。</p>
    <p><img src="img/300px-OpenSCAD_regular_polygon_using_circle.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> translate([-42, 0]){circle(20,$fn=3);%circle(20,$fn=90);}</div>
        <div class="codeLine"> translate([ 0, 0]) circle(20,$fn=4);</div>
        <div class="codeLine"> translate([ 42, 0]) circle(20,$fn=5);</div>
        <div class="codeLine"> translate([-42,-42]) circle(20,$fn=6);</div>
        <div class="codeLine"> translate([ 0,-42]) circle(20,$fn=8);</div>
        <div class="codeLine"> translate([ 42,-42]) circle(20,$fn=12);</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> color("black"){</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([-42, 0,1])text("3",7,,center);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([ 0, 0,1])text("4",7,,center);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([ 42, 0,1])text("5",7,,center);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([-42,-42,1])text("6",7,,center);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([ 0,-42,1])text("8",7,,center);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([ 42,-42,1])text("12",7,,center);</div>
        <div class="codeLine"> }</div>
    </div>
    <h2><a name="多边形"></a>多边形</h2>
    <p>可通过一列 x,y 坐标来创建一个多边形。多边形是最为强大的二维形状，不但可用来创建圆形和方形能创建任何的东西，更是另有无限可能——比如，不规则形状，无论凸形还是凹形。甚至，可以在形状中留有孔洞。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">polygon(points = [ [x, y], ... ], paths = [ [p1, p2, p3..], ...], convexity = N);</div>
    </div>
    <p><strong>参数</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">默认使用: &nbsp; polygon(); 得到: polygon(points = undef, paths = undef, convexity = 1);</div>
    </div>
    <p><strong>无孔洞示例</strong></p>
    <p><img src="img/OpenSCAD_Polygon_Example_Rhomboid.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> polygon(points=[[0,0],[100,0],[130,50],[30,50]]);</div>
        <div class="codeLine"> polygon([[0,0],[100,0],[130,50],[30,50]], paths=[[0,1,2,3]]);</div>
        <div class="codeLine"> polygon([[0,0],[100,0],[130,50],[30,50]],[[3,2,1,0]]);</div>
        <div class="codeLine"> polygon([[0,0],[100,0],[130,50],[30,50]],[[1,0,3,2]]);</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> a=[[0,0],[100,0],[130,50],[30,50]];</div>
        <div class="codeLine"> b=[[3,0,1,2]];</div>
        <div class="codeLine"> polygon(a);</div>
        <div class="codeLine"> polygon(a,b);</div>
        <div class="codeLine"> polygon(a,[[2,3,0,1,2]]);</div>
    </div>
    <p><strong>有孔洞示例</strong></p>
    <p><img src="img/Openscad-polygon-example1.png"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">上例的等效脚本</div>
        <div class="codeLine"> polygon(points=[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]], paths=[[0,1,2],[3,4,5]],convexity=10);</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> triangle_points =[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]];</div>
        <div class="codeLine"> triangle_paths =[[0,1,2],[3,4,5]];</div>
        <div class="codeLine"> polygon(triangle_points,triangle_paths,10);</div>
        <div class="codeLine">第一个 path 矢量 [0,1,2]，选择了这些顶点 [0,0],[100,0],[0,100] 作为主形状。</div>
        <div class="codeLine">第二个 path 矢量 [3,4,5]，选择了这些顶点 [10,10],[80,10],[10,80] 作为次形状。</div>
        <div class="codeLine">把次形状从主形状减去（参考 difference()）</div>
        <div class="codeLine">由于次形状完全包含在主形状内部，这使最后的形状留了一个孔洞。</div>
    </div>
    <p><strong>多孔示例</strong></p>
    <p>注意： concat() 只在 2015.03 之后版本中有效</p>
    <p><img src="img/OpenSCAD_romboid_with_holes.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; //example polygon with multiple holes</div>
        <div class="codeLine">a0 = [[0,0],[100,0],[130,50],[30,50]]; &nbsp; &nbsp; // 主形状</div>
        <div class="codeLine">b0 = [1,0,3,2];</div>
        <div class="codeLine">a1 = [[20,20],[40,20],[30,30]]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 孔洞1</div>
        <div class="codeLine">b1 = [4,5,6];</div>
        <div class="codeLine">a2 = [[50,20],[60,20],[40,30]]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 孔洞2</div>
        <div class="codeLine">b2 = [7,8,9];</div>
        <div class="codeLine">a3 = [[65,10],[80,10],[80,40],[65,40]]; &nbsp; // 孔洞3</div>
        <div class="codeLine">b3 = [10,11,12,13];</div>
        <div class="codeLine">a4 = [[98,10],[115,40],[85,40],[85,10]]; &nbsp; // 孔洞4</div>
        <div class="codeLine">b4 = [14,15,16,17];</div>
        <div class="codeLine">a = concat (a0,a1,a2,a3,a4);</div>
        <div class="codeLine">b = [b0,b1,b2,b3,b4];</div>
        <div class="codeLine">polygon(a,b);</div>
        <div class="codeLine"> &nbsp; &nbsp; //alternate </div>
        <div class="codeLine">polygon(a,[b0,b1,b2,b3,b4]);</div>
    </div>
    <p><strong>convexity</strong></p>
    <p>凸性数（convexity）参数指明：一条射线与形状相交时，可以截得的最大前端（或后端）数量。 此参数仅在预览模式中用来正确显示对象，而在多面体渲染中则用不到它。</p>
    <p><img src="img/400px-Openscad_convexity.jpg"></p>
    <p>此图所示之二维形状凸性数为 4，因为图中红色所示射线与二维形状的边线相交4次。三维形状的凸性数也以类似方式确定。一般来说，设置凸性数为 10 足以应对大多数情况。</p>
    <h2><a name="importdxf"></a>import_dxf</h2>
    <p>已废止: import_dxf() 模块将从未来版本中移除。请使用 <a href="#import">import()</a> 替代之。</p>
    <p>读取 DXF 文件，并以之创建一个二维形状。</p>
    <p><strong>示例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 5, center = true, convexity = 10)</div>
        <div class="codeLine">import_dxf(file = "example009.dxf", layer = "plate");</div>
    </div>
    <hr />
    <h1><a name="openscad用户手册文本"></a>OpenSCAD用户手册/文本</h1>
    <p><code>text</code>模块借助本地系统安装的字体或用户提供的单独字体文件，以2D几何对象的方式来创建文本。</p>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p><strong>参数</strong></p>
    <ul>
        <li> text - 字符串。待生成的文本。</li>
        <li> size - 十进制数。生成的文本将逼近所指定值的大小（也就是基线以上的高度）。 默认值为10。 请注意，特定字体或有差异，可能会导致不能按指定的size精确地填充字体，通常情况下填充的效果会稍小一些。</li>
        <li> font - 字符串。所用的字体名称。此参数并非字体文件的名称，而是字体的逻辑名称 (即，fontconfig库内部处理时所用名称)。此参数中还可以包括一个字体样式参数，参见下文。系统中安装的字体与样式列表可以通过字体列表（font list）对话框来获取 (Help -&gt;Font List)。</li>
        <li> halign - 字符串。文本的水平对齐方式。取值可以为：&quot;left（左对齐）&quot;, &quot;center（居中对齐）&quot; 与 &quot;right（右对齐）&quot;. 默认值为&quot;left&quot;。</li>
        <li> valign - 字符串。文本的垂直对齐方式。取值可以为&quot;top（顶部对齐）&quot;, &quot;center（居中对齐）&quot;, &quot;baseline（基线对齐）&quot; 与&quot;bottom（底部对齐）&quot;。默认值为&quot;baseline&quot;。</li>
        <li> spacing - 十进制数。用于增减字符间距的因子。默认值1采用的是字体的一般间距，而大于1的值将导致字母间的距离更大。</li>
        <li> direction- 字符串。文本流的方向。取值可以为&quot;ltr&quot; (左 -&gt; 右), &quot;rtl&quot; (右 -&gt; 左), &quot;ttb&quot; (上 -&gt; 下) 与 &quot;btt&quot; (下 -&gt;上)。默认值为&quot;ltr&quot;。</li>
        <li> language- 字符串。文本的语言。默认值为&quot;en（英文）&quot;。</li>
        <li> script- 字符串。文本的脚本。默认值为&quot;latin（拉丁文）&quot;。</li>
        <li> $fn- 用于细分freetype所提供的曲线路径片段（curved path segments）</li>
    </ul>
    <p><strong>示例</strong></p>
    <p><img src="img/220px-OpenSCAD_text%28%29_example.png"></p>
    <p>示例1: 执行效果。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">text("OpenSCAD");</div>
    </div>
    <ul>
        <li>请注意</li>
    </ul>
    <p>为了可以使用特殊的<a target="wikibook" href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>字符，您可以在字符串中借助以下转义码来指定它们：</p>
    <p>\x03 - 单个16进制字符 (仅限于01h - 7fh范围内的值)</p>
    <p>\u0123 - 以4个十六进制数表示的unicode字符 (请注意: 要使用小写字母)</p>
    <p>\U012345 - 以6个十六进制数表示的unicode字符 (请注意: 要使用大写字母)</p>
    <p><strong>示例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">t="\u20AC10 \u263A"; // 10欧元以及1个笑脸</div>
    </div>
    <h3><a name="目录-n3379"></a>目录</h3>
    <ul>
        <li><a href="#使用字体及其样式">1 使用字体及其样式</a></li>
        <li> 2 对齐
            <ul>
                <li><a href="#垂直对齐">2.1 垂直对齐</a></li>
                <li><a href="#水平对齐">2.2 水平对齐</a></li>
            </ul>
        </li>
        <li><a href="#可渲染3d文本">3 可渲染3D文本</a></li>
    </ul>
    <h3><a name="使用字体及其样式"></a>使用字体及其样式</h3>
    <p>指定字体依赖于其字体逻辑名；另外，还能利用像&quot;<strong>bold</strong>&quot; 或 &quot;<em>italic</em>&quot;等样式参数为它选择字体的样式。这样，指定字体的语句就形如：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">font="Liberation Sans:style=Bold Italic"</div>
    </div>
    <p>字体列表（font list）对话框中给出了每个可用字体的字体名称及其样式。另外，此列表还提供了字体文件的所在位置以供参考。您可以直接将字体列表中的字体拖拽至编辑器窗口，以便用于text()语句。</p>
    <p><img src="img/400px-OpenSCAD_font_list_dialog.png"></p>
    <p>OpenSCAD字体列表对话框</p>
    <p>OpenSCAD中囊括了<em>Liberation Mono, Liberation Sans, Liberation Sans Narrow 与 Liberation Serif</em>字体。因此，就算不同的平台采用不同的字体，而OpenSCAD却依然可以跨平台保持其字体的兼容性。</p>
    <p>出于上述原因，不管是对于常用文本/非正式文本而言，墙裂<strong>建议</strong>您使用上述内置字体之一。Liberation Sans是程序推荐使用的默认字体。</p>
    <p>为了安装字体，可能需要为工程添加特定的字体文件。OpenSCAD支持的字体格式为<a target="wikibook" href="https://zh.wikipedia.org/wiki/TrueType">TrueType</a>字体(<em>.ttf)与 <atarget="wikibook" href="https://zh.wikipedia.org/wiki/OpenType">OpenType</a>字体(</em>.otf)。另外，还需要使用use&lt;&gt;语句来注册字体文件。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> use &lt;ttf/paratype-serif/PTF55F.ttf&gt;</div>
    </div>
    <p>注册后的字体也将位于字体列表对话框之中，因此在字体逻辑名称未知的情况下，也可以在注册后借助字体列表来查询。</p>
    <p>OpenSCAD通过fontconfig来查找并管理各种字体，因此，也能够以命令行的方式借助fontconfig工具列出系统中配置的字体，其格式就像在GUI对话框中所示的那样。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">$ fc-list -f "%-60{{%{family[0]}%{:style[0]=}}}%{file}\n" | sort</div>
        <div class="codeLine">​</div>
        <div class="codeLine">...</div>
        <div class="codeLine">Liberation Mono:style=Bold Italic /usr/share/fonts/truetype/liberation2/LiberationMono-BoldItalic.ttf</div>
        <div class="codeLine">Liberation Mono:style=Bold &nbsp; &nbsp; &nbsp; /usr/share/fonts/truetype/liberation2/LiberationMono-Bold.ttf</div>
        <div class="codeLine">Liberation Mono:style=Italic &nbsp; &nbsp; /usr/share/fonts/truetype/liberation2/LiberationMono-Italic.ttf</div>
        <div class="codeLine">Liberation Mono:style=Regular &nbsp; &nbsp; /usr/share/fonts/truetype/liberation2/LiberationMono-Regular.ttf</div>
        <div class="codeLine">...</div>
    </div>
    <p><strong>示例</strong></p>
    <p><img src="img/220px-OpenSCAD_text%28%29_font_style_example.png"></p>
    <p>示例2: 执行效果。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> square(10);</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> translate([15, 15]) {</div>
        <div class="codeLine"> &nbsp; text("OpenSCAD", font = "Liberation Sans");</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> translate([15, 0]) {</div>
        <div class="codeLine"> &nbsp; text("OpenSCAD", font = "Liberation Sans:style=Bold Italic");</div>
        <div class="codeLine"> }</div>
    </div>
    <h3><a name="对齐"></a>对齐</h3>
    <h3><a name="垂直对齐"></a>垂直对齐</h3>
    <ul>
        <li> top - 文本对齐于指定Y坐标处边框（bounding box）的顶部。</li>
        <li> center - 文本对齐于指定Y坐标处边框的中心。</li>
        <li> baseline - 文本对齐于指定Y坐标处的字体基线。此项为默认值。</li>
        <li> bottom - 文本对齐于指定Y坐标处边框的底部。</li>
    </ul>
    <p><img src="img/220px-OpenSCAD_text_align_vertical.png"></p>
    <p>OpenSCAD垂直文本对齐</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> text = "Align";</div>
        <div class="codeLine"> font = "Liberation Sans";</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> valign = [</div>
        <div class="codeLine"> &nbsp; [ 0, "top"],</div>
        <div class="codeLine"> &nbsp; [ 40, "center"],</div>
        <div class="codeLine"> &nbsp; [ 75, "baseline"],</div>
        <div class="codeLine"> &nbsp; [110, "bottom"]</div>
        <div class="codeLine"> ];</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> for (a = valign) {</div>
        <div class="codeLine"> &nbsp; translate([10, 120 - a[0], 0]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; color("red") cube([135, 1, 0.1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; color("blue") cube([1, 20, 0.1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; linear_extrude(height = 0.5) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; text(text = str(text,"_",a[1]), font = font, size = 20, valign = a[1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine"> }</div>
    </div>
    <h3><a name="水平对齐"></a>水平对齐</h3>
    <ul>
        <li> left - 文本对齐于指定X坐标处边框的左侧。此项为默认值。</li>
        <li> center - 文本对齐于指定X坐标处边框的中心。</li>
        <li> right - 文本对齐于指定X坐标处边框的右侧。</li>
    </ul>
    <p><img src="img/220px-OpenSCAD_text_align_horizontal.png"></p>
    <p>OpenSCAD水平文本对齐</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> text = "Align";</div>
        <div class="codeLine"> font = "Liberation Sans";</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> halign = [</div>
        <div class="codeLine"> &nbsp; [10, "left"],</div>
        <div class="codeLine"> &nbsp; [50, "center"],</div>
        <div class="codeLine"> &nbsp; [90, "right"]</div>
        <div class="codeLine"> ];</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> for (a = halign) {</div>
        <div class="codeLine"> &nbsp; translate([140, a[0], 0]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; color("red") cube([115, 2,0.1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; color("blue") cube([2, 20,0.1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; linear_extrude(height = 0.5) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; text(text = str(text,"_",a[1]), font = font, size = 20, halign = a[1]);</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine"> }</div>
    </div>
    <h3><a name="可渲染3d文本"></a>可渲染3D文本</h3>
    <p>只需利用linear_extrude(height);函数即可轻松实现。</p>
    <hr />
    <h1><a name="openscad用户手册2d-到-3d-拉伸"></a>OpenSCAD用户手册/2D 到 3D 拉伸</h1>
    <p>&nbsp;</p>
    <p><a target="wikibook"href="https://zh.wikipedia.org/wiki/Extrusion">挤压成型</a>是以固定截面形状来创建工件的一道工序。OpenSCAD为从2D形状创建3D实体提供了两种命令：linear_extrude()与rotate_extrude()。线性挤型就如同把橡皮泥放入特定形状的模具，再通过挤压成型。
    </p>
    <p><img src="img/220px-Playdoh.jpg"></p>
    <p>linear_extrude()的工作方式就像一台橡皮泥的挤压机</p>
    <p>旋转挤型就类似于在陶轮上制作碗的过程。Potter&#39;s wheel.</p>
    <p><img src="img/220px-Potter_in_Rabka_04.JPG"></p>
    <p>rotate_extrude() emulates throwing a vessel</p>
    <p>两种挤型方法处理的目标都是位于X-Y平面上的(可能是不连续的)2D几何图形。While transformations that operates on both 2D shapes and 3D solids can move a shape off the X-Y plane, whenthe extrusion is performed the end result is not very intuitive. What actually happens is that any information in the third coordinate (the Zcoordinate) is ignored for any 2D shape, this process amounts to an implicit <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/3D_to_2D_Projection&amp;action=edit&amp;redlink=1">projection()</a>performed on any 2D shape before the extrusion is executed. It is recommended to perform extrusion on shapes that remains strictly on the X-Y plane.
    </p>
    <h3><a name="目录-n3459"></a>目录</h3>
    <ul>
        <li> 1 线性挤型
            <ul>
                <li><a href="#用法">1.1 用法</a></li>
                <li><a href="#twist">1.2 Twist</a></li>
                <li><a href="#center">1.3 Center</a></li>
                <li><a href="#mesh-refinement">1.4 Mesh Refinement</a></li>
                <li><a href="#scale">1.5 Scale</a></li>
            </ul>
        </li>
        <li><a href="#rotate-extrude">2 Rotate Extrude</a>
            <ul>
                <li><a href="#用法-n3544">2.1 用法</a></li>
                <li><a href="#示例">2.2 示例</a></li>
                <li><a href="#mesh-refinement_2">2.3 Mesh Refinement</a></li>
                <li><a href="#extruding_a_polygon">2.4 Extruding a Polygon</a></li>
            </ul>
        </li>
        <li> 3 挤型参数的相关描述
            <ul>
                <li><a href="#针对所有挤型模式的挤型参数">3.1 针对所有挤型模式的挤型参数</a></li>
                <li><a href="#仅用于线性挤型的挤型参数">3.2 仅用于线性挤型的挤型参数</a></li>
            </ul>
        </li>
    </ul>
    <h3><a name="线性挤型"></a>线性挤型</h3>
    <p>线性挤型（LinearExtrusion）是一种以2D多边形作为输入，并令其在3D空间进行扩展的建模操作。这样，就可创建出一个3D几何形状。请牢记，挤型总是以XY平面开始，并按照高度的指示沿<strong>Z</strong>轴来挤压3D形状；因此，如果您在挤型之前运用了旋转或其他变换的话，挤型函数将依照2D多边形在XY平面上的投影进行处理。
    </p>
    <h3><a name="用法"></a>用法</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = fanwidth, center = true, convexity = 10, twist = -fanrot, slices = 20, scale = 1.0, $fn = 16) {...}
        </div>
    </div>
    <p>由于向后兼容的问题，您必须使用参数名。</p>
    <p><code>height</code>必须为正数。</p>
    <p><code>$fn</code>是指定linear_extrude分辨率的可选项（值越大图形越“平滑”，但计算时间也将随之增加）。</p>
    <p>If the extrusion fails for a non-trivial 2D shape, try setting the convexity parameter (the default is not 10, but 10 is a &quot;good&quot; value totry). See explanation further down.</p>
    <h3><a name="twist"></a>Twist</h3>
    <p>Twist is the number of degrees of through which the shape is extruded. Setting the parameter twist = 360 will extrude through one revolution. Thetwist direction follows the left hand rule.</p>
    <p><img src="img/Openscad_linext_01.jpg"></p>
    <p><strong>0° of Twist</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = true, convexity = 10, twist = 0)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <p><img src="img/400px-Openscad_linext_02.jpg"></p>
    <p><strong>-100° of Twist</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = true, convexity = 10, twist = -100)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <p><img src="img/400px-Openscad_linext_03.jpg"></p>
    <p><strong>100° of Twist</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = true, convexity = 10, twist = 100)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <p><img src="img/400px-Openscad_linext_04.jpg"></p>
    <p><strong>-500° of Twist</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = true, convexity = 10, twist = -500)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <h3><a name="center"></a>Center</h3>
    <p>It is similar to the parameter center of cylinders. If <code>center</code> is false the linear extrusion Z range is from 0 to height; if it is true,the range is from -height/2 to height/2.</p>
    <p><img src="img/400px-Openscad_linext_04.jpg"></p>
    <p><strong>center = true</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = true, convexity = 10, twist = -500)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <p><img src="img/400px-Openscad_linext_05.jpg"></p>
    <p><strong>center = false</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = false, convexity = 10, twist = -500)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <h3><a name="mesh-refinement"></a>Mesh Refinement</h3>
    <p>The slices parameter defines the number of intermediate points along the Z axis of the extrusion. Its default increases with the value of twist.Explicitly setting slices may improve the output refinement.</p>
    <p><img src="img/400px-Openscad_linext_06.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = false, convexity = 10, twist = 360, slices = 100)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <p>The <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Other_Language_Features&amp;action=edit&amp;redlink=1">specialvariables</a> $fn, $fs and $fa can also be used to improve the output. If slices is not defined, its value is taken from the defined $fn value.
    </p>
    <p><img src="img/400px-Openscad_linext_07.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">linear_extrude(height = 10, center = false, convexity = 10, twist = 360, $fn = 100)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <h3><a name="scale"></a>Scale</h3>
    <p>Scales the 2D shape by this value over the height of the extrusion. Scale can be a scalar or a vector:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> linear_extrude(height = 10, center = true, convexity = 10, scale=3)</div>
        <div class="codeLine"> translate([2, 0, 0])</div>
        <div class="codeLine"> circle(r = 1);</div>
    </div>
    <p><img src="img/400px-Openscad_linext_09.png"></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> linear_extrude(height = 10, center = true, convexity = 10, scale=[1,5], $fn=100)</div>
        <div class="codeLine"> translate([2, 0, 0])</div>
        <div class="codeLine"> circle(r = 1);</div>
    </div>
    <p><img src="img/400px-OpenScad_linear_extrude_scale_example2.png"></p>
    <p>Note that if scale is a vector, the resulting side walls may be nonplanar. Use <code>twist=0</code> and the
        <code>slices</code> parameter to avoid <a target="wikibook" href="https://github.com/openscad/openscad/issues/1341">asymmetry</a>.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> linear_extrude(height=10, scale=[1,0.1], slices=20, twist=0)</div>
        <div class="codeLine"> polygon(points=[[0,0],[20,10],[20,-10]]);</div>
    </div>
    <h3><a name="rotate-extrude"></a>Rotate Extrude</h3>
    <p>Rotational extrusion spins a 2D shape around the Z-axis to form a solid which has rotational symmetry. One way to think of this operation is toimagine a Potter&#39;s wheel placed on the X-Y plane with its axis of rotation pointing up towards +Z. Then place the to-be-made object on thisvirtual Potter&#39;s wheel (possibly extended down below the X-Y plane towards -Z, take the cross-section of this object on the X-Z plane but keeponly the right half (X &gt;= 0). That is the 2D shape that need to be fed to rotate_extrude() as the child in order to generate this solid.</p>
    <p>Since a 2D shape is rendered by OpenSCAD on the X-Y plane, an alternative way to think of this operation is as follows: spins a 2D shape around theY-axis to form a solid. The resultant solid is placed so that its axis of rotation lies along the Z-axis.</p>
    <p>It can not be used to produce a helix or screw threads.</p>
    <p>The 2D shape needs to lie completely on either the right (recommended) or the left side of the Y-axis. More precisely speaking, each vertex of theshape must have either x &gt;= 0 or x &lt;= 0. If the shape crosses the X axis a warning will be shown in the console windows and therotate_extrude() will be ignored. For OpenSCAD versions prior to 2016.xxxx, if the shape is in the negative axis the faces will be inside-out, whichmay cause undesired effects.</p>
    <p><strong>参数</strong></p>
    <h3><a name="用法-n3544"></a>用法</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate_extrude(angle = 360, convexity = 2) {...}</div>
    </div>
    <p><img src="img/220px-Right-hand_grip_rule.svg.png"></p>
    <p>Right-hand grip rule</p>
    <p>You must use parameter names due to a backward compatibility issue.</p>
    <ul>
        <li> convexity - If the extrusion fails for a non-trival 2D shape, try setting the convexity parameter (the default is not 10, but 10 is a&quot;good&quot; value to try). See explanation further down.</li>
        <li> angle - <strong>[请注意: *需要使用版本*<em>2015.09*</em>*]</strong> <br> Defaults to 360. Specifies the number of degrees to sweep, starting at thepositive X axis. The direction of the sweep follows the
            <a target="wikibook" href="https://en.wikipedia.org/wiki/right-hand_rule">Right Hand Rule</a>, hence a negative angle will sweep clockwise.</li>
    </ul>
    <h3><a name="示例"></a>示例</h3>
    <p><img src="img/400px-Rotate_extrude_wiki_2D.jpg"></p>
    <p><img src="img/400px-Openscad_rotext_01.jpg"></p>
    <p>A simple torus can be constructed using a rotational extrude.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate_extrude(convexity = 10)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1);</div>
    </div>
    <h3><a name="mesh-refinement-n3561"></a>Mesh Refinement</h3>
    <p><img src="img/380px-Rotate_extrude_wiki_2D_C.jpg"></p>
    <p><img src="img/400px-Openscad_rotext_02.jpg"></p>
    <p>Increasing the number of fragments that the 2D shape is composed of will improve the quality of the mesh, but take longer to render.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate_extrude(convexity = 10)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1, $fn = 100);</div>
    </div>
    <p><img src="img/380px-Rotate_extrude_wiki_2D_C.jpg"></p>
    <p><img src="img/400px-Openscad_rotext_03.jpg"></p>
    <p>The number of fragments used by the extrusion can also be increased.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate_extrude(convexity = 10, $fn = 100)</div>
        <div class="codeLine">translate([2, 0, 0])</div>
        <div class="codeLine">circle(r = 1, $fn = 100);</div>
    </div>
    <p>Using the parameter angle (with OpenSCAD versions 2016.xx), a hook can be modeled .</p>
    <p><img src="img/Hook.png"></p>
    <p>OpenSCAD - a hook</p>
    <div class="CodeMirror-code">
        <div class="codeLine">translate([0,60,0])</div>
        <div class="codeLine"> &nbsp; rotate_extrude(angle=270, convexity=10)</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([40, 0]) circle(10);</div>
        <div class="codeLine">rotate_extrude(angle=90, convexity=10)</div>
        <div class="codeLine"> &nbsp; translate([20, 0]) circle(10);</div>
        <div class="codeLine">translate([20,0,0]) </div>
        <div class="codeLine"> &nbsp; rotate([90,0,0]) cylinder(r=10,h=80);</div>
    </div>
    <h3><a name="extruding-a-polygon"></a>Extruding a Polygon</h3>
    <p>Extrusion can also be performed on polygons with points chosen by the user.</p>
    <p>Here is a simple polygon and its 200 step rotational extrusion. (Note it has been rotated 90 degrees to show how the rotation will look; the
        <code>rotate_extrude()</code> needs it flat).</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate([90,0,0]) &nbsp; &nbsp; &nbsp; polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );</div>
        <div class="codeLine">rotate_extrude($fn=200) polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );</div>
    </div>
    <p><img src="img/300px-Rotate_extrude_wiki_2D_B.jpg"></p>
    <p><img src="img/300px-Openscad_polygon_extrusion_1.png">
        <img src="img/300px-Openscad_polygon_extrusion_2.png"></p>
    <p>For more information on polygons, please see: <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/2D_Primitives&amp;action=edit&amp;redlink=1">2D Primitives: Polygon</a>.
    </p>
    <h3><a name="挤型参数的相关描述"></a>挤型参数的相关描述</h3>
    <h3><a name="针对所有挤型模式的挤型参数"></a>针对所有挤型模式的挤型参数</h3>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>convexity</th>
                    <th>Integer. The convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object mightpenetrate.This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on thepolyhedron rendering.</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>&nbsp;</td>
                    <td>&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p><img src="img/400px-Openscad_convexity.jpg"></p>
    <p>This image shows a 2D shape with a convexity of 4, as the ray indicated in red crosses the 2D shape a maximum of 4 times. The convexity of a 3D shapewould be determined in a similar way. Setting it to 10 should work fine for most cases.</p>
    <h3><a name="仅用于线性挤型的挤型参数"></a>仅用于线性挤型的挤型参数</h3>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>height</th>
                    <th>The extrusion height</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>center</td>
                    <td>If true the solid will be centered after extrusion</td>
                </tr>
                <tr>
                    <td>twist</td>
                    <td>The extrusion twist in degrees</td>
                </tr>
                <tr>
                    <td>slices</td>
                    <td>Similar to special variable $fn without being passed down to the child 2D shape.</td>
                </tr>
                <tr>
                    <td>scale</td>
                    <td>Scales the 2D shape by this value over the height of the extrusion.</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <hr />
    <h1><a name="openscad用户手册变换"></a>OpenSCAD用户手册/变换</h1>
    <h3><a name="目录-n3614"></a>目录</h3>
    <ul>
        <li><a href="#基本概念">1 基本概念</a></li>
        <li><a href="#高级概念">2 高级概念</a></li>
        <li><a href="#scale">3 scale</a></li>
        <li><a href="#resize">4 resize</a></li>
        <li> 5 rotate
            <ul>
                <li><a href="#旋转规则提示">5.1 旋转规则提示</a></li>
            </ul>
        </li>
        <li><a href="#translate">6 translate</a></li>
        <li> 7 mirror
            <ul>
                <li><a href="#函数签名">7.1 函数签名:</a></li>
                <li><a href="#examples">7.2 Examples</a></li>
            </ul>
        </li>
        <li> 8 multmatrix
            <ul>
                <li><a href="#不够刺激">8.1 不够刺激？</a></li>
            </ul>
        </li>
        <li> 9 color
            <ul>
                <li><a href="#函数签名-n3780">9.1 函数签名:</a></li>
                <li><a href="#示例">9.2 示例</a></li>
                <li><a href="#示例2">9.3 示例2</a></li>
            </ul>
        </li>
        <li><a href="#offset">10 offset</a></li>
        <li><a href="#minkowski">11 minkowski</a></li>
        <li><a href="#hull">12 hull</a></li>
        <li><a href="#组合变换">13 组合变换</a></li>
    </ul>
    <h3><a name="基本概念"></a>基本概念</h3>
    <p>顾名思义，变换会以各种方式影响子节点，例如对它们进行移动、旋转或缩放。级联变换(cascading transformations)则常用于将多种变换作用于一个最终子对象 。通过嵌套语句即可实现级联变换，即：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate([45,45,45])</div>
        <div class="codeLine"> translate([10,20,30])</div>
        <div class="codeLine"> &nbsp; cube(10);</div>
    </div>
    <p>利用&#39;{&#39; 与 &#39;}&#39;围起子节点树，即可将变换应用于这一组子节点，如：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">translate([0,0,-5])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; cube(10);</div>
        <div class="codeLine"> &nbsp; cylinder(r=5,h=10);</div>
        <div class="codeLine">}</div>
    </div>
    <p>变换要写于其影响的对象之前。</p>
    <p>可以将类似于translate（平移）、mirror（镜像）与scale（缩放）这样的命令想象为动词。而将color（上色）这样的命令想象为描述对象的形容词。</p>
    <p>请注意，变换命令后不加分号。</p>
    <h3><a name="高级概念"></a>高级概念</h3>
    <p>由于OpenSCAD采用不同的库来实现其中功能，因此在用F5预览变换的行为时可能会产生一些不一致的现象。传统的变换(平移，旋转，缩放，镜像与multmatrix)都采用OpenGL实现预览。而其他更为高级的变换，如resize，则用CGAL进行处理，其行为就像CSG操作，影响的是对象本身，而不仅仅是对其进行变换。特别是这会影响修饰符的显示，尤其是&quot;#&quot;与&quot;%&quot;，wherethe highlight may not display intuitively。such as highlighting the pre-resized object, but highlighting the post-scaled object. | |</p>
    <h3><a name="scale-n3672"></a>scale</h3>
    <p>scale命令利用指定的向量来缩放其子元素。参数名可以不写。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">用例：</div>
        <div class="codeLine">scale(v = [x, y, z]) { ... }</div>
        <div class="codeLine">cube(10);</div>
        <div class="codeLine">translate([15,0,0]) scale([0.5,1,2]) cube(10);</div>
    </div>
    <p><img src="img/OpenSCAD_scale%28%29_example.JPG"></p>
    <p>注意： 不要用负数作为缩放值。负缩放值的效果可以在预览中看到，但是通过CGAL渲染时会导致不可预测的错误。如需输入负值，可用mirror()函数代替。</p>
    <h3><a name="resize"></a>resize</h3>
    <p>根据指定的x、y、z修改子对象的尺寸。</p>
    <p>resize()函数由CGAL来实现，就像render()这样的函数一样要处理整个几何体，因此就算是在预览模式下也要花上些时间来进行处理。</p>
    <p>用例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 将球体在x轴上的直径拓展至30，在y轴上的直径拓展至60，在z轴上的直径拓展至10。</div>
        <div class="codeLine">resize(newsize=[30,60,10]) sphere(r=10);</div>
    </div>
    <p><img src="img/400px-OpenSCAD_Resize_example_elipse.JPG"></p>
    <p>如果x、y或z为0，那么原对象在对应维度上保持不变。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 将大小为1x1x1的立方体调整为2x2x1</div>
        <div class="codeLine">resize([2,2,0]) cube();</div>
    </div>
    <p>如果把&#39;auto&#39;参数设置为true，则resize函数将对参数值为0的维度进行自动缩放。例如：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 将大小为1x2x0.5的长方体调整为7x14x3.5</div>
        <div class="codeLine">resize([7,0,0], auto=true) cube([1,2,0.5]);</div>
    </div>
    <p>&#39;auto&#39;参数也可用于仅对一个维度进行自动缩放而其他维度保持不变的情况。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 将原长方体调整为10x8x1。请注意，其z维度保持不变。</div>
        <div class="codeLine">resize([10,0,0], auto=[true,true,false]) cube([5,4,1]);</div>
    </div>
    <h3><a name="rotate"></a>rotate</h3>
    <p>令子元素绕坐标轴或任意轴旋转&#39;a&#39;度。如果将参数按下列相同顺序指定，则可省略参数名。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">//用例:</div>
        <div class="codeLine">rotate(a = deg_a, v = [x, y, z]) { ... } &nbsp;</div>
        <div class="codeLine">// 或</div>
        <div class="codeLine">rotate(deg_a, [x, y, z]) { ... }</div>
        <div class="codeLine">rotate(a = [deg_x, deg_y, deg_z]) { ... }</div>
        <div class="codeLine">rotate([deg_x, deg_y, deg_z]) { ... }</div>
    </div>
    <p>参数&#39;a&#39;(deg_a)可以是一个数组，其语法如上所示；当deg_a是一个数组时，将忽略参数&#39;v&#39;。而此时的&#39;a&#39;则指定的是令物体绕<em>多个坐标轴</em>进行旋转，而旋转的执行顺序为：x, y, z。这就意味着下列代码：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(a=[ax,ay,az]) {...}</div>
    </div>
    <p>等价于（旋转顺序会影响最终旋转结果）：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(a=[0,0,az]) rotate(a=[0,ay,0]) rotate(a=[ax,0,0]) {...}</div>
    </div>
    <p>可选参数&#39;v&#39;是一个向量，您可借此令对象绕任意轴进行旋转。</p>
    <p>例如，为了让一个对象上下颠倒翻转过来，您可以令此对象绕&#39;y&#39;轴旋转180度。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(a=[0,180,0]) { ... }</div>
    </div>
    <p>常用化简写法为：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate([0,180,0]) { ... }</div>
    </div>
    <p>在指定单个坐标轴时，通过设置参数&#39;v&#39;也能令对象绕坐标轴进行旋转。例如，以下代码是上述代码的等效实现，它令对象仅绕轴y进行旋转</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(a=180, v=[0,1,0]) { ... }</div>
    </div>
    <p>在指定单个坐标轴时，参数&#39;v&#39;是一个定义任意旋转轴的<a target="wikibook"href="https://en.wikipedia.org/wiki/Euler_vector">向量</a>；这与此前提及的绕<em>多个坐标轴</em>进行旋转并不相同。例如，令对象绕向量[1,1,0]定义的轴旋转45度的代码为</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(a=45, v=[1,1,0]) { ... }</div>
    </div>
    <p><img src="img/OpenSCAD_rotate%28%29_example.JPG"></p>
    <p>利用<em>单个标量参数</em>令对象绕Z轴进行旋转。这种方法在2D环境中十分有用，此时通常仅绕一种轴进行旋转。例如：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate(45) square(10);</div>
    </div>
    <p><img src="img/Example_2D_Rotate.JPG"></p>
    <h3><a name="旋转规则提示"></a>旋转规则提示</h3>
    <p><img src="img/220px-Right-hand_grip_rule.svg.png"></p>
    <p>右手定则</p>
    <p>针对以下情况：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate([a, b, c]) { ... };</div>
    </div>
    <p>&quot;a&quot;是一个令对象从+Y轴方向至+Z轴方向绕X轴旋转的旋转角。 &quot;b&quot;是一个令对象从+Z轴方向至+X轴方向绕Y轴旋转的旋转角。 &quot;c&quot;是一个令对象从+X轴方向至+Y轴方向绕Z轴旋转的旋转角。</p>
    <p>这些情况均遵从<a target="wikibook" href="https://en.wikipedia.org/wiki/right-hand_rule">右手法则</a>。右手拇指指向旋转轴的正方向，则其他手指的自然弯曲方向即为旋转方向。</p>
    <p>因此，如果&quot;a&quot;恒为0，且对&quot;b&quot;与&quot;c&quot;进行适当的计算，便可将rotate()当作<em>球坐标系</em>来使用。 所以，为了构建从原点至(x,y,z)的圆柱体，可以这样编写代码：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">x= 10; y = 10; z = 10; // 圆柱体的端点坐标</div>
        <div class="codeLine"> </div>
        <div class="codeLine">length = norm([x,y,z]); // 半径距离</div>
        <div class="codeLine">b = acos(z/length); // 倾角（inclination angle）</div>
        <div class="codeLine">c = atan2(y,x); &nbsp; &nbsp; // 方位角（azimuthal angle）</div>
        <div class="codeLine">​</div>
        <div class="codeLine">rotate([0, b, c]) </div>
        <div class="codeLine"> &nbsp; cylinder(h=length, r=0.5);</div>
        <div class="codeLine">%cube([x,y,z]); // 圆柱体的端点应与立方体的交点重合</div>
    </div>
    <p><img src="img/Example_xyz_rotation_in_OpenSCAD.JPG"></p>
    <h3><a name="translate"></a>translate</h3>
    <p>沿指定向量平移(移动)子元素。可省略参数名。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">示例:</div>
        <div class="codeLine">translate(v = [x, y, z]) { ... }</div>
        <div class="codeLine">cube(2,center = true); </div>
        <div class="codeLine">translate([5,0,0]) </div>
        <div class="codeLine"> &nbsp; sphere(1,center = true);</div>
    </div>
    <p><img src="img/OpenSCAD_translate%28%29_example.JPG"></p>
    <h3><a name="mirror"></a>mirror</h3>
    <p>基于原点对平面上的子元素进行镜像操作。传入mirror()函数的参数为交于原点且用于镜像对象的平面上的法向量。</p>
    <h3><a name="函数签名"></a>函数签名:</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">mirror(v= [x, y, z] ) { ... }</div>
    </div>
    <h3><a name="examples"></a>Examples</h3>
    <p>左侧为原始对象。请注意，镜像并非复制品。而是像rotate与scale函数那样，改变对象本身。</p>
    <ul>
        <li>
            <p><img src="img/Mirror-x.png"></p>
            <p><code>hand(); // 原始对象</code>
                <code>mirror([1,0,0]) hand();</code></p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/Mirror-x-y.png"></p>
            <p><code>hand(); // 原始对象</code>
                <code>mirror([1,1,0]) hand();</code></p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/Mirror-x-y-z.png"></p>
            <p><code>hand(); // 原始对象</code>
                <code>mirror([1,1,1]) hand();</code></p>
        </li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine">rotate([0,0,10]) cube([3,2,1]);</div>
        <div class="codeLine">mirror([1,0,0]) translate([1,0,0]) rotate([0,0,10]) cube([3,2,1]);</div>
    </div>
    <p><img src="img/OpenSCAD_mirror%28%29_example.JPG"></p>
    <h3><a name="multmatrix"></a>multmatrix</h3>
    <p>为所有子元素的几何体乘上指定的4x4变换矩阵。</p>
    <p>用法: multmatrix(m = [...]) { ... }</p>
    <p>以下为矩阵中前三行每一元素的内含解析：</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>[Scale X]</th>
                    <th>[Scale X sheared along Y]</th>
                    <th>[Scale X sheared along Z]</th>
                    <th>[Translate X]</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>[Scale Y sheared along X]</td>
                    <td>[Scale Y]</td>
                    <td>[Scale Y sheared along Z]</td>
                    <td>[Translate Y]</td>
                </tr>
                <tr>
                    <td>[Scale Z sheared along X]</td>
                    <td>[Scale Z sheared along Y]</td>
                    <td>[Scale Z]</td>
                    <td>[Translate Z]</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>第四行用于在3D环境中定义对象的视图。在OpenSCAD中没有用到这一点，应将其设置为[0,0,0,1]。</p>
    <p>以下示例为将对象在XY平面内旋转45度，并按[10,20,30]进行平移，其效果与<code>translate([10,20,30]) rotate([0,0,45])</code>相同。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">angle=45;</div>
        <div class="codeLine">multmatrix(m = [ [cos(angle), -sin(angle), 0, 10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [sin(angle), cos(angle), 0, 20],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ &nbsp; &nbsp; &nbsp; &nbsp; 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0, 1, 30],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ &nbsp; &nbsp; &nbsp; &nbsp; 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0, 0, 1]</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]) union() {</div>
        <div class="codeLine"> &nbsp; cylinder(r=10.0,h=10,center=false);</div>
        <div class="codeLine"> &nbsp; cube(size=[10,10,10],center=false);</div>
        <div class="codeLine">}</div>
    </div>
    <p>以下为令模型倾斜（skew）的示例，这是不能由其他变换来实现的。此例也展示了可将矩阵置于一个变量中。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">M = [ [ 1 , 0 , 0 , 0 &nbsp; ],</div>
        <div class="codeLine"> &nbsp; &nbsp; [ 0 , 1 , 0.7, 0 &nbsp; ], // "0.7"为倾斜值；在这里，它令对象偏离y轴发生倾斜</div>
        <div class="codeLine"> &nbsp; &nbsp; [ 0 , 0 , 1 , 0 &nbsp; ],</div>
        <div class="codeLine"> &nbsp; &nbsp; [ 0 , 0 , 0 , 1 &nbsp; ] ] ;</div>
        <div class="codeLine">multmatrix(M) { union() {</div>
        <div class="codeLine"> &nbsp; cylinder(r=10.0,h=10,center=false);</div>
        <div class="codeLine"> &nbsp; cube(size=[10,10,10],center=false); </div>
        <div class="codeLine">} }</div>
    </div>
    <h3><a name="不够刺激"></a>不够刺激？</h3>
    <p>来这里学习更多的相关知识吧：</p>
    <ul>
        <li><a href="#affine_transformations">仿射变换</a> on wikipedia</li>
        <li><a target="wikibook" href="http://www.senocular.com/flash/tutorials/transformmatrix/" target="_blank"class="url">http://www.senocular.com/flash/tutorials/transformmatrix/</a></li>
    </ul>
    <h3><a name="color"></a>color</h3>
    <p>利用指定的RGB颜色 + alpha值来显示子元素。此函数仅用于F5预览，因为CGAL 与 STL (F6)当前还不支持上色。如果未指定alpha值，其默认值为1.0(不透明)。</p>
    <h3><a name="函数签名-n3780"></a>函数签名:</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">color( c = [r, g, b, a] ) { ... }</div>
        <div class="codeLine">color( c = [r, g, b], alpha = 1.0 ) { ... }</div>
        <div class="codeLine">color( "#hexvalue" ) { ... }</div>
        <div class="codeLine">color( "colorname", 1.0 ) { ... }</div>
    </div>
    <p>请注意，<code>r, g, b, a</code>值仅限于<strong>[0,1]</strong>范围中的浮点值，而非相对传统的{ 0 ... 255 }整数值。然鹅，没有神马能阻止您通过适当的比例转换方式<code>color([ R/255, G/255, B/255 ]) { ...}</code>来运用{0 ... 255}范围的<code>R, G, B</code>值：</p>
    <p><strong>[请注意: *需要使用版本 *<em>2011.12*</em>*]</strong> 可以通过颜色名称(大小写<strong>不</strong>敏感)来定义颜色。例如，要创建一个红色的球体，您可以写<code>color(&quot;red&quot;)sphere(5);</code>。对于采用颜色名称指定颜色的方式而言，还要为alpha值额外指定一个参数：<code>color(&quot;Blue&quot;,0.5) cube(5);</code></p>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong> 表示颜色的16进制值有4种格式：<code>#rgb</code>, <code>#rgba</code>, <code>#rrggbb</code> 与
        <code>#rrggbbaa</code>。如果alpha值以单独的16进制参数给出，the alpha parameter will take precedence.</p>
    <p>可用的颜色名称都取自万维网联盟的[<a target="wikibook" href="http://www.w3.org/TR/css3-color/SVG配色列表">1]</a>。下面给出一幅颜色名称图表,
        <em>(请注意，包括slategrey/slategray等在内的grey/gray拼写都是合法的)</em>:</p>
    <figure>
        <table style="font-size:90%;border-style:solid;border-color:black;border-width:1px;" cellpadding="4" width="100%">
            <tbody>
                <tr valign="top">
                    <td width="20%">
                        <table width="100%">
                            <tbody>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Purples</b></big></td>
                                </tr>
                                <tr style="background:lavender;color:black">
                                    <td>Lavender</td>
                                </tr>
                                <tr style="background:thistle;color:black">
                                    <td>Thistle</td>
                                </tr>
                                <tr style="background:plum;color:black">
                                    <td>Plum</td>
                                </tr>
                                <tr style="background:violet;color:black">
                                    <td>Violet</td>
                                </tr>
                                <tr style="background:orchid;color:black">
                                    <td>Orchid</td>
                                </tr>
                                <tr style="background:fuchsia;color:white">
                                    <td>Fuchsia</td>
                                </tr>
                                <tr style="background:Magenta;color:white">
                                    <td>Magenta</td>
                                </tr>
                                <tr style="background:mediumorchid;color:white">
                                    <td>MediumOrchid</td>
                                </tr>
                                <tr style="background:mediumpurple;color:white">
                                    <td>MediumPurple</td>
                                </tr>
                                <tr style="background:#9966CC;color:white">
                                    <td>BlueViolet</td>
                                </tr>
                                <tr style="background:darkviolet;color:white">
                                    <td>DarkViolet</td>
                                </tr>
                                <tr style="background:darkorchid;color:white">
                                    <td>DarkOrchid</td>
                                </tr>
                                <tr style="background:darkmagenta;color:white">
                                    <td>DarkMagenta</td>
                                </tr>
                                <tr style="background:purple;color:white">
                                    <td>Purple</td>
                                </tr>
                                <tr style="background:indigo;color:white">
                                    <td>Indigo</td>
                                </tr>
                                <tr style="background:darkslateblue;color:white">
                                    <td>DarkSlateBlue</td>
                                </tr>
                                <tr style="background:slateblue;color:white">
                                    <td>SlateBlue</td>
                                </tr>
                                <tr style="background:mediumslateblue;color:white">
                                    <td>MediumSlateBlue</td>
                                </tr>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Pinks</b></big></td>
                                </tr>
                                <tr style="background:pink;color:black">
                                    <td>Pink</td>
                                </tr>
                                <tr style="background:lightpink;color:black">
                                    <td>LightPink</td>
                                </tr>
                                <tr style="background:hotpink;color:white">
                                    <td>HotPink</td>
                                </tr>
                                <tr style="background:deeppink;color:white">
                                    <td>DeepPink</td>
                                </tr>
                                <tr style="background:mediumvioletred;color:white">
                                    <td>MediumVioletRed</td>
                                </tr>
                                <tr style="background:palevioletred;color:white">
                                    <td>PaleVioletRed</td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td width="20%">
                        <table width="100%">
                            <tbody>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Blues</b></big></td>
                                </tr>
                                <tr style="background:aqua;color:black">
                                    <td>Aqua</td>
                                </tr>
                                <tr style="background:cyan;color:black">
                                    <td>Cyan</td>
                                </tr>
                                <tr style="background:lightcyan;color:black">
                                    <td>LightCyan</td>
                                </tr>
                                <tr style="background:paleturquoise;color:black">
                                    <td>PaleTurquoise</td>
                                </tr>
                                <tr style="background:aquamarine;color:black">
                                    <td>Aquamarine</td>
                                </tr>
                                <tr style="background:turquoise;color:black">
                                    <td>Turquoise</td>
                                </tr>
                                <tr style="background:mediumturquoise;color:black">
                                    <td>MediumTurquoise</td>
                                </tr>
                                <tr style="background:darkturquoise;color:white">
                                    <td>DarkTurquoise</td>
                                </tr>
                                <tr style="background:cadetblue;color:white">
                                    <td>CadetBlue</td>
                                </tr>
                                <tr style="background:steelblue;color:white">
                                    <td>SteelBlue</td>
                                </tr>
                                <tr style="background:lightsteelblue;color:black">
                                    <td>LightSteelBlue</td>
                                </tr>
                                <tr style="background:powderblue;color:black">
                                    <td>PowderBlue</td>
                                </tr>
                                <tr style="background:lightblue;color:black">
                                    <td>LightBlue</td>
                                </tr>
                                <tr style="background:skyblue;color:black">
                                    <td>SkyBlue</td>
                                </tr>
                                <tr style="background:lightskyblue;color:black">
                                    <td>LightSkyBlue</td>
                                </tr>
                                <tr style="background:deepskyblue;color:white">
                                    <td>DeepSkyBlue</td>
                                </tr>
                                <tr style="background:dodgerblue;color:white">
                                    <td>DodgerBlue</td>
                                </tr>
                                <tr style="background:cornflowerblue;color:white">
                                    <td>CornflowerBlue</td>
                                </tr>
                                <tr style="background:royalblue;color:white">
                                    <td>RoyalBlue</td>
                                </tr>
                                <tr style="background:blue;color:white">
                                    <td>Blue</td>
                                </tr>
                                <tr style="background:mediumblue;color:white">
                                    <td>MediumBlue</td>
                                </tr>
                                <tr style="background:darkblue;color:white">
                                    <td>DarkBlue</td>
                                </tr>
                                <tr style="background:navy;color:white">
                                    <td>Navy</td>
                                </tr>
                                <tr style="background:midnightblue;color:white">
                                    <td>MidnightBlue</td>
                                </tr>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center;"><big><b>Reds</b></big></td>
                                </tr>
                                <tr style="background:indianred;color:white">
                                    <td>IndianRed</td>
                                </tr>
                                <tr style="background:lightcoral;color:black">
                                    <td>LightCoral</td>
                                </tr>
                                <tr style="background:salmon;color:black">
                                    <td>Salmon</td>
                                </tr>
                                <tr style="background:darksalmon;color:black">
                                    <td>DarkSalmon</td>
                                </tr>
                                <tr style="background:lightsalmon;color:black">
                                    <td>LightSalmon</td>
                                </tr>
                                <tr style="background:red;color:white">
                                    <td>Red</td>
                                </tr>
                                <tr style="background:crimson;color:white;color:white">
                                    <td>Crimson</td>
                                </tr>
                                <tr style="background:fireBrick;color:white">
                                    <td>FireBrick</td>
                                </tr>
                                <tr style="background:darkred;color:white">
                                    <td>DarkRed</td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td width="20%">
                        <table width="100%">
                            <tbody>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Greens</b></big></td>
                                </tr>
                                <tr style="background:greenyellow;color:black">
                                    <td>GreenYellow</td>
                                </tr>
                                <tr style="background:chartreuse;color:black">
                                    <td>Chartreuse</td>
                                </tr>
                                <tr style="background:lawngreen;color:black">
                                    <td>LawnGreen</td>
                                </tr>
                                <tr style="background:lime;color:black">
                                    <td>Lime</td>
                                </tr>
                                <tr style="background:limegreen;color:black">
                                    <td>LimeGreen</td>
                                </tr>
                                <tr style="background:palegreen;color:black">
                                    <td>PaleGreen</td>
                                </tr>
                                <tr style="background:lightgreen;color:black">
                                    <td>LightGreen</td>
                                </tr>
                                <tr style="background:mediumspringgreen;color:black">
                                    <td>MediumSpringGreen</td>
                                </tr>
                                <tr style="background:springgreen;color:black">
                                    <td>SpringGreen</td>
                                </tr>
                                <tr style="background:mediumseagreen;color:white">
                                    <td>MediumSeaGreen</td>
                                </tr>
                                <tr style="background:seagreen;color:white">
                                    <td>SeaGreen</td>
                                </tr>
                                <tr style="background:forestgreen;color:white">
                                    <td>ForestGreen</td>
                                </tr>
                                <tr style="background:green;color:white">
                                    <td>Green</td>
                                </tr>
                                <tr style="background:darkgreen;color:white">
                                    <td>DarkGreen</td>
                                </tr>
                                <tr style="background:yellowgreen;color:black">
                                    <td>YellowGreen</td>
                                </tr>
                                <tr style="background:olivedrab;color:white">
                                    <td>OliveDrab</td>
                                </tr>
                                <tr style="background:olive;color:white">
                                    <td>Olive</td>
                                </tr>
                                <tr style="background:darkolivegreen;color:white">
                                    <td>DarkOliveGreen</td>
                                </tr>
                                <tr style="background:mediumaquamarine;color:black">
                                    <td>MediumAquamarine</td>
                                </tr>
                                <tr style="background:darkseagreen;color:black">
                                    <td>DarkSeaGreen</td>
                                </tr>
                                <tr style="background:lightseagreen;color:white">
                                    <td>LightSeaGreen</td>
                                </tr>
                                <tr style="background:darkcyan;color:white">
                                    <td>DarkCyan</td>
                                </tr>
                                <tr style="background:teal;color:white">
                                    <td>Teal</td>
                                </tr>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Oranges</b></big></td>
                                </tr>
                                <tr style="background:lightsalmon;color:black">
                                    <td>LightSalmon</td>
                                </tr>
                                <tr style="background:coral;color:white">
                                    <td>Coral</td>
                                </tr>
                                <tr style="background:tomato;color:white">
                                    <td>Tomato</td>
                                </tr>
                                <tr style="background:orangered;color:white">
                                    <td>OrangeRed</td>
                                </tr>
                                <tr style="background:darkorange;color:white">
                                    <td>DarkOrange</td>
                                </tr>
                                <tr style="background:orange;color:white">
                                    <td>Orange</td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td width="20%">
                        <table width="100%">
                            <tbody>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Yellows</b></big></td>
                                </tr>
                                <tr style="background:gold;color:black">
                                    <td>Gold</td>
                                </tr>
                                <tr style="background:yellow;color:black">
                                    <td>Yellow</td>
                                </tr>
                                <tr style="background:lightyellow;color:black">
                                    <td>LightYellow</td>
                                </tr>
                                <tr style="background:lemonchiffon;color:black">
                                    <td>LemonChiffon</td>
                                </tr>
                                <tr style="background:lightgoldenrodyellow;color:black">
                                    <td>LightGoldenrodYellow</td>
                                </tr>
                                <tr style="background:papayawhip;color:black">
                                    <td>PapayaWhip</td>
                                </tr>
                                <tr style="background:moccasin;color:black">
                                    <td>Moccasin</td>
                                </tr>
                                <tr style="background:peachpuff;color:black">
                                    <td>PeachPuff</td>
                                </tr>
                                <tr style="background:palegoldenrod;color:black">
                                    <td>PaleGoldenrod</td>
                                </tr>
                                <tr style="background:khaki;color:black">
                                    <td>Khaki</td>
                                </tr>
                                <tr style="background:darkkhaki;color:black">
                                    <td>DarkKhaki</td>
                                </tr>
                                <tr>
                                    <td style="background:whitesmoke;color:slategray;text-align:center"><big><b>Browns</b></big></td>
                                </tr>
                                <tr style="background:cornsilk;color:black">
                                    <td>Cornsilk</td>
                                </tr>
                                <tr style="background:blanchedalmond;color:black">
                                    <td>BlanchedAlmond</td>
                                </tr>
                                <tr style="background:bisque;color:black">
                                    <td>Bisque</td>
                                </tr>
                                <tr style="background:navajowhite;color:black">
                                    <td>NavajoWhite</td>
                                </tr>
                                <tr style="background:wheat;color:black">
                                    <td>Wheat</td>
                                </tr>
                                <tr style="background:burlywood;color:black">
                                    <td>BurlyWood</td>
                                </tr>
                                <tr style="background:tan;color:black">
                                    <td>Tan</td>
                                </tr>
                                <tr style="background:rosybrown;color:black">
                                    <td>RosyBrown</td>
                                </tr>
                                <tr style="background:sandybrown;color:black">
                                    <td>SandyBrown</td>
                                </tr>
                                <tr style="background:goldenrod;color:black">
                                    <td>Goldenrod</td>
                                </tr>
                                <tr style="background:darkgoldenrod;color:white">
                                    <td>DarkGoldenrod</td>
                                </tr>
                                <tr style="background:Peru;color:white">
                                    <td>Peru</td>
                                </tr>
                                <tr style="background:chocolate;color:white">
                                    <td>Chocolate</td>
                                </tr>
                                <tr style="background:saddlebrown;color:white">
                                    <td>SaddleBrown</td>
                                </tr>
                                <tr style="background:sienna;color:white">
                                    <td>Sienna</td>
                                </tr>
                                <tr style="background:brown;color:white">
                                    <td>Brown</td>
                                </tr>
                                <tr style="background:maroon;color:white">
                                    <td>Maroon</td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                    <td width="20%">
                        <table width="100%">
                            <tbody>
                                <tr style="background:whitesmoke;color:slategray;text-align:center">
                                    <td><big><b>Whites</b></big></td>
                                </tr>
                                <tr style="background:white;">
                                    <td>White</td>
                                </tr>
                                <tr style="background:snow;">
                                    <td>Snow</td>
                                </tr>
                                <tr style="background:honeydew;">
                                    <td>Honeydew</td>
                                </tr>
                                <tr style="background:mintcream;">
                                    <td>MintCream</td>
                                </tr>
                                <tr style="background:azure;">
                                    <td>Azure</td>
                                </tr>
                                <tr style="background:aliceblue;">
                                    <td>AliceBlue</td>
                                </tr>
                                <tr style="background:ghostwhite;">
                                    <td>GhostWhite</td>
                                </tr>
                                <tr style="background:whitesmoke;">
                                    <td>WhiteSmoke</td>
                                </tr>
                                <tr style="background:seashell;">
                                    <td>Seashell</td>
                                </tr>
                                <tr style="background:beige;">
                                    <td>Beige</td>
                                </tr>
                                <tr style="background:oldlace;">
                                    <td>OldLace</td>
                                </tr>
                                <tr style="background:floralwhite;">
                                    <td>FloralWhite</td>
                                </tr>
                                <tr style="background:ivory;">
                                    <td>Ivory</td>
                                </tr>
                                <tr style="background:antiquewhite;">
                                    <td>AntiqueWhite</td>
                                </tr>
                                <tr style="background:linen;">
                                    <td>Linen</td>
                                </tr>
                                <tr style="background:lavenderblush;">
                                    <td>LavenderBlush</td>
                                </tr>
                                <tr style="background:mistyrose;">
                                    <td>MistyRose</td>
                                </tr>
                                <tr>
                                    <td colspan="3" style="background:whitesmoke;color:slategray;text-align:center"><big><b>Grays</b></big></td>
                                </tr>
                                <tr style="background:gainsboro;color:black">
                                    <td>Gainsboro</td>
                                </tr>
                                <tr style="background:lightgrey;color:black">
                                    <td>LightGrey</td>
                                </tr>
                                <tr style="background:silver;color:black">
                                    <td>Silver</td>
                                </tr>
                                <tr style="background:darkgray;color:black">
                                    <td>DarkGray</td>
                                </tr>
                                <tr style="background:gray;color:black">
                                    <td>Gray</td>
                                </tr>
                                <tr style="background:dimgray;color:white">
                                    <td>DimGray</td>
                                </tr>
                                <tr style="background:lightslategray;color:white">
                                    <td>LightSlateGray</td>
                                </tr>
                                <tr style="background:slategray;color:white">
                                    <td>SlateGray</td>
                                </tr>
                                <tr style="background:darkslategray;color:white">
                                    <td>DarkSlateGray</td>
                                </tr>
                                <tr style="background:black;color:white">
                                    <td>Black</td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="示例-n3800"></a>示例</h3>
    <p><img src="img/220px-Wavy_multicolor_object.jpg"></p>
    <p>一个3-D酷炫多色正弦波模型</p>
    <p>这里给出一个绘制多色波浪对象的代码片段：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> for(i=[0:36]) {</div>
        <div class="codeLine"> &nbsp; for(j=[0:36]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; color( [0.5+sin(10*i)/2, 0.5+sin(10*j)/2, 0.5+sin(10*(i+j))/2] )</div>
        <div class="codeLine"> &nbsp; &nbsp; translate( [i, j, 0] )</div>
        <div class="codeLine"> &nbsp; &nbsp; cube( size = [1, 1, 11+10*cos(10*i)*sin(10*j)] );</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine"> }</div>
    </div>
    <p>↗ 由于 -1&lt;=sin(<em>x</em>)&lt;=1，因此 0&lt;=(1/2 + sin(<em>x</em>)/2)&lt;=1 ，这样即可为RGB分量赋予[0,1]区间中的颜色值。</p>
    <p><em><a target="wikibook" href="https://en.wikipedia.org/wiki/Web_colors">基于Wikipedia中&quot;网页颜色&quot;词条的颜色图表</a></em></p>
    <h3><a name="示例2"></a>示例2</h3>
    <p>在本例中，我们将基于参数来选择性地设置颜色，这里使用了如下技巧：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> module myModule(withColors=false) {</div>
        <div class="codeLine"> &nbsp; c=withColors?"red":undef;</div>
        <div class="codeLine"> &nbsp; color(c) circle(r=10);</div>
        <div class="codeLine"> }</div>
    </div>
    <p>将colorname设置为undef将保持其默认颜色。</p>
    <h3><a name="offset"></a>offset</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>offset函数根据指定的值令2D轮廓外向或内向移动。</p>
    <ul>
        <li>通过正偏移外表面与负偏移内表面之差可方便地绘制薄壁。</li>
        <li>Fillet: offset(r=-3) offset(delta=+3) rounds all inside (concave) corners, and leaves flat walls unchanged. However, holes less than 2*r indiameter will vanish.</li>
        <li>Round: offset(r=+3) offset(delta=-3) rounds all outside (convex) corners, and leaves flat walls unchanged. However, walls less than 2*r thickwill vanish.</li>
    </ul>
    <p><strong>参数</strong></p>
    <ul>
        <li> r | delta - 双精度浮点数（double）。偏移多边形的值。此值为负时，令多边形进行内向偏移。参数r指定的是用于生成圆角的半径，使用delta则采用直边。</li>
        <li>
            <p>chamfer - 布尔值（boolean）。 （默认值为<em>false</em>） 在使用delta参数时，此标志定义了是（以直线进行切割）否（扩展至边的交点）应当对边进行倒角。</p>
        </li>
    </ul>
    <p><img src="img/350px-OpenSCAD_offset_join-type_out.svg.png"></p>
    <p>正的r/delta值</p>
    <p><img src="img/350px-OpenSCAD_offset_join-type_in.svg.png"></p>
    <p>负的r/delta值</p>
    <p>不同参数所得到的结果。黑色多边形是用于offset()处理的输入几何图形。</p>
    <p><strong>示例</strong></p>
    <p><img src="img/220px-OpenSCAD_offset_example.png"></p>
    <p>示例1的效果图。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 示例1</div>
        <div class="codeLine"> </div>
        <div class="codeLine">linear_extrude(height = 60, twist = 90, slices = 60) {</div>
        <div class="codeLine"> &nbsp; difference() {</div>
        <div class="codeLine"> &nbsp; &nbsp; offset(r = 10) {</div>
        <div class="codeLine"> &nbsp; &nbsp; square(20, center = true);</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; offset(r = 8) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; square(20, center = true);</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine"> }</div>
        <div class="codeLine">// 示例2</div>
        <div class="codeLine"> </div>
        <div class="codeLine">module fillet(r) {</div>
        <div class="codeLine"> &nbsp; offset(r = -r) {</div>
        <div class="codeLine"> &nbsp; &nbsp; offset(delta = r) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; children();</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="minkowski"></a>minkowski</h3>
    <p><img src="img/200px-Openscad_minkowski_example_1a.png"></p>
    <p>一个长方体与一个圆柱体</p>
    <p><img src="img/200px-Openscad_minkowski_example_2a.png"></p>
    <p>上述长方体与圆柱体的闵可夫斯基和</p>
    <p>显示子节点的<a target="wikibook" href="https://www.cgal.org/Manual/latest/doc_html/cgal_manual/Minkowski_sum_3/Chapter_main.html">闵可夫斯基和（minkowskisum）</a>。</p>
    <p>用例:</p>
    <p>假设您有一个平整的立方体，并希望对其进行倒圆角操作。有很多方法可以达到此目的，minkowski就是一种简单易用的方法。先来制作待处理的立方体与圆柱体：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> $fn=50;</div>
        <div class="codeLine"> cube([10,10,1]);</div>
        <div class="codeLine"> cylinder(r=2,h=1);</div>
    </div>
    <p>接着，令它们执行闵可夫斯基和（请注意，立方体的外形尺寸现在为14x2，10+2+2 = 14个单位，而高的2个单位则为两者的高之和）：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">$fn=50;</div>
        <div class="codeLine">minkowski()</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> cube([10,10,1]);</div>
        <div class="codeLine"> cylinder(r=2,h=1);</div>
        <div class="codeLine">}</div>
    </div>
    <p>请注意：第二个对象的<strong>原点（origin）</strong>将用于求和运算。如果第二个对象并未对齐于原点，则闵可夫斯基和的结果将是不对称的。下列两种闵可夫斯基和是不同的：第一种会把原始的立方体在正负每个方向各展开0.5个单位。而第二种会将原始立方体在每个正方向上扩展+1，却不会在负方向上对其进行展开。
    </p>
    <div class="CodeMirror-code">
        <div class="codeLine">minkowski() {</div>
        <div class="codeLine">cube([10, 10, 1]);</div>
        <div class="codeLine">cylinder(1, center=true);</div>
        <div class="codeLine">}</div>
        <div class="codeLine">minkowski() {</div>
        <div class="codeLine">cube([10, 10, 1]);</div>
        <div class="codeLine">cylinder(1);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="hull"></a>hull</h3>
    <p><img src="img/200px-Openscad_hull_example_1a.png"></p>
    <p>两个圆柱体</p>
    <p><img src="img/200px-Openscad_hull_example_2a.png"></p>
    <p>上述两个圆柱体的凸包</p>
    <p>显示子节点的<a target="wikibook" href="https://www.cgal.org/Manual/latest/doc_html/cgal_manual/Convex_hull_2/Chapter_main.html">凸包（convex hull）</a>。</p>
    <p>用例:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">hull() {</div>
        <div class="codeLine"> &nbsp; translate([15,10,0]) circle(10);</div>
        <div class="codeLine"> &nbsp; circle(10);</div>
        <div class="codeLine">}</div>
    </div>
    <p>采用2D参数的hull函数只能计算出2D结果；在Z轴方向上平移2D组件不会产生任何效果。</p>
    <h2><a name="组合变换"></a>组合变换</h2>
    <p>在把多种变换组合在一起时，要按从右至左的次序进行处理。例如，</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> rotate( ... ) translate ( ... ) cube(5) ;</div>
    </div>
    <p>将首先平移立方体，再以平移距离为半径的弧（弧度为rotate中所指定）进行移动。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> translate ( ... ) rotate( ... ) cube(5) ;</div>
    </div>
    <p>将首先旋转立方体，再将其按平移定义的偏移量进行平移。</p>
    <p><img src="img/200px-Openscad_combined_transform.png"></p>
    <p>将两种变换组合起来</p>
    <div class="CodeMirror-code">
        <div class="codeLine">color("red") &nbsp; translate([0,10,0]) rotate([45,0,0]) &nbsp; &nbsp; cube(5);</div>
        <div class="codeLine">color("green") rotate([45,0,0]) &nbsp; &nbsp; translate([0,10,0]) cube(5);</div>
    </div>
    <hr />
    <h1><a name="openscad用户手册逻辑组合csg-建模"></a>OpenSCAD用户手册/逻辑组合/CSG 建模</h1>
    <h3><a name="目录-n3874"></a>目录</h3>
    <ul>
        <li> 1 布尔操作概述
            <ul>
                <li><a href="#2d示例">1.1 2D示例</a></li>
                <li><a href="#3d示例">1.2 3D示例</a></li>
            </ul>
        </li>
        <li><a href="#union">2 union</a></li>
        <li> 3 difference
            <ul>
                <li><a href="#减去多个子对象">3.1 减去多个子对象</a></li>
            </ul>
        </li>
        <li><a href="#intersection">4 intersection</a></li>
        <li><a href="#render">5 render</a></li>
    </ul>
    <h3><a name="布尔操作概述"></a>布尔操作概述</h3>
    <h3><a name="2d示例"></a>2D示例</h3>
    <ul>
        <li>
            <p><img src="img/120px-OpenSCAD_Boolean_Union_2D.jpg"></p>
            <p>并集 ( 或 ) 圆形 + 正方形</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/120px-OpenSCAD_Boolean_Difference_2D.jpg"></p>
            <p>差集 ( 与非 ) 正方形 - 圆形</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/120px-OpenSCAD_Boolean_Difference_1_2D.jpg"></p>
            <p>差集 ( 与非 ) 圆形 - 正方形</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/120px-OpenSCAD_Boolean_Intersection_2D.jpg"></p>
            <p>交集 ( 与 ) 圆形 - (圆形 - 正方形)</p>
        </li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine"> union() &nbsp; &nbsp; &nbsp; {square(10);circle(10);} // 正方形 或 &nbsp; 圆形</div>
        <div class="codeLine"> difference() {square(10);circle(10);} // 正方形 与非 圆形</div>
        <div class="codeLine"> difference() {circle(10);square(10);} // 圆形 &nbsp; 与非 正方形</div>
        <div class="codeLine"> intersection(){square(10);circle(10);} // 正方形 与 &nbsp; 圆形</div>
    </div>
    <h3><a name="3d示例"></a>3D示例</h3>
    <ul>
        <li>
            <p><img src="img/107px-OpenScad_Boolean_Union.jpg"></p>
            <p>并集 ( 或 ) 球体 + 立方体</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/118px-Boolean_Difference_1a.jpg"></p>
            <p>差集 ( 与非 ) 立方体 - 球体</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/120px-OpenScad_Boolean_Difference_2.jpg"></p>
            <p>差集 ( 与非 ) 球体 - 立方体</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/120px-OpenScad_Boolean_Intersection.jpg"></p>
            <p>交集 ( 与 ) 球体 - (球体 - 立方体)</p>
        </li>
    </ul>
    <div class="CodeMirror-code">
        <div class="codeLine"> union() &nbsp; &nbsp; &nbsp; {cube(12, center=true); sphere(8);} // 立方体 或 &nbsp; 球体</div>
        <div class="codeLine"> difference() {cube(12, center=true); sphere(8);} // 立方体 与非 球体</div>
        <div class="codeLine"> difference() {sphere(8); cube(12, center=true);} // 球体 &nbsp; 与非 立方体</div>
        <div class="codeLine"> intersection(){cube(12, center=true); sphere(8);} // 立方体 与 &nbsp; 球体</div>
    </div>
    <h3><a name="union"></a>union</h3>
    <p>创建所有子节点的并集。即，所有子节点之<strong>和</strong>(逻辑<strong>或</strong>). 可用于2D对象或3D对象, 但不能两者混用。</p>
    <p><img src="img/400px-Openscad_union.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> //举个栗子:</div>
        <div class="codeLine"> union() {</div>
        <div class="codeLine"> cylinder (h = 4, r=1, center = true, $fn=100);</div>
        <div class="codeLine"> rotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);</div>
        <div class="codeLine"> }</div>
    </div>
    <p>备注: union is implicit when not used. But it is mandatory, for example, in difference to group first child nodes into one.</p>
    <h3><a name="difference"></a>difference</h3>
    <p>从第一个子节点集中减去第二个（以及指定的其他）子节点集(逻辑<strong>与非</strong>). 可用于2D对象或3D对象, 但不能两者混用。</p>
    <p><img src="img/400px-Openscad_difference.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">用例:</div>
        <div class="codeLine">difference() {</div>
        <div class="codeLine">cylinder (h = 4, r=1, center = true, $fn=100);</div>
        <div class="codeLine">rotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="减去多个子对象"></a>减去多个子对象</h3>
    <p>请注意，在第二个实例中，加入了第一个子对象与第二个子对象的并集操作。</p>
    <p><img src="img/Bollean_Difference_3.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 减去多个子对象的用例：</div>
        <div class="codeLine">$fn=90;</div>
        <div class="codeLine">difference(){</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; cylinder(r=5,h=20,center=true);</div>
        <div class="codeLine"> &nbsp; rotate([00,140,-45]) color("LightBlue") cylinder(r=2,h=25,center=true);</div>
        <div class="codeLine"> &nbsp; rotate([00,40,-50]) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cylinder(r=2,h=30,center=true);</div>
        <div class="codeLine"> &nbsp; translate([0,0,-10])rotate([00,40,-50]) cylinder(r=1.4,h=30,center=true);</div>
        <div class="codeLine">}</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">// 第二个实例在第一个实例的基础上添加了一个并集操作</div>
        <div class="codeLine">translate([10,10,0]){</div>
        <div class="codeLine"> &nbsp; difference(){</div>
        <div class="codeLine"> &nbsp; &nbsp; union(){ &nbsp; &nbsp; &nbsp; // 将第一个子对象与第二个子对象组合起来</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cylinder(r=5,h=20,center=true);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; rotate([00,140,-45]) color("LightBlue") cylinder(r=2,h=25,center=true);</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; rotate([00,40,-50]) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cylinder(r=2,h=30,center=true);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([0,0,-10])rotate([00,40,-50]) &nbsp; cylinder(r=1.4,h=30,center=true);</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="intersection"></a>intersection</h3>
    <p>创建所有子节点的交集。这将保留集合间的<strong>重合</strong>部分(逻辑<strong>与</strong>). 只有<strong>所有</strong>子对象共用或共享的部分才会被保留下来。 可用于2D对象或3D对象, 但不能两者混用。</p>
    <p><img src="img/Openscad_intersection.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">//用例:</div>
        <div class="codeLine">intersection() {</div>
        <div class="codeLine">cylinder (h = 4, r=1, center = true, $fn=100);</div>
        <div class="codeLine">rotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="render"></a>render</h3>
    <p><strong>警告：</strong>使用渲染函数时，总是针对子对象树计算其CSG模型(在OpenCSG预览模式下也是如此)。这将导致预览变得极慢，并发生OpenSCAD短暂挂起并处于冻结状态。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">用例:</div>
        <div class="codeLine">render(convexity = 1) { ... }</div>
    </div>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>convexity</th>
                    <th>此参数为整数。此凸性参数用于指定：一射线贯穿物体的前后侧时，两者相交可达到的最多次数。此参数仅用于在OpenCSG预览模式下正确地显示对象，而对于多面体的渲染并无影响。</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>&nbsp;</td>
                    <td>&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p><img src="img/400px-Openscad_convexity.jpg"></p>
    <p>此图像展示的是凸性参数为4的一个2D图形，这是因为红色射线穿过该图形时与之最多相交4次。利用同样的方法亦可确定3D图形的凸性。在大多数情况下，将其设置为10就能够顺利地完成渲染工作。</p>
    <hr />
    <h1><a name="openscad用户手册条件与迭代函数"></a>OpenSCAD用户手册/条件与迭代函数</h1>
    <h3><a name="目录-n3972"></a>目录</h3>
    <ul>
        <li><a href="#for循环">1 for循环</a></li>
        <li><a href="#intersection_for循环">2 intersection_for循环</a></li>
        <li> 3 if语句
            <ul>
                <li><a href="#else_if">3.1 else if</a></li>
            </ul>
        </li>
        <li> 4 条件语句? :
            <ul>
                <li><a href="#函数递归调用">4.1 函数递归调用</a></li>
            </ul>
        </li>
        <li><a href="#assign语句">5 assign语句</a></li>
        <li><a href="#let语句">6 let语句</a></li>
    </ul>
    <h3><a name="for循环"></a>for循环</h3>
    <hr />
    <p>计算出范围或向量中的每一个值，并对其执行其后的动作（action）。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> for(variable = [start : increment : end])</div>
        <div class="codeLine"> for(variable = [start : end])</div>
        <div class="codeLine"> for(variable = [vector])</div>
    </div>
    <p><strong>参数</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> for (a =[3:5])echo(a); &nbsp; &nbsp; // 3 4 5</div>
        <div class="codeLine"> for (a =[3:0]){echo(a);} &nbsp; // 0 1 2 3 &nbsp; &nbsp; &nbsp; &nbsp; 开始循环时start &gt; end是非法的，本特性自2015.3版废止</div>
        <div class="codeLine"> for (a =[3:0.5:5])echo(a); // 3 3.5 4 4.5 5</div>
        <div class="codeLine"> for (a =[0:2:5])echo(a); &nbsp; // 0 2 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 整个循环过程中，比较值从未等于过end </div>
        <div class="codeLine"> for (a =[3:-2:-1])echo(a); // 3 1 -1 &nbsp; &nbsp; &nbsp; &nbsp; 自2015.3版起开始支持负值increment</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 确保end &gt; start</div>
        <div class="codeLine"> for (a =[3,4,1,5])echo(a); // 3 4 1 5</div>
        <div class="codeLine"> for (a =[0.3,PI,1,99]){echo(a);} &nbsp; // 0.3 3.14159 1 99</div>
        <div class="codeLine"> x1=2; x2=8; x3=5.5;</div>
        <div class="codeLine"> for (a =[x1,x2,x3]){echo(a);} // 2 8 5.5 </div>
        <div class="codeLine"> for (a =[[1,2],6,"s",[[3,4],[5,6]]])echo(a); // [1,2] 6 "s" [[3,4],[5,6]] </div>
    </div>
    <p>for()是一种运算符（算子）。如果运算符的作用域中存在多个动作，就用大括号{}将这些动作圈在其中。动作要以分号作为结尾，运算符不必如此。</p>
    <p>对于变量规则而言，for()函数也非例外，其作用域中的变量各有自己的唯一值。循环中的每次求值都有其自己的作用域，借此令任一变量都有其唯一值。所以，您依然不能使用a=a+1;语句。</p>
    <p>请牢记，OpenSCAD并非支持迭代（iterative）的语言，而在编写代码时也应意识到for()其实也并非循环：它会针对范围/向量中的每一项构建一颗对象分支树，在每一个分支中&#39;变量&#39;是一个独立的特定实例或作用域。</p>
    <p>因此:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">for (i=[0:3])</div>
        <div class="codeLine"> &nbsp; translate([i*10,0,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; cube(i+1);</div>
    </div>
    <p>将生成: <em>[参见Design/Display-CSG-Tree菜单]</em></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> group() {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; group() {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multmatrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube(size = [1, 1, 1], center = false);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multmatrix([[1, 0, 0, 10], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {
        </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube(size = [2, 2, 2], center = false);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multmatrix([[1, 0, 0, 20], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {
        </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube(size = [3, 3, 3], center = false);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multmatrix([[1, 0, 0, 30], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {
        </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube(size = [4, 4, 4], center = false);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine">}</div>
    </div>
    <p>所有的for()实例同时存在，并非按顺序迭代。</p>
    <p>多个for()语句的嵌套调用也是合情合理的：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">for(z=[-180:45:+180])</div>
        <div class="codeLine"> for(x=[10:5:50])</div>
        <div class="codeLine"> &nbsp; rotate([0,0,z]) translate([x,0,0]) cube(1);</div>
    </div>
    <p>instead, all ranges/vectors can be include in the same for() operator.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">for ( variable1 = &lt;range or vector&gt; , variable2 = &lt;range or vector&gt; ) &lt;do something using both variables&gt;
        </div>
    </div>
    <p><img src="img/380px-OpenSCAD_Manual_nested_for.jpg"></p>
    <p>深度为3的for()循环嵌套</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> 深度为3的for()嵌套示例</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> color_vec = ["black","red","blue","green","pink","purple"];</div>
        <div class="codeLine"> for (x = [-20:10:20] )</div>
        <div class="codeLine"> for (y = [0:4] )color(color_vec[y])</div>
        <div class="codeLine"> for (z = [0,4,10] )</div>
        <div class="codeLine"> &nbsp; &nbsp; {translate([x,y*5-10,z])cube();}</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> 上述for()嵌套的等效简化写法</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> color_vec = ["black","red","blue","green","pink","purple"];</div>
        <div class="codeLine"> for (x = [-20:10:20],</div>
        <div class="codeLine"> y = [0:4],</div>
        <div class="codeLine"> z = [0,4,10] )</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([x,y*5-10,z]){color(color_vec[y])cube();}</div>
    </div>
    <p><img src="img/220px-OpenSCAD_For_Rotation.png"></p>
    <p>示例1：对元素为向量的向量执行for()循环(旋转操作)</p>
    <div class="CodeMirror-code">
        <div class="codeLine">示例1 - 对元素为向量的向量进行迭代(旋转操作)</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> for(i = [ [ 0, 0, &nbsp; 0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 10, 20, 300],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [200, 40, 57],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 20, 88, 57] ])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; rotate(i)</div>
        <div class="codeLine"> &nbsp; cube([100, 20, 20], center = true);</div>
        <div class="codeLine">}</div>
    </div>
    <p><img src="img/220px-OpenSCAD_For_Translation.png"></p>
    <p>示例2：对元素为向量的向量执行for()循环(平移操作)</p>
    <div class="CodeMirror-code">
        <div class="codeLine">示例2 - 对元素为向量的向量进行迭代(平移操作)</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">for(i = [ [ 0, 0, 0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [10, 12, 10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [20, 24, 20],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [30, 36, 30],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [20, 48, 40],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [10, 60, 50] ])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; translate(i)</div>
        <div class="codeLine"> &nbsp; cube([50, 15, 10], center = true);</div>
        <div class="codeLine">}</div>
    </div>
    <p><img src="img/220px-OpenSCAD_Vector_of_vectors_example_3.jpg"></p>
    <p>示例3：对元素为向量的向量执行for()循环</p>
    <div class="CodeMirror-code">
        <div class="codeLine">示例3 - 对元素为向量的向量进行迭代</div>
        <div class="codeLine">for(i = [ [[ 0, 0, 0], 20],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [[10, 12, 10], 50],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [[20, 24, 20], 70],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [[30, 36, 30], 10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [[20, 48, 40], 30],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; [[10, 60, 50], 40] ])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> translate([i[0][0], 2*i[0][1], 0])</div>
        <div class="codeLine"> cube([10, 15, i[1]]);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="intersectionfor循环"></a>intersection_for循环</h3>
    <hr />
    <p>Iterate over the values in a range or vector and create the <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/The_OpenSCAD_Language&amp;action=edit&amp;redlink=1">intersection</a> ofobjects created by each pass.</p>
    <p>Besides creating separate instances for each pass, the standard <strong>for()</strong> also groups all these instances creating an implicit union.
        <strong>intersection_for()</strong> is a work around because the implicit union prevents getting the expected results using a combination of thestandard <strong>for()</strong> and
        <strong>intersection()</strong> statements.</p>
    <p><strong>intersection_for()</strong> uses the same parameters, and works the same as a <a href="#for_loop">For Loop</a>, other than eliminating theimplicit union.</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>示例1 - loop over a range:</strong></th>
                    <th>&nbsp;</th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>intersection_for(n = [1 : 6]) { rotate([0, 0, n * 60]) { translate([5,0,0]) sphere(r=12); } }</code></td>
                    <td><img src="img/220px-OpenSCAD_Intersection_For_Range.png">intersection_for()</td>
                    <td><img src="img/220px-OpenSCAD_Intersection%28%29for%28%29_example1.jpg">either intersection() for() or for() intersection()</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>示例2 - rotation</strong> :</th>
                    <th>&nbsp;</th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>intersection_for(i = [ [ 0, 0, 0], [ 10, 20, 300], [200, 40, 57], [ 20, 88, 57] ]) { rotate(i) cube([100, 20, 20], center =true); }</code></td>
                    <td><img src="img/220px-OpenSCAD_Intersection_For_Rotation.png">intersection_for()</td>
                    <td><img src="img/220px-OpenSCAD_Intersection%28%29for%28%29_example_2.jpg">intersection() for()</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>In</p>
    <h3><a name="if语句"></a>if语句</h3>
    <hr />
    <p>执行一个测试，用于确定其子域中的动作是否该执行。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">if (test) scope1</div>
        <div class="codeLine">if (test){scope1}</div>
        <div class="codeLine">if (test) scope1 else scope2</div>
        <div class="codeLine">if (test){scope1} else {scope2}</div>
        <div class="codeLine">if (b==a) cube(4);</div>
        <div class="codeLine">if (b&lt;a) {cube(4); cylinder(6);}</div>
        <div class="codeLine">if (b&amp;&amp;a) {cube(4); cylinder(6);}</div>
        <div class="codeLine">if (b!=a) cube(4); else cylinder(3);</div>
        <div class="codeLine">if (b) &nbsp; {cube(4); cylinder(6);} else {cylinder(10,5,5);} </div>
        <div class="codeLine">if (!true){cube(4); cylinder(6);} else cylinder(10,5,5); </div>
        <div class="codeLine">if (x&gt;y) &nbsp; cube(1, center=false); else {cube(size = 2, center = true);}</div>
        <div class="codeLine">if (a==4) {} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else echo("a is not 4");</div>
        <div class="codeLine">if ((b&lt;5)&amp;&amp;(a&gt;8)) {cube(4); &nbsp; &nbsp; else cylinder(3);}</div>
        <div class="codeLine">if (b&lt;5&amp;&amp;a&gt;8) &nbsp; &nbsp; &nbsp; cube(4); &nbsp; &nbsp; else cylinder(3);</div>
    </div>
    <p>Since 2015.03 variables can now be assigned in any scope. Note that assignments are only valid within the scope in which they are defined - you arestill not allowed to leak values to an outer scope. See <a href="#scope_of_variables">Scope of variables</a> for more details.</p>
    <p>The scopes of both the <strong>if()</strong> portion and the <strong>else</strong> portion, can in turn contain <strong>if()</strong> statements.This nesting can be to many depths.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> if (test1) </div>
        <div class="codeLine"> {</div>
        <div class="codeLine"> &nbsp; scope1 if (test2) {scope2.1}</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; else {scope2.2}</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> else</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> scope2 if (test3) {scope3.1}</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; else {scope3.2}</div>
        <div class="codeLine">}</div>
    </div>
    <p>When scope1 and scope2 contain <strong>only</strong> the if() statement, the outer sets of braces can be removed.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> if (test1)</div>
        <div class="codeLine"> &nbsp; if (test2) {scope2.1}</div>
        <div class="codeLine"> &nbsp; else {scope2.2}</div>
        <div class="codeLine"> else</div>
        <div class="codeLine"> &nbsp; if (test3) {scope3.1}</div>
        <div class="codeLine"> &nbsp; else {scope3.2}</div>
    </div>
    <p>One evolution is this:</p>
    <h3><a name="else-if"></a>else if</h3>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; if(test1) {scope1}</div>
        <div class="codeLine"> else if(test2) {scope2}</div>
        <div class="codeLine"> else if(test3) {scope3}</div>
        <div class="codeLine"> else if(test4) {scope4}</div>
        <div class="codeLine"> else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {scope5}</div>
    </div>
    <p>Note that else and if are two separate words. When working down the chain of tests, the first true will use its scope. All further tests will beskipped.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">示例</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">if((k&lt;8)&amp;&amp;(m&gt;1)) cube(10);</div>
        <div class="codeLine">else if(y==6) &nbsp; {sphere(6);cube(10);}</div>
        <div class="codeLine">else if(y==7) &nbsp; color("blue")sphere(5);</div>
        <div class="codeLine">else if(k+m!=8) {cylinder(15,5,0);sphere(8);}</div>
        <div class="codeLine">else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color("green"){cylinder(12,5,0);sphere(8);}</div>
    </div>
    <h3><a name="条件语句-"></a>条件语句? :</h3>
    <hr />
    <p>A function which uses a test to determine which of 2 values to return.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> a = &nbsp; test ? TrueValue : FalseValue ;</div>
        <div class="codeLine"> echo( test ? TrueValue : FalseValue );</div>
    </div>
    <p>This works like the <code>?:</code> operator from the family of C-like programming languages.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> a=1; b=2; c= a==b ? 4 : 5 ; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 5</div>
        <div class="codeLine"> a=1; b=2; c= a==b ? "a==b" : "a!=b" ; &nbsp; &nbsp; &nbsp; // "a!=b"</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> TrueValue = true; FalseValue = false;</div>
        <div class="codeLine"> a=5; test = a==1;</div>
        <div class="codeLine"> echo( test ? TrueValue : FalseValue ); &nbsp; &nbsp; &nbsp; // false</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine"> L = 75; R = 2; test = (L/R)&gt;25;</div>
        <div class="codeLine"> TrueValue = [test,L,R,L/R,cos(30)];</div>
        <div class="codeLine"> FalseValue = [test,L,R,sin(15)];</div>
        <div class="codeLine"> a1 = test ? TrueValue : FalseValue ; &nbsp; &nbsp; &nbsp; &nbsp; // [true, 75, 2, 37.5, 0.866025]</div>
    </div>
    <h3><a name="函数递归调用"></a>函数递归调用</h3>
    <p>Recursive function calls are supported. Using the Conditional &quot;... ? ... : ... &quot; it&#39;s possible to ensure the recursion is terminated.Note: There is a built-in recursion limit to prevent an application crash. If the limit is hit, the function returns undef.</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> // recursion - find the sum of the values in a vector (array) by calling itself</div>
        <div class="codeLine"> // from the start (or s'th element) to the i'th element - remember elements are zero based</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> function sumv(v,i,s=0) = (i==s ? v[i] : v[i] + sumv(v,i-1,s));</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> vec=[ 10, 20, 30, 40 ];</div>
        <div class="codeLine"> echo("sum vec=", sumv(vec,2,1)); // calculates 20+30=50</div>
    </div>
    <p>Some forms of tail-recursion elimination are supported.</p>
    <h3><a name="assign语句"></a>assign语句</h3>
    <hr />
    <p>[<strong>*废止:</strong> <strong>assign()</strong> 将从未来发行版中去掉。 现在可在任意作用域对变量进行赋值。如果您更喜欢以这种方式来设置值，可以用新的<a href="#let_statement">Let语句</a>来替代它。*]</p>
    <p>针对一颗子树对变量设置的新值。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">for (i = [10:50])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; assign (angle = i*360/20, distance = i*10, r = i*2)</div>
        <div class="codeLine"> &nbsp; {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; rotate(angle, [1, 0, 0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0, distance, 0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; sphere(r = r);</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
        <div class="codeLine">for (i = [10:50])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; angle = i*360/20;</div>
        <div class="codeLine"> &nbsp; distance = i*10;</div>
        <div class="codeLine"> &nbsp; r = i*2;</div>
        <div class="codeLine"> &nbsp; rotate(angle, [1, 0, 0])</div>
        <div class="codeLine"> &nbsp; translate([0, distance, 0])</div>
        <div class="codeLine"> &nbsp; sphere(r = r);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="let语句"></a>let语句</h3>
    <hr />
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>针对一颗子树为变量设置新值。 The parameters are evaluated sequentially and may depend on each other (as opposed to the deprecated assign() statement).</p>
    <div class="CodeMirror-code">
        <div class="codeLine">for (i = [10:50])</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; let (angle = i*360/20, r= i*2, distance = r*5)</div>
        <div class="codeLine"> &nbsp; {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; rotate(angle, [1, 0, 0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0, distance, 0])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; sphere(r = r);</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
    </div>
    <hr />
    <h1><a name="openscad用户手册数学运算符"></a>OpenSCAD用户手册/数学运算符</h1>
    <h3><a name="标量算术运算符"></a>标量算术运算符</h3>
    <p>标量算术运算符以数值为操作数，并计算出一个新的数值。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>+</th>
                    <th>加法</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>-</td>
                    <td>减法</td>
                </tr>
                <tr>
                    <td>*</td>
                    <td>乘法</td>
                </tr>
                <tr>
                    <td>/</td>
                    <td>除法</td>
                </tr>
                <tr>
                    <td>%</td>
                    <td>取模</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>&quot;-&quot;也可以充当前缀操作符，表示对目标数值取反。</p>
    <h3><a name="关系运算符"></a>关系运算符</h3>
    <p>关系运算符根据参与计算的两个操作数得到一个布尔值。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>&lt;</th>
                    <th>小于</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>&lt;=</td>
                    <td>小于等于</td>
                </tr>
                <tr>
                    <td>==</td>
                    <td>相等</td>
                </tr>
                <tr>
                    <td>!=</td>
                    <td>不相等</td>
                </tr>
                <tr>
                    <td>&gt;=</td>
                    <td>大于等于</td>
                </tr>
                <tr>
                    <td>&gt;</td>
                    <td>大于</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>如果操作数皆为简单的数值，那么其意义是不言自明的。</p>
    <p>如果操作数皆为字符串，则根据字母顺序来确定相等或次序。例如，&quot;ab&quot; &gt; &quot;aa&quot; &gt; &quot;a&quot;。</p>
    <p>如果操作数皆为布尔值，<em>true</em> &gt;
        <em>false</em>。在一个布尔值与一个数值进行比较时，将<em>true</em>视作1，并将<em>false</em>视作0。对于其他类型与布尔值进行不等式测试时，返回false。</p>
    <p>如果操作数皆为向量，则二者相同时返回<em>true</em>，否则返回<em>false</em>。当不等式测试的操作数中有一个或两个向量时，总是返回<em>false</em>因此，如[1] &lt; [2]亦返回<em>false</em>。</p>
    <p>用&#39;==&#39; 与 &#39;!=&#39;来测试不同的类型，则总是返回不相等。 不同类型之间进行不等式比较时，除了上述布尔值与数值以外，将总是得到<em>false</em>。 请注意，[1]与1是两种截然不同的类型，因此[1] == 1为false。</p>
    <p>除了<em>undef</em>以外，<em>undef</em>不等于其他任意值。含有<em>undef</em>的不等式比较将总是得到<em>false</em>。</p>
    <p><em>nan</em>不等于其他任意值（甚至不等于其自身），且不等式测试恒为<em>false</em>。请参见<a href="#数">数</a>.</p>
    <h3><a name="逻辑运算符"></a>逻辑运算符</h3>
    <p>所有的逻辑运算符取布尔值作为操作数并计算出一个布尔值。非布尔类型的量值在由逻辑运算符计算前先被转换为布尔值。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>&amp;&amp;</th>
                    <th>逻辑与</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>||</td>
                    <td>逻辑或</td>
                </tr>
                <tr>
                    <td>!</td>
                    <td>一元逻辑非</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>由于<code>[false]</code>为<code>true</code>, 因此<code>false || [false]</code>的结果亦为<code>true</code>.</p>
    <p>请注意，逻辑运算符与关系运算符处理向量的区别：</p>
    <p><code>[1, 1] &gt; [0, 2]</code> 为 <code>false</code>, 但是</p>
    <p><code>[false, false] &amp;&amp; [false, false]</code> 为 <code>true</code>.</p>
    <h3><a name="条件运算符"></a>条件运算符</h3>
    <p><code>?:</code>运算符可用于根据条件对两个表达式之一进行求值。它的工作方式脱胎于类C编程语言系。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>? :</th>
                    <th>条件运算符</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>&nbsp;</td>
                    <td>&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例：</strong></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>a=1; b=2; c= a==b ? 4 : 5;</code>如果a等于b, 便将c设置为4, 否则将c设置为5。 &quot;a==b&quot;部分必须要计算出一个布尔值。</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="向量数运算符"></a>向量数运算符</h3>
    <p>向量数（vector-number）运算符取一个向量与一个数来计算出一个新向量。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>*</th>
                    <th>令所有的向量元素与该数进行乘法运算</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>/</td>
                    <td>令所有的向量元素与该数进行除法运算</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <div class="CodeMirror-code">
        <div class="codeLine">L = [1, [2, [3, "a"] ] ];</div>
        <div class="codeLine">echo(5*L);</div>
        <div class="codeLine">// ECHO: [5, [10, [15, undef]]]</div>
    </div>
    <h3><a name="向量运算符"></a>向量运算符</h3>
    <p>向量运算符取两个向量作为操作数来计算出一个新向量。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>+</th>
                    <th>两个向量中对应元素相加</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>-</td>
                    <td>两个向量中对应元素相减</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p>&quot;-&quot;也可用作前置运算符，令向量中的每个元素逐一取反。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">L1 = [1, [2, [3, "a"] ] ];</div>
        <div class="codeLine">L2 = [1, [2, 3] ];</div>
        <div class="codeLine">echo(L1+L1); // ECHO: [2, [4, [6, undef]]]</div>
        <div class="codeLine">echo(L1+L2); // ECHO: [2, [4, undef]]</div>
    </div>
    <h3><a name="向量点积运算符"></a>向量点积运算符</h3>
    <p>如果参与乘法运算的两个操作数都为简单向量，则根据<a target="wikibook" href="https://zh.wikipedia.org/wiki/Dot_product">点积</a>的线性代数规则，计算结果为一个数。 <code>c =u*v;</code>的计算过程为{\displaystyle c=\sum u<em>{i}v</em>{i}}<imgsrc="img/62719e8c892aa5cc4d9357848a218d3c4b73654c">。如果操作数的大小不匹配，则计算结果为<code>undef</code>。</p>
    <h3><a name="矩阵乘法"></a>矩阵乘法</h3>
    <p>如果参与乘法运算的两个操作数中存在矩阵，则根据<a href="#matrix_product_.28two_matrices.29">矩阵乘积</a>的线性代数规则，计算结果为一个简单向量或一个矩阵。在接下来的讨论中，我们设 A, B, C...为矩阵，u, v, w...为向量。下标i,j表示元素的索引。</p>
    <p>对于规模为n × m的矩阵A与规模为m × p的矩阵B而言，二者之积<code>C = A*B;</code>为一个n × p矩阵，其中的元素依次为 {\displaystyle C<em>{ij}=\sum_{k=0}^{m-1}A</em>{ik}B<em>{kj}}![{\displaystyle C</em>{ij}=\sum
        <em>{k=0}^{m-1}A</em>{ik}B_{kj}}](<a target="wikibook"href="https://wikimedia.org/api/rest_v1/media/math/render/svg/0cdb6e01b98696f33cdd13519f49a5d31a0eb5bc" target="_blank"class="url">https://wikimedia.org/api/rest_v1/media/math/render/svg/0cdb6e01b98696f33cdd13519f49a5d31a0eb5bc</a>)。</p>
    <p>而<code>C = B*A;</code>的结果为<code>undef</code>，除非n = p。</p>
    <p>对于规模为n × m的矩阵A与规模为m的向量v而言，二者之积<code>u = A*v;</code>为一个规模为n的向量，其中的元素依次为 {\displaystyle u<em>{i}=\sum _{k=0}^{m-1}A</em>{ik}v<em>{k}}![{\displaystyleu</em>{i}=\sum
        <em>{k=0}^{m-1}A</em>{ik}v_{k}}](<a target="wikibook"href="https://wikimedia.org/api/rest_v1/media/math/render/svg/a25ee6408c0dbf26d2ecce9c86c3214fa22e6aba" target="_blank"class="url">https://wikimedia.org/api/rest_v1/media/math/render/svg/a25ee6408c0dbf26d2ecce9c86c3214fa22e6aba</a>)。</p>
    <p>在线性代数中，此为<a href="#square_matrix_and_column_vector">矩阵与列向量的乘积</a>.</p>
    <p>对于规模为n的向量v与规模为n × m的矩阵A而言，二者之积<code>u = v*A;</code>为一个规模为m的向量，其中的元素以此为</p>
    <p>{\displaystyle u<em>{j}=\sum _{k=0}^{n-1}v</em>{k}A<em>{kj}}![{\displaystyle u</em>{j}=\sum
        <em>{k=0}^{n-1}v</em>{k}A_{kj}}](<a target="wikibook"href="https://wikimedia.org/api/rest_v1/media/math/render/svg/7f46be5cabd3bdfc2ef5047ff3d0542bde66442c" target="_blank"class="url">https://wikimedia.org/api/rest_v1/media/math/render/svg/7f46be5cabd3bdfc2ef5047ff3d0542bde66442c</a>).</p>
    <p>在线性代数中，此为行向量与矩阵的乘积。</p>
    <p>矩阵的乘法运算并不满足交换律，即：{\displaystyle AB\neq BA}<img src="img/38f1a5c060698eefdb6af8dd172fd3fe7124189c">, {\displaystyle Av\neq vA}<imgsrc="img/43b5db3b81699facd7bdf07afd0e85312fc763ee">。</p>
    <hr />
    <h1><a name="openscad用户手册数学函数"></a>OpenSCAD用户手册/数学函数</h1>
    <p>目录</p>
    <ul>
        <li><a href="#三角函数">1.三角函数</a></li>
        <li><a href="#cos">1.1 cos</a></li>
        <li><a href="#sin">1.2 sin</a></li>
        <li><a href="#tan">1.3 tan</a></li>
        <li><a href="#acos">1.4 acos</a></li>
        <li><a href="#asin">1.5 asin</a></li>
        <li><a href="#atan">1.6 atan</a></li>
        <li><a href="#atan2">1.7 atan2</a></li>
        <li><a href="#其他数学函数">2.其他数学函数</a></li>
        <li><a href="#abs">2.1 abs</a></li>
        <li><a href="#ceil">2.2 ceil</a></li>
        <li><a href="#concat">2.3 concat</a></li>
        <li><a href="#cross">2.4 cross</a></li>
        <li><a href="#exp">2.5 exp</a></li>
        <li><a href="#floor">2.6 floor</a></li>
        <li><a href="#ln">2.7 ln</a></li>
        <li><a href="#len">2.8 len</a></li>
        <li><a href="#let">2.9 let</a></li>
        <li><a href="#log">2.10 log</a></li>
        <li><a href="#lookup">2.11 lookup</a></li>
        <li><a href="#max">2.12 max</a></li>
        <li><a href="#min">2.13 min</a></li>
        <li><a href="#norm">2.14 norm</a></li>
        <li><a href="#pow">2.15 pow</a></li>
        <li><a href="#rands">2.16 rands</a></li>
        <li><a href="#round">2.17 round</a></li>
        <li><a href="#sign">2.18 sign</a></li>
        <li><a href="#sqrt">2.19 sqrt</a></li>
        <li><a href="#infinities_and_nans">3.Infinities and NaNs</a></li>
    </ul>
    <h2><a name="三角函数"></a>三角函数</h2>
    <p>三角函数使用的是C语言的数学函数，基于二进制浮点运算，即在计算过程中采用的是实数的近似值。OpenSCAD的数学函数使用的是Value.h/Value.cc&#39;s文件中的C++ &#39;double&#39;类型。</p>
    <p>如果对C语言库中的数学函数规范（例如有效的输入/输出范围）感兴趣，可以查阅Open Group网站<a target="wikibook"href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html">math.h</a> &amp; <a target="wikibook"href="http://pubs.opengroup.org/onlinepubs/009695399/functions/acos.html">acos</a></p>
    <h3><a name="cos"></a>cos</h3>
    <p>数学中的<strong>余弦</strong>函数，以角度为单位。参见 <a href="#sine.2c_cosine_and_tangent">余弦</a></p>
    <p><strong>参数</strong></p>
    <ul>
        <li>
            <p>
                <degrees>
            </p>
            <p>十进制数。以角度为单位表示的旋转角。</p>
        </li>
    </ul>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例：</strong></th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>for(i=[0:36]) translate([i*10,0,0]) cylinder(r=5,h=cos(i*10)*50+60);</code></td>
                    <td><img src="img/220px-OpenSCAD_Cos_Function.png">OpenSCAD余弦函数示例‎</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="sin"></a>sin</h3>
    <p>数学中的<strong>正弦</strong>函数。参见 <a href="#sine.2c_cosine_and_tangent">正弦</a></p>
    <p><strong>参数</strong></p>
    <ul>
        <li>
            <p>
                <degrees>
            </p>
            <p>十进制数。以角度为单位表示的旋转角。</p>
        </li>
    </ul>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例1：</strong></th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>for (i = [0:5]) { echo(360*i/6, sin(360*i/6)*80, cos(360*i/6)*80); translate([sin(360*i/6)*80, cos(360*i/6)*80, 0 ])cylinder(h = 200, r=10); }</code></td>
                    <td>&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例2：</strong></th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>for(i=[0:36]) translate([i*10,0,0]) cylinder(r=5,h=sin(i*10)*50+60);</code></td>
                    <td><img src="img/220px-OpenSCAD_Sin_Function.png">OpenSCAD正弦函数示例</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="tan"></a>tan</h3>
    <p>数学中的<strong>正切</strong>函数。参见<a href="#sine.2c_cosine_and_tangent">正切</a></p>
    <p><strong>参数</strong></p>
    <ul>
        <li>
            <p>
                <degrees>
            </p>
            <p>十进制数。以角度为单位表示的旋转角。</p>
        </li>
    </ul>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例：</strong></th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>for (i = [0:5]) { echo(360*i/6, tan(360*i/6)*80); translate([tan(360*i/6)*80, 0, 0 ]) cylinder(h = 200, r=10); }</code></td>
                    <td>&nbsp;</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="acos"></a>acos</h3>
    <p>数学中的<strong>反余弦</strong>函数，以角度为单位。参见： <a target="wikibook" href="https://zh.wikipedia.org/wiki/Inverse_trigonometric_functions">反三角函数</a></p>
    <h3><a name="asin"></a>asin</h3>
    <p>数学中的<strong>反正弦</strong>函数，以角度为单位。参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Inverse_trigonometric_functions">反三角函数</a></p>
    <h3><a name="atan"></a>atan</h3>
    <p>数学中的<strong>反正切</strong>函数。返回x反正切函数的主值，以角度为单位。参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Inverse_trigonometric_functions">反三角函数</a>
    </p>
    <h3><a name="atan2"></a>atan2</h3>
    <p>数学中的<strong>two-argument atan</strong>函数，取y作为其第一个参数。返回y/x反正切函数的主值，以角度为单位。参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Atan2">atan2</a>
    </p>
    <h2><a name="其他数学函数"></a>其他数学函数</h2>
    <h3><a name="abs"></a>abs</h3>
    <p>数学中的<strong>求绝对值</strong>函数。返回带符号十进制数的正值。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">abs(-5.0);</div>
        <div class="codeLine">abs(0);</div>
        <div class="codeLine">abs(8.0);</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">5.0</div>
        <div class="codeLine">0.0</div>
        <div class="codeLine">8.0</div>
    </div>
    <h3><a name="ceil"></a>ceil</h3>
    <p>数学中的&#39;<em>向上取整</em>函数。</p>
    <p>若目标数为小数，则返回大于它的最小整数；否则返回其自身。</p>
    <p>See: <a target="wikibook" href="https://zh.wikipedia.org/wiki/Ceil_function">向上取整函数</a></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(ceil(4.4),ceil(-4.4)); &nbsp; &nbsp; // 生成结果ECHO: 5, -4</div>
    </div>
    <h3><a name="concat-n4348"></a>concat</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>返回由参数所构成的向量。</p>
    <p>若参数是一个向量，则将其中元素依次取出构成返回的结果向量。此函数处理字符的方式与向量不同。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(concat("a","b","c","d","e","f")); &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: ["a", "b", "c", "d", "e", "f"]</div>
        <div class="codeLine">echo(concat(["a","b","c"],["d","e","f"])); &nbsp; &nbsp; // 生成结果ECHO: ["a", "b", "c", "d", "e", "f"]</div>
        <div class="codeLine">echo(concat(1,2,3,4,5,6)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: [1, 2, 3, 4, 5,6]</div>
    </div>
    <p>处理以向量为元素的向量</p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(concat([ [1],[2] ], [ [3] ])); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: [[1], [2], [3]]</div>
    </div>
    <p>将向量与字符串的处理结果进行对比</p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(concat([1,2,3],[4,5,6])); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: [1, 2, 3, 4, 5, 6]
        </div>
        <div class="codeLine">echo(concat("abc","def")); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: ["abc","def"]</div>
        <div class="codeLine">echo(str("abc","def")); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO:"abcdef"</div>
    </div>
    <h3><a name="cross"></a>cross</h3>
    <p>计算两个3D向量的叉积。结果是一个正交于两个输入向量的向量。</p>
    <p>输入无效参数(例如，长度不为3的向量或其他类型)将产生一个无定义的结果。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(cross([2, 3, 4], [5, 6, 7])); &nbsp; &nbsp; // 生成结果ECHO: [-3, 6, -3]</div>
        <div class="codeLine">echo(cross([2, 1, -3], [0, 4, 5])); &nbsp; // 生成结果ECHO: [17, -10, 8]</div>
        <div class="codeLine">echo(cross([2, 3, 4], "5")); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 生成结果ECHO: undef</div>
    </div>
    <h3><a name="exp"></a>exp</h3>
    <p>数学中的<strong>exp</strong>函数。返回以e为底，参数x为幂的结果。参考：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Exponent">Exponent</a></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(exp(1),exp(ln(3)*4)); &nbsp; // 生成结果ECHO: 2.71828, 81</div>
    </div>
    <h3><a name="floor"></a>floor</h3>
    <p>数学中的<strong>floor</strong>函数。floor(x)返回的是不大于参数x的最大整数。</p>
    <p>参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Floor_function">Floor Function</a></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(floor(4.4),floor(-4.4)); &nbsp; // 生成结果ECHO: 4, -5</div>
    </div>
    <h3><a name="ln"></a>ln</h3>
    <p>数学中的<strong>自然对数</strong>。参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Natural_logarithm">Natural logarithm</a></p>
    <h3><a name="len-n4372"></a>len</h3>
    <p>数学中的<strong>length</strong>函数。返回数组、向量或字符串参数的长度。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">str1="abcdef"; len_str1=len(str1);</div>
        <div class="codeLine">echo(str1,len_str1);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">a=6; len_a=len(a);</div>
        <div class="codeLine">echo(a,len_a);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">array1=[1,2,3,4,5,6,7,8]; len_array1=len(array1);</div>
        <div class="codeLine">echo(array1,len_array1);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">array2=[[0,0],[0,1],[1,0],[1,1]]; len_array2=len(array2);</div>
        <div class="codeLine">echo(array2,len_array2);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">len_array2_2=len(array2[2]);</div>
        <div class="codeLine">echo(array2[2],len_array2_2);</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">ECHO: "abcdef", 6</div>
        <div class="codeLine">ECHO: 6, undef</div>
        <div class="codeLine">ECHO: [1, 2, 3, 4, 5, 6, 7, 8], 8</div>
        <div class="codeLine">ECHO: [[0, 0], [0, 1], [1, 0], [1, 1]], 4</div>
        <div class="codeLine">ECHO: [1, 0], 2</div>
    </div>
    <p>此函数可用于对数组、向量或字符串进行解析。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">str2="4711";</div>
        <div class="codeLine">for (i=[0:len(str2)-1])</div>
        <div class="codeLine">echo(str("digit ",i+1," : ",str2[i]));</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">ECHO: "digit 1 : 4"</div>
        <div class="codeLine">ECHO: "digit 2 : 7"</div>
        <div class="codeLine">ECHO: "digit 3 : 1"</div>
        <div class="codeLine">ECHO: "digit 4 : 1"</div>
    </div>
    <p>请注意，对于len()函数而言，为之传入一个简单的变量作为参数是无定义的。</p>
    <p>用此函数来为模块处理参数也是极好的，例如能用一个数或形如[x,y,z]的向量来定义一个图形，即cube(5)或cube([5,5,5])。</p>
    <p>例如</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module doIt(size) {</div>
        <div class="codeLine">if (len(size) == undef) {</div>
        <div class="codeLine">// 若size为一个数，就把它作为x、y、z(原本undef)</div>
        <div class="codeLine">do([size,size,size]);</div>
        <div class="codeLine">} else { </div>
        <div class="codeLine">// 若size是一个向量(也可能是一个字符串，但是这也太蠢了)</div>
        <div class="codeLine">do(size);</div>
        <div class="codeLine">}</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> </div>
        <div class="codeLine">doIt(5);// 等价于[5,5,5]</div>
        <div class="codeLine">doIt([5,5,5]);// similar to cube(5) v's cube([5,5,5])</div>
    </div>
    <h3><a name="let"></a>let</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>为表达式中的一系列变量进行赋值。let函数后的表达式可以用赋值后的变量进行计算。此函数的主要功能在于：通过将多个中间结果赋予对应变量，令复杂的表达式更具可读性。</p>
    <p><strong>参数</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">let (var1 = value1, var2 = f(var1), var3 = g(var1, var2)) 表达式</div>
    </div>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(let(a = 135, s = sin(a), c = cos(a)) [ s, c ]); // ECHO: [0.707107, -0.707107]</div>
    </div>
    <h3><a name="log"></a>log</h3>
    <p>数学中以10位底的<strong>对数</strong>。例如：log(1000) = 3。参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Logarithm">Logarithm</a></p>
    <h3><a name="lookup"></a>lookup</h3>
    <p>查找表中的值，如果没有完全匹配的值，则进行线性插值。第一个参数为待查值。第二个参数为待查表——由键-值对构成的向量。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> key - 待查键</li>
        <li> &lt;key,value&gt; 数组 - 键值对集合</li>
    </ul>
    <p><strong>请注意</strong> 此函数存在一个bug，若查找的键不在待查范围之中，将返回键值对列表中的第一个值。在Openscad的较新版本中，应当采用最近的表值加以取代。</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th><strong>用例：</strong>此例将创建一张由不同高度的圆柱体构成的3D图表。</th>
                    <th>&nbsp;</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>function get_cylinder_h(p) = lookup(p, [ [ -200, 5 ], [ -50, 20 ], [ -20, 18 ], [ +80, 25 ], [ +150, 2 ] ]); for (i =[-100:5:+100]) { // echo(i, get_cylinder_h(i)); translate([ i, 0, -30 ]) cylinder(r1 = 6, r2 = 2, h = get_cylinder_h(i)*3);}</code></td>
                    <td><img src="img/220px-OpenSCAD_Lookup_Function.png">OpenSCAD查找函数示例</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="max"></a>max</h3>
    <p>返回参数中的最大值。若参数指定的是一个向量，则返回数组中的最大元素。</p>
    <p><strong>参数</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">max(n,n{,n}...)</div>
        <div class="codeLine">max(vector)</div>
    </div>
    <ul>
        <li>
            <p>
                <n>
            </p>
            <p>两个或两个以上十进制数</p>
        </li>
        <li>
            <p>
                <vector>
            </p>
            <p>一个由十进制元素构成的向量 <strong>[请注意: *需要使用版本 *<em>2014.06*</em>*]</strong></p>
        </li>
    </ul>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">max(3.0,5.0)</div>
        <div class="codeLine">max(8.0,3.0,4.0,5.0)</div>
        <div class="codeLine">max([8,3,4,5])</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">5</div>
        <div class="codeLine">8</div>
        <div class="codeLine">8</div>
    </div>
    <h3><a name="min"></a>min</h3>
    <p>返回参数中的最小值。若参数指定的是一个向量，则返回向量中的最小元素。</p>
    <p><strong>参数</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">min(n,n{,n}...)</div>
        <div class="codeLine">min(vector)</div>
    </div>
    <ul>
        <li>
            <p>
                <n>
            </p>
            <p>两个或两个以上十进制数</p>
        </li>
        <li>
            <p>
                <vector>
            </p>
            <p>一个由十进制元素构成的向量 <strong>[请注意: *需要使用版本 *<em>2014.06*</em>*]</strong>.</p>
        </li>
    </ul>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">min(3.0,5.0)</div>
        <div class="codeLine">min(8.0,3.0,4.0,5.0)</div>
        <div class="codeLine">min([8,3,4,5])</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">3</div>
        <div class="codeLine">3</div>
        <div class="codeLine">3</div>
    </div>
    <p>Looking for <strong>mod</strong> - 它并不是一个函数，参见 <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators&amp;action=edit&amp;redlink=1">modulo operator(%)</a></p>
    <h3><a name="norm"></a>norm</h3>
    <p>返回向量的[[w:Norm_(mathematics)|欧几里得范数]。请注意， 当用<strong>len</strong>返回向量或数组中元素的数量时，返回的是实有数的个数。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">a=[1,2,3,4];</div>
        <div class="codeLine">b="abcd";</div>
        <div class="codeLine">c=[];</div>
        <div class="codeLine">d="";</div>
        <div class="codeLine">e=[[1,2,3,4],[1,2,3],[1,2],[1]];</div>
        <div class="codeLine">echo(norm(a)); //5.47723</div>
        <div class="codeLine">echo(norm(b)); //undef</div>
        <div class="codeLine">echo(norm(c)); //0</div>
        <div class="codeLine">echo(norm(d)); //undef</div>
        <div class="codeLine">echo(norm(e[0])); //5.47723</div>
        <div class="codeLine">echo(norm(e[1])); //3.74166</div>
        <div class="codeLine">echo(norm(e[2])); //2.23607</div>
        <div class="codeLine">echo(norm(e[3])); //1</div>
    </div>
    <p><strong>结果</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">ECHO: 5.47723</div>
        <div class="codeLine">ECHO: undef</div>
        <div class="codeLine">ECHO: 0</div>
        <div class="codeLine">ECHO: undef</div>
        <div class="codeLine">ECHO: 5.47723</div>
        <div class="codeLine">ECHO: 3.74166</div>
        <div class="codeLine">ECHO: 2.23607</div>
        <div class="codeLine">ECHO: 1</div>
    </div>
    <h3><a name="pow"></a>pow</h3>
    <p>数学中的<strong>幂</strong>函数。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li>
            <base>
            <p>十进制数。底数。</p>
        </li>
        <li>
            <p>
                <exponent>
            </p>
            <p>十进制数。指数（幂）。</p>
        </li>
    </ul>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">for (i = [0:5]) {</div>
        <div class="codeLine"> translate([i*25,0,0]) {</div>
        <div class="codeLine"> &nbsp; cylinder(h = pow(2,i)*5, r=10);</div>
        <div class="codeLine"> &nbsp; echo (i, pow(2,i));</div>
        <div class="codeLine"> }</div>
        <div class="codeLine">}</div>
        <div class="codeLine">echo(pow(10,2)); // 意即10^2 或 10*10</div>
        <div class="codeLine">// 结果: ECHO: 100</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo(pow(10,3)); // 意即10^3 或 10*10*10</div>
        <div class="codeLine">// 结果: ECHO: 1000</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo(pow(125,1/3)); // 意即125^(0.333...)，等价于计算125的立方根</div>
        <div class="codeLine">// 结果: ECHO: 5</div>
    </div>
    <h3><a name="rands"></a>rands</h3>
    <p>随机数生成器。生成伪随机数构成的常向量（很像数组）。其中的元素皆为双精度浮点数而非整数。当生成一个数时，您仍可用变量[0]来调用它。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> min_value - 随机数范围中的最小值</li>
        <li> max_value - 随机数范围中的最大值</li>
        <li> value_count - 返回向量中的随机数数量</li>
        <li> seed_value (可选项) - 应对可重复结果而为随机数生成器设置的种子值。在2015近期之前的各版本中，seed_value将被取整为最接近的整数。</li>
    </ul>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 获取单个随机数</div>
        <div class="codeLine">single_rand = rands(0,10,1)[0];</div>
        <div class="codeLine">echo(single_rand);</div>
        <div class="codeLine">// 获取由4个元素构成的向量</div>
        <div class="codeLine">seed=42;</div>
        <div class="codeLine">random_vect=rands(5,15,4,seed);</div>
        <div class="codeLine">echo( "Random Vector: ",random_vect);</div>
        <div class="codeLine">sphere(r=5);</div>
        <div class="codeLine">for(i=[0:3]) {</div>
        <div class="codeLine"> rotate(360*i/4) {</div>
        <div class="codeLine"> &nbsp; translate([10+random_vect[i],0,0])</div>
        <div class="codeLine"> &nbsp; &nbsp; sphere(r=random_vect[i]/2);</div>
        <div class="codeLine"> }</div>
        <div class="codeLine">}</div>
        <div class="codeLine">// ECHO: "Random Vector: ", [8.7454, 12.9654, 14.5071, 6.83435]</div>
    </div>
    <h3><a name="round"></a>round</h3>
    <p>&quot;round&quot;运算符返回参数的四舍五入值。</p>
    <p>一些示例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">round(x.5) = x+1.</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(x.49) = x.</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(-(x.5)) = -(x+1).</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(-(x.49)) = -x.</div>
        <div class="codeLine">​</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(5.4); //-&gt; 5</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(5.5); //-&gt; 6</div>
        <div class="codeLine">​</div>
        <div class="codeLine">round(5.6); //-&gt; 6</div>
    </div>
    <h3><a name="sign"></a>sign</h3>
    <p>数学中的<strong>符号</strong>函数。返回带有参数符号的单位值，参见：<a target="wikibook" href="https://zh.wikipedia.org/wiki/Sign_function">Signum function</a></p>
    <p><strong>参数</strong></p>
    <ul>
        <li>
            <p>
                <x>
            </p>
            <p>十进制数。待查符号的值。</p>
        </li>
    </ul>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">sign(-5.0);</div>
        <div class="codeLine">sign(0);</div>
        <div class="codeLine">sign(8.0);</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">-1.0</div>
        <div class="codeLine">0.0</div>
        <div class="codeLine">1.0</div>
    </div>
    <h3><a name="sqrt"></a>sqrt</h3>
    <p>数学中的<strong>平方根</strong>函数。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">translate([sqrt(100),0,0])sphere(100);</div>
    </div>
    <h2><a name="infinities-and-nans"></a>Infinities and NaNs</h2>
    <p>How does OpenSCAD deal with inputs like (1/0)? Basically, the behavior is inherited from the language OpenSCAD was written in, the C++ language, andits floating point number types and the associated C math library. This system allows representation of both positive and negative infinity by thespecial values &quot;Inf&quot; or &quot;-Inf&quot;. It also allow representation of creatures like sqrt(-1) or 0/0 as &quot;NaN&quot;, anabbreviation for &quot;Not A Number&quot;. Some very nice explanations can be found on the web, for example the <a target="wikibook"href="http://pubs.opengroup.org/onlinepubs/009695399/basedefs/math.h.html">Open Group&#39;s site on math.h</a> or <ahref="#representation_of_non-numbers">Wikipedia&#39;s page on the IEEE 754 number format</a>. However OpenSCAD is it&#39;s own language so itmay not exactly match everything that happens in C. For example, OpenSCAD uses degrees instead of radians for trigonometric functions. Anotherexample is that sin() does not throw a &quot;domain error&quot; when the input is 1/0, although it does return NaN.</p>
    <p>Here are some examples of infinite input to OpenSCAD math functions and the resulting output, taken from OpenSCAD&#39;s regression test system inlate 2015.</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th>0/0: nan</th>
                    <th>sin(1/0): nan</th>
                    <th>asin(1/0): nan</th>
                    <th>ln(1/0): inf</th>
                    <th>round(1/0): inf</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>-0/0: nan</td>
                    <td>cos(1/0): nan</td>
                    <td>acos(1/0): nan</td>
                    <td>ln(-1/0): nan</td>
                    <td>round(-1/0): -inf</td>
                </tr>
                <tr>
                    <td>0/-0: nan</td>
                    <td>tan(1/0): nan</td>
                    <td>atan(1/0): 90</td>
                    <td>log(1/0): inf</td>
                    <td>sign(1/0): 1</td>
                </tr>
                <tr>
                    <td>1/0: inf</td>
                    <td>ceil(-1/0): -inf</td>
                    <td>atan(-1/0): -90</td>
                    <td>log(-1/0): nan</td>
                    <td>sign(-1/0): -1</td>
                </tr>
                <tr>
                    <td>1/-0: -inf</td>
                    <td>ceil(1/0): inf</td>
                    <td>atan2(1/0, -1/0): 135</td>
                    <td>max(-1/0, 1/0): inf</td>
                    <td>sqrt(1/0): inf</td>
                </tr>
                <tr>
                    <td>-1/0: -inf</td>
                    <td>floor(-1/0): -inf</td>
                    <td>exp(1/0): inf</td>
                    <td>min(-1/0, 1/0): -inf</td>
                    <td>sqrt(-1/0): nan</td>
                </tr>
                <tr>
                    <td>-1/-0: inf</td>
                    <td>floor(1/0): inf</td>
                    <td>exp(-1/0): 0</td>
                    <td>pow(2, 1/0): inf</td>
                    <td>pow(2, -1/0): 0</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <hr />
    <h1><a name="openscad用户手册字符串函数"></a>OpenSCAD用户手册/字符串函数 | |</h1>
    <h3><a name="目录-n4552"></a>目录</h3>
    <ul>
        <li><a href="#str">1 str</a></li>
        <li><a href="#chr">2 chr</a></li>
        <li><a href="#ord">3 ord</a></li>
        <li><a href="#参见search()">4 参见search()</a></li>
    </ul>
    <h3><a name="str"></a>str</h3>
    <p>将所有参数都转换为字符串并合而为一。</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">number=2;</div>
        <div class="codeLine">echo ("This is ",number,3," and that's it.");</div>
        <div class="codeLine">echo (str("This is ",number,3," and that's it."));</div>
    </div>
    <p><strong>结果：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">ECHO: "This is ", 2, 3, " and that's it."</div>
        <div class="codeLine">ECHO: "This is 23 and that's it."</div>
    </div>
    <h3><a name="chr"></a>chr</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>将数值们转换为对应编码，并合并为一个字符串。OpenSCAD采用Unicode码, 因此会将数值解释为Unicode码位(code point)。若数值超出有效码位的范围，则生成一个空字符串。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> chr(数值) - 如果数值的码位有效，则将仅有的一个码位转换至长度为1的字符串（字节数取决于UTF-8编码）。</li>
        <li> chr(向量) - 将向量参数中的所有码位转换为一个字符串。</li>
        <li> chr(范围) - 将范围参数生成的所有码位转换为一个字符串。</li>
    </ul>
    <p><strong>示例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(chr(65), chr(97)); &nbsp; &nbsp; // ECHO: "A", "a"</div>
        <div class="codeLine">echo(chr(65, 97)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "Aa"</div>
        <div class="codeLine">echo(chr([66, 98])); &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "Bb"</div>
        <div class="codeLine">echo(chr([97 : 2 : 102])); &nbsp; // ECHO: "ace"</div>
        <div class="codeLine">echo(chr(-3)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: ""</div>
        <div class="codeLine">echo(chr(9786), chr(9788)); // ECHO: "☺", "☼"</div>
        <div class="codeLine">echo(len(chr(9788))); &nbsp; &nbsp; &nbsp; // ECHO: 1</div>
    </div>
    <p>请注意: 当使用echo()向控制台输出字符码大于127的内容时，具体的输出结果取决于所用平台。</p>
    <h3><a name="ord"></a>ord</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>将一个字符转换为对应<a target="wikibook" href="https://en.wikipedia.org/wiki/Unicode">Unicode</a><a target="wikibook"href="https://en.wikipedia.org/wiki/Code_point">码位</a>的数值。如果参数并非字符串，则<code>ord()</code>将返回<code>undef</code>。</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> ord(字符串) - 将指定字符串中的第一个字符转换为一个Unicode码位。</li>
    </ul>
    <p><strong>示例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo(ord("a"));</div>
        <div class="codeLine">// ECHO: 97</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo(ord("BCD"));</div>
        <div class="codeLine">// ECHO: 66</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo([for (c = "Hello! �") ord(c)]);</div>
        <div class="codeLine">// ECHO: [72, 101, 108, 108, 111, 33, 32, 128578]</div>
    </div>
    <h3><a name="参见search"></a>参见search()</h3>
    <p><em><a href="#查找函数search()">search()</a></em>用于搜索文本。</p>
    <hr />
    <h1><a name="openscad用户手册其他语言特性"></a>OpenSCAD用户手册/其他语言特性</h1>
    <h3><a name="目录-n4603"></a>目录</h3>
    <ul>
        <li> 1 特殊变量
            <ul>
                <li><a href="#$fa,_$fs_与_$fn">1.1 $fa, $fs 与 $fn</a></li>
                <li><a href="#$t">1.2 $t</a></li>
                <li><a href="#$vpr,_$vpt_与_$vpd">1.3 $vpr, $vpt 与 $vpd</a></li>
                <li><a href="#$preview">1.4 $preview</a></li>
            </ul>
        </li>
        <li> 2 echo语句
            <ul>
                <li><a href="#用例">2.1 用例</a></li>
                <li><a href="#四舍五入示例">2.2 四舍五入示例</a></li>
                <li><a href="#小数与大数示例">2.3 小数与大数示例</a></li>
                <li><a href="#html">2.4 HTML</a></li>
            </ul>
        </li>
        <li><a href="#echo函数">3 echo函数</a></li>
        <li><a href="#render">4 render</a></li>
        <li> 5 surface
            <ul>
                <li><a href="#文本文件格式">5.1 文本文件格式</a></li>
                <li><a href="#图片">5.2 图片</a></li>
                <li><a href="#示例">5.3 示例</a></li>
            </ul>
        </li>
        <li> 6 search
            <ul>
                <li><a href="#查找函数的用法">6.1 查找函数的用法</a></li>
                <li><a href="#查找函数的参数">6.2 查找函数的参数</a></li>
                <li> 6.3 Search Usage Examples
                    <ul>
                        <li><a href="#index_values_return_as_list">6.3.1 Index values return as list</a></li>
                        <li><a href="#search_on_different_column;_return_index_values">6.3.2 Search on different column; return Index values</a></li>
                        <li><a href="#对一组值进行搜索">6.3.3 对一组值进行搜索</a></li>
                        <li><a href="#search_on_list_of_strings">6.3.4 Search on list of strings</a></li>
                        <li><a href="#getting_the_right_results">6.3.5 Getting the right results</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="#openscad版本">7 OpenSCAD版本</a></li>
        <li><a href="#parent_module(n)_与_$parent_modules">8 parent_module(n) 与 $parent_modules</a></li>
        <li> 9 assert
            <ul>
                <li><a href="#示例_2">9.1 示例</a></li>
                <li><a href="#检查参数">9.2 检查参数</a></li>
                <li><a href="#adding_message">9.3 Adding message</a></li>
                <li><a href="#using_assertions_in_function">9.4 Using assertions in function</a></li>
            </ul>
        </li>
        <li> 10 is_undef
            <ul>
                <li><a href="#legacy_support">10.1 legacy support</a></li>
            </ul>
        </li>
        <li><a href="#is_list">11 is_list</a></li>
        <li><a href="#is_num">12 is_num</a></li>
        <li><a href="#is_bool">13 is_bool</a></li>
        <li><a href="#is_string">14 is_string</a></li>
    </ul>
    <h3><a name="特殊变量-n4689"></a>特殊变量</h3>
    <p>特殊变量为向模块与函数传递参数提供了一种替代方法。所有的用户或OpenSCAD自身通过在变量前加入&#39;$&#39;来定义特殊变量，这与lisp中的特殊变量定义方式相似。Modules and function see all outside variables in addition tothose passed as arguments or defined internally.</p>
    <p>常规变量的赋值发生在编译时，因此，对于所有调用而言其值是静态的。</p>
    <p>Special variables pass along their value from within the scope <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/The_OpenSCAD_Language&amp;action=edit&amp;redlink=1">(see scope ofvariables)</a> from which the module or function is called. This means that special variables can potentially have a different value each time amodule or function is called.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">regular = "regular global";</div>
        <div class="codeLine">$special = "special global";</div>
        <div class="codeLine">module show() echo(" &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", regular," &nbsp; ", $special );</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo (" &nbsp; &nbsp; &nbsp; &nbsp; outside &nbsp; ", regular," &nbsp; ", $special );</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; outside &nbsp; ", "regular global", " &nbsp; ", "specialglobal"</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">for ( regular = [0:1] ){ echo("in regular loop &nbsp; &nbsp; ", regular," &nbsp; ", $special ); show();}</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "in regular loop &nbsp; &nbsp; ", 0, " &nbsp; ", "special global"</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", "regular global", " &nbsp; ", "specialglobal"</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "in regular loop &nbsp; &nbsp; ", 1, " &nbsp; ", "special global"</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", "regular global", " &nbsp; ", "specialglobal"</div>
        <div class="codeLine">​</div>
        <div class="codeLine">for ( $special = [5:6] ){ echo("in special loop &nbsp; &nbsp; ", regular," &nbsp; ", $special ); show();}</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "in special loop &nbsp; &nbsp; ", "regular global", " &nbsp; ", 5</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", "regular global", " &nbsp; ", 5</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: "in special loop &nbsp; &nbsp; ", "regular global", " &nbsp; ", 6</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", "regular global", " &nbsp; ", 6</div>
        <div class="codeLine">​</div>
        <div class="codeLine">show();</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; // ECHO: " &nbsp; &nbsp; &nbsp; &nbsp; in show &nbsp; ", "regular global", " &nbsp; ", "specialglobal"</div>
    </div>
    <p>This is useful when multiple arguments need to be passed thru several layers of module calls.</p>
    <p>Several special variables are already defined by OpenSCAD.</p>
    <h3><a name="fa-fs-与-fn"></a>$fa, $fs 与 $fn</h3>
    <p>特殊变量$fa, $fs 与 $fn控制着用于生成弧的细分平面数量：</p>
    <p>$fa为片段的最小角度。即使是一个再巨大的圆形，也不能通过此值而将其划分为多于360个片段。此特殊变量的默认值为12 (即，整个圆形分为30个片段)。其最小值为0.01。若企图将其设置为小于0.01的值，会产生一个警告。</p>
    <p>$fs为片段的最小尺寸。Because of this variable very small circles have a smaller number of fragments than specified using $fa.此特殊变量的默认值为2。其最小值为0.01。若企图将其设置为小于0.01的值，会产生一个警告。</p>
    <p>$fn通常为0。当此变量大于0时，则忽略另外两个变量（$fa, $fs），且以此值作为片段数量来渲染整个圆形。其默认值为0。</p>
    <p>片段数量越多，占用的内存与CPU也就越多，较大值会令大多数系统跪掉。 Depending on the design, $fn values, and the corresponding results of $fa &amp; $fs, should be kept small, atleast until the design is finalised when it can be increased for the final result. <strong>A $fn over 100 is not recommended</strong> or only forspecific circumstances, and below 50 would be advisable for performance.</p>
    <p><strong>TIP:</strong> If you want to create a circle/cylinder/sphere which has a axis aligned integer bounding box (i.e. a bounding box that hasintegral dimensions, and an integral position) use a value of $fn that is divisible by 4.</p>
    <p>当采用$fa与$fs来确定一个圆形的片段数量时，OpenSCAD使用的片段从不会少于5个。</p>
    <p>以下是计算圆形中片段数量的C代码：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; int get_fragments_from_r(double r, double fn, double fs, double fa)</div>
        <div class="codeLine"> &nbsp; &nbsp; {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (r &lt; GRID_FINE) return 3;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fn &gt; 0.0) return (int)(fn &gt;= 3 ? fn : 3);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (int)ceil(fmax(fmin(360.0 / fa, r*2*M_PI / fs), 5));</div>
        <div class="codeLine"> &nbsp; &nbsp; }</div>
    </div>
    <p>Or you can embed this OpenSCAD version in your code to work out what&#39;s going on, you need to set r= to your size</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; echo(n=($fn&gt;0?($fn&gt;=3?$fn:3):ceil(max(min(360/$fa,r*2*PI/$fs),5))),a_based=360/$fa,s_based=r*2*PI/$fs);</div>
    </div>
    <p>Spheres are first sliced into as many slices as the number of fragments being used to render a circle of the sphere&#39;s radius, and then everyslice is rendered into as many fragments as are needed for the slice radius. You might have recognized already that the pole of a sphere is usuallya pentagon. This is why.</p>
    <p>The number of fragments for a cylinder is determined using the greater of the two radii.</p>
    <p>The method is also used when rendering circles and arcs from DXF files. The variables have no effect when importing STL files.</p>
    <p>You can generate high resolution spheres by resetting the $fX values in the instantiating module:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; $fs = 0.01;</div>
        <div class="codeLine"> &nbsp; &nbsp; sphere(2);</div>
    </div>
    <p>或简单地通过传入特殊变量作为参数：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; sphere(2, $fs = 0.01);</div>
    </div>
    <p>您甚至可以直接为特殊变量乘以某个值而非将其重置：</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; &nbsp; sphere(2, $fs = $fs * 0.01);</div>
    </div>
    <h3><a name="t"></a>$t</h3>
    <p>$t变量用于制作动画。如果您通过设置view-&gt;animate开启动画，并指定&quot;FPS（帧率）&quot;以及&quot;Steps（步长）&quot;，&quot;Time&quot;字段显示的就是$t的当前值。掌握了这些信息，便能令您的设计以动画效果展示出来。Thedesign is recompiled every 1/&quot;FPS&quot; seconds with $t incremented by 1/&quot;Steps&quot; for &quot;Steps&quot; times, ending at either $t=1or $t=1-1/steps.</p>
    <p>如果选中&quot;Dump Pictures（转存图片）&quot;，那么就会在.scad文件所在的相同目录下创建一系列图片，此功能会利用以下$t值，并将图像保存在下列文件中：</p>
    <ul>
        <li>$t=0/Steps filename=&quot;frame00001.png&quot;</li>
        <li>$t=1/Steps filename=&quot;frame00002.png</li>
        <li>$t=2/Steps filename=&quot;frame00003.png&quot;</li>
        <li>. . .</li>
        <li>$t=1-3/Steps filename=&quot;frame
            <Steps-2>.png&quot;</li>
        <li>$t=1-2/Steps filename=&quot;frame
            <Steps-1>.png&quot;</li>
        <li>$t=1-1/Steps filename=&quot;frame00000.png&quot;</li>
    </ul>
    <p>或者，对于其他Steps步长值，它将按以下模式执行：</p>
    <ul>
        <li>$t=0/Steps filename=&quot;frame00001.png&quot;</li>
        <li>$t=1/Steps filename=&quot;frame00002.png</li>
        <li>$t=2/Steps filename=&quot;frame00003.png&quot;</li>
        <li>. . .</li>
        <li>$t=1-3/Steps filename=&quot;frame
            <Steps-2>.png&quot;</li>
        <li>$t=1-2/Steps filename=&quot;frame
            <Steps-1>.png&quot;</li>
        <li>$t=1-1/Steps filename=&quot;frame
            <Steps-0>.png&quot;</li>
        <li>$t=1-0/Steps filename=&quot;frame00000.png&quot;</li>
    </ul>
    <p>Which pattern it chooses appears to be an unpredictable, but consistent, function of Steps. For example, when Steps=4, it follows the first pattern,and outputs a total of 4 files. When Steps=3, it follows the second pattern, and also outputs 4 files. It will always output either Steps or Steps+1files, though it may not be predictable which. When finished, it will wrap around and recreate each of the files, looping through and recreatingthem forever.</p>
    <h3><a name="vpr-vpt-与-vpd"></a>$vpr, $vpt 与 $vpd</h3>
    <p>这三个特殊变量包含当前渲染时的视口旋转、视口平移与摄像机距离三种信息。移动视口并不会影响它们的值（wconly:??）。在展示动画期间会在每帧都更新它们的值。</p>
    <ul>
        <li>$vpr表示旋转</li>
        <li>$vpt表示平移(即此值不受旋转或缩放操作影响)</li>
        <li>$vpd表示摄像机距离 <strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></li>
    </ul>
    <p>示例</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> cube([10, 10, $vpr[0] / 10]);</div>
    </div>
    <p>如果开启动画循环(无需使用$t变量)，这段代码将使立方体随观察视角改变大小。</p>
    <p>You can also make bits of a complex model vanish as you change the view.</p>
    <p>All three variables are writable but only assignments at the top-level of the main file will have an effect on the viewport.
        <strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>示例</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> $vpr = [0, 0, $t * 360];</div>
    </div>
    <p>which allows a simple 360 degree rotation around the Z axis in animation mode.</p>
    <p>The menu command <em>Edit - Paste Viewport Rotation/Translation</em> copies the current value of the viewport, but not the current $vpr or $vpt.</p>
    <h3><a name="preview"></a>$preview</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>当处于OpenCSG预览模式(F5)下，$preview为true。在处于渲染模式(F6)下，$preview为false。</p>
    <p>This can, for example, be used to reduce detail during preview to save time, without losing detail in the final rendered result:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">$fn = $preview ? 12 : 72;</div>
        <div class="codeLine">sphere(r = 1);</div>
    </div>
    <p>请注意，渲染模块不会影响$preview:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">render(){</div>
        <div class="codeLine"> &nbsp; $fn = $preview ? 12 : 72;</div>
        <div class="codeLine"> &nbsp; sphere(r = 1);</div>
        <div class="codeLine">}</div>
    </div>
    <p>Another use could be to make the preview show an assembly view and the render generate just the printed parts laid out for printing.</p>
    <p>If printed parts need extra features that are removed post printing, for example support for suspended holes, then the preview can omit these to showthe finished part after post processing.</p>
    <p>When OpenSCAD is run from the command line $preview is only true when generating a PNG image with OpenCSG. It is false when generating STL, DXF andSVG files with CGAL. It is also false when generating CSG and ECHO files. This may or may not be what you want, but you can always override it onthe command line like any other variable with the -D option.</p>
    <h3><a name="echo语句"></a>echo语句</h3>
    <p>此函数会在编译窗口（又名控制台）中打印特定内容。有助于调试代码。参见字符串函数 str().</p>
    <p>此函数显示的数值经四舍五入保留5位有效数字。</p>
    <p>OpenSCAD控制台支持HTML标记语言的一个子集。细节请见<a target="wikibook" href="http://doc.qt.io/qt-5/richtext-html-subset.html">Qt Docs</a>。</p>
    <p>It can be handy to use &#39;variable=variable&#39; as the expression to easily label the variables, see the example below.</p>
    <h3><a name="用例"></a>用例</h3>
    <p><strong>用例:</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">my_h=50;</div>
        <div class="codeLine">my_r=100;</div>
        <div class="codeLine">echo("This is a cylinder with h=", my_h, " and r=", my_r);</div>
        <div class="codeLine">echo(my_h=my_h,my_r=my_r); // shortcut</div>
        <div class="codeLine">cylinder(h=my_h, r=my_r);</div>
        <div class="codeLine">//</div>
        <div class="codeLine">echo("Hello Qt!");</div>
    </div>
    <p>工作台中显示的结果为：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">ECHO: "This is a cylinder with h=", 50, " and r=", 100</div>
        <div class="codeLine">ECHO: my_h = 50, my_r = 100</div>
        <div class="codeLine">ECHO: "Hello Qt!"</div>
    </div>
    <h3><a name="四舍五入示例"></a>四舍五入示例</h3>
    <p>针对四舍五入设置的示例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">a=1.0;</div>
        <div class="codeLine">b=1.000002;</div>
        <div class="codeLine">echo(a);</div>
        <div class="codeLine">echo(b);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">if(a==b){ // 尽管回显结果相同，但是二值仍有差别</div>
        <div class="codeLine"> &nbsp; echo ("a==b");</div>
        <div class="codeLine">}else if(a&gt;b){</div>
        <div class="codeLine"> &nbsp; echo ("a&gt;b");</div>
        <div class="codeLine">}else if(a&lt;b){</div>
        <div class="codeLine"> &nbsp; echo ("a&lt;b");</div>
        <div class="codeLine">}else{</div>
        <div class="codeLine"> &nbsp; echo ("???");</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="小数与大数示例"></a>小数与大数示例</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">c=1000002;</div>
        <div class="codeLine">d=0.000002;</div>
        <div class="codeLine">echo(c); //1e+06</div>
        <div class="codeLine">echo(d); //2e-06</div>
    </div>
    <h3><a name="html"></a>HTML</h3>
    <p>HTML工作示例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("&lt;h1&gt;Heading&lt;/h1&gt;");</div>
        <div class="codeLine">echo("&lt;b&gt;Bold&lt;/b&gt; &lt;i&gt;italic&lt;/i&gt; &lt;big&gt;big&lt;/big&gt;");</div>
        <div class="codeLine">echo("i&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;2&lt;sup&gt;");</div>
        <div class="codeLine">echo("&lt;font color="red"&gt;red&lt;/font&gt; &lt;font color="green"&gt;green&lt;/font&gt; &lt;fontcolor="blue"&gt;blue&lt;/font&gt;");</div>
    </div>
    <p>不会生效的代码示例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("&lt;img src="http://www.openscad.org/assets/img/logo.png"&gt;&lt;/img&gt;");</div>
        <div class="codeLine">echo("&lt;a target="wikibook" href="http://en.wikibooks.org/"&gt;wikibooks&lt;/a&gt;");</div>
    </div>
    <p>请注意：可以复制输出再将其粘贴到OpenOffice中，图片与链接在里面都可正常工作。</p>
    <h3><a name="echo函数"></a>echo函数</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>Echo can be used in expression context to print information while the function/expression is evaluated. The output is generated before the expressionevaluation to allow debugging of recursive functions.</p>
    <p><strong>示例</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> a = 3; b = 5;</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> // echo() prints values before evaluating the expression</div>
        <div class="codeLine"> r1 = echo(a, b) a * b; // ECHO: 3, 5</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> // using let it's still easy to output the result</div>
        <div class="codeLine"> r2 = let(r = 2 * a * b) echo(r) r; // ECHO: 30</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> // use echo statement for showing results </div>
        <div class="codeLine"> echo(r1, r2); // ECHO: 15, 30</div>
    </div>
    <p>A more complex example shows how echo() can be used in both descending and ascending path of a recursive function. The result() helper function is asimple way to output the value of an expression after evaluation.</p>
    <p><strong>Example printing both input values and result of recursive sum()</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> v = [4, 7, 9, 12];</div>
        <div class="codeLine"> function result(x) = echo(result = x) x;</div>
        <div class="codeLine"> function sum(x, i = 0) = echo(str("x[", i, "]=", x[i])) result(len(x) &gt; i ? x[i] + sum(x, i + 1) : 0);</div>
        <div class="codeLine"> echo("sum(v) = ", sum(v));</div>
        <div class="codeLine"> </div>
        <div class="codeLine"> // ECHO: "x[0]=4"</div>
        <div class="codeLine"> // ECHO: "x[1]=7"</div>
        <div class="codeLine"> // ECHO: "x[2]=9"</div>
        <div class="codeLine"> // ECHO: "x[3]=12"</div>
        <div class="codeLine"> // ECHO: "x[4]=undef"</div>
        <div class="codeLine"> // ECHO: result = 0</div>
        <div class="codeLine"> // ECHO: result = 12</div>
        <div class="codeLine"> // ECHO: result = 21</div>
        <div class="codeLine"> // ECHO: result = 28</div>
        <div class="codeLine"> // ECHO: result = 32</div>
        <div class="codeLine"> // ECHO: "sum(v) = ", 32</div>
    </div>
    <h3><a name="render-n4812"></a>render</h3>
    <p>Forces the generation of a mesh even in preview mode. Useful when the boolean operations become too slow to track.</p>
    <p>Needs description.</p>
    <p><strong>用例：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">render(convexity = 2) difference() {</div>
        <div class="codeLine"> cube([20, 20, 150], center = true);</div>
        <div class="codeLine"> translate([-10, -10, 0])</div>
        <div class="codeLine"> cylinder(h = 80, r = 10, center = true);</div>
        <div class="codeLine"> translate([-10, -10, +40])</div>
        <div class="codeLine"> sphere(r = 10);</div>
        <div class="codeLine"> translate([-10, -10, -40])</div>
        <div class="codeLine"> sphere(r = 10);</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="surface"></a>surface</h3>
    <p>Surface reads <a target="wikibook" href="https://zh.wikipedia.org/wiki/Heightmap">Heightmap</a> information from text or image files.</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> file - String. The path to the file containing the heightmap data.</li>
        <li>
            <p>center - Boolean. This determines the positioning of the generated object. If true, object is centered in X- and Y-axis. Otherwise, theobject is placed in the positive quadrant. Defaults to false.</p>
        </li>
        <li>
            <p>invert - Boolean. Inverts how the color values of imported images are translated into height values. This has no effect when importing textdata files. Defaults to false. <strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
        </li>
        <li>
            <p>convexity - Integer. The convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object mightpenetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on the finalrendering.</p>
        </li>
    </ul>
    <h3><a name="文本文件格式"></a>文本文件格式</h3>
    <p>The format for text based heightmaps is a matrix of numbers that represent the height for a specific point. Rows are mapped to the Y-axis, columns tothe X axis. The numbers must be separated by spaces or tabs. Empty lines and lines starting with a # character are ignored.</p>
    <h3><a name="图片"></a>图片</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <p>Currently only PNG images are supported. Alpha channel information of the image is ignored and the height for the pixel is determined by convertingthe color value to <a target="wikibook" href="https://zh.wikipedia.org/wiki/Grayscale">Grayscale</a> using the linear luminance for the sRGB colorspace (Y = 0.2126R + 0.7152G + 0.0722B). The gray scale values are scaled to be in the range 0 to 100.</p>
    <h3><a name="示例-n4838"></a>示例</h3>
    <p><strong>示例1：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">//surface.scad</div>
        <div class="codeLine">surface(file = "surface.dat", center = true, convexity = 5);</div>
        <div class="codeLine">%translate([0,0,5])cube([10,10,10], center =true);</div>
        <div class="codeLine">#surface.dat</div>
        <div class="codeLine">10 9 8 7 6 5 5 5 5 5 </div>
        <div class="codeLine">9 8 7 6 6 4 3 2 1 0 </div>
        <div class="codeLine">8 7 6 6 4 3 2 1 0 0</div>
        <div class="codeLine">7 6 6 4 3 2 1 0 0 0</div>
        <div class="codeLine">6 6 4 3 2 1 1 0 0 0</div>
        <div class="codeLine">6 6 3 2 1 1 1 0 0 0</div>
        <div class="codeLine">6 6 2 1 1 1 1 0 0 0</div>
        <div class="codeLine">6 6 1 0 0 0 0 0 0 0</div>
        <div class="codeLine">3 1 0 0 0 0 0 0 0 0</div>
        <div class="codeLine">3 0 0 0 0 0 0 0 0 0</div>
    </div>
    <p>结果：</p>
    <p><img src="img/Openscad_surface_example_x1.png"></p>
    <p><strong>示例2：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> // example010.dat generated using octave:</div>
        <div class="codeLine"> // d = (sin(1:0.2:10)' * cos(1:0.2:10)) * 10;</div>
        <div class="codeLine"> // save("example010.dat", "d");</div>
        <div class="codeLine"> intersection() {</div>
        <div class="codeLine"> &nbsp; surface(file = "example010.dat", center = true, convexity = 5);</div>
        <div class="codeLine"> &nbsp; rotate(45, [0, 0, 1]) surface(file = "example010.dat", center = true, convexity = 5); </div>
        <div class="codeLine"> }</div>
    </div>
    <p><img src="img/Openscad_surface_example_x2.png"></p>
    <p><strong>示例3：</strong></p>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 示例 3a</div>
        <div class="codeLine">scale([1, 1, 0.1])</div>
        <div class="codeLine"> surface(file = "smiley.png", center = true);</div>
        <div class="codeLine">// 示例 3b</div>
        <div class="codeLine">scale([1, 1, 0.1])</div>
        <div class="codeLine"> surface(file = "smiley.png", center = true, invert = true);</div>
    </div>
    <p><img src="img/220px-OpenSCAD_surface_example_input_image.png"></p>
    <p>输入的图片</p>
    <p><img src="img/220px-OpenSCAD_surface_example.png"></p>
    <p>示例3a: surface(invert = false)</p>
    <p><img src="img/220px-OpenSCAD_surface_example_%28inverted%29.png"></p>
    <p>示例3b: surface (invert = true)</p>
    <p>示例3: 用surface()函数处理以PNG图片充当的高度图</p>
    <p><strong>示例4：</strong></p>
    <p><strong>[请注意: *需要使用版本 *<em>2015.03*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 示例4</div>
        <div class="codeLine">surface(file = "BRGY-Grey.png", center = true, invert = false);</div>
    </div>
    <ul>
        <li>
            <p><img src="img/BRGY-Grey.png"></p>
            <p>PNG测试文件</p>
        </li>
        <li> &nbsp;</li>
        <li>
            <p><img src="img/BRGY-Grey-3D.png"></p>
            <p>生成的3D表面</p>
        </li>
    </ul>
    <h3><a name="search"></a>search</h3>
    <p>The search() function is a general-purpose function to find one or more (or all) occurrences of a value or list of values in a vector, string or morecomplex list-of-list construct.</p>
    <h3><a name="查找函数的用法"></a>查找函数的用法</h3>
    <h3><a name="查找函数的参数"></a>查找函数的参数</h3>
    <ul>
        <li><strong>match_value</strong></li>
    </ul>
    <ul>
        <li><strong>string_or_vector</strong></li>
    </ul>
    <ul>
        <li><strong>num_returns_per_match</strong> (default: 1)</li>
    </ul>
    <ul>
        <li><strong>index_col_num</strong> (default: 0)</li>
    </ul>
    <h3><a name="search-usage-examples"></a>Search Usage Examples</h3>
    <h3><a name="index-values-return-as-list"></a>Index values return as list</h3>
    <figure>
        <table>
            <thead>
                <tr>
                    <th style="text-align:center;">Example</th>
                    <th style="text-align:center;">Code</th>
                    <th style="text-align:center;">Result</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="text-align:center;">1</td>
                    <td style="text-align:center;"><code>search(&quot;a&quot;,&quot;abcdabcd&quot;);</code></td>
                    <td style="text-align:center;">[0]</td>
                </tr>
                <tr>
                    <td style="text-align:center;">2</td>
                    <td style="text-align:center;"><code>search(&quot;e&quot;,&quot;abcdabcd&quot;);</code></td>
                    <td style="text-align:center;">[]</td>
                </tr>
                <tr>
                    <td style="text-align:center;">3</td>
                    <td style="text-align:center;"><code>search(&quot;a&quot;,&quot;abcdabcd&quot;,0);</code></td>
                    <td style="text-align:center;">[[0,4]]</td>
                </tr>
                <tr>
                    <td style="text-align:center;">4</td>
                    <td style="text-align:center;">
                        <code>data=[[&quot;a&quot;,1],[&quot;b&quot;,2],[&quot;c&quot;,3],[&quot;d&quot;,4],[&quot;a&quot;,5],[&quot;b&quot;,6],[&quot;c&quot;,7],[&quot;d&quot;,8],[&quot;e&quot;,9]];``search(&quot;a&quot;,data, *num_returns_per_match*=0);</code></td>
                    <td style="text-align:center;">[[0,4]] (see also Example 6 below)</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <h3><a name="search-on-different-column-return-index-values"></a>Search on different column; return Index values</h3>
    <p><strong>示例5：</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> data= [ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",3] ];</div>
        <div class="codeLine"> echo(search(3, data)); &nbsp; // Searches index 0, so it doesn't find anything</div>
        <div class="codeLine"> echo(search(3, data, num_returns_per_match=0, index_col_num=1));</div>
    </div>
    <p>输出:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> ECHO: []</div>
        <div class="codeLine"> ECHO: [2, 8]</div>
    </div>
    <h3><a name="对一组值进行搜索"></a>对一组值进行搜索</h3>
    <p><strong>示例6: Return all matches per search vector element.</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> data= [ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ];</div>
        <div class="codeLine"> search("abc", data, num_returns_per_match=0);</div>
    </div>
    <p>Returns:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; [[0,4],[1,5],[2,6]]</div>
    </div>
    <p><strong>示例7: Return first match per search vector element; special case return vector.</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> data= [ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ];</div>
        <div class="codeLine"> search("abc", data, num_returns_per_match=1);</div>
    </div>
    <p>Returns:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; [0,1,2]</div>
    </div>
    <p><strong>示例8: Return first two matches per search vector element; vector of vectors.</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> data= [ ["a",1],["b",2],["c",3],["d",4],["a",5],["b",6],["c",7],["d",8],["e",9] ];</div>
        <div class="codeLine"> search("abce", data, num_returns_per_match=2);</div>
    </div>
    <p>Returns:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> [[0,4],[1,5],[2,6],[8]]</div>
    </div>
    <h3><a name="search-on-list-of-strings"></a>Search on list of strings</h3>
    <p><strong>示例9:</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine"> lTable2=[ ["cat",1],["b",2],["c",3],["dog",4],["a",5],["b",6],["c",7],["d",8],["e",9],["apple",10],["a",11] ];</div>
        <div class="codeLine"> lSearch2=["b","zzz","a","c","apple","dog"];</div>
        <div class="codeLine"> l2=search(lSearch2,lTable2);</div>
        <div class="codeLine"> echo(str("Default list string search (",lSearch2,"): ",l2));</div>
    </div>
    <p>Returns</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> ECHO: "Default list string search (["b", "zzz", "a", "c", "apple", "dog"]): [1, [], 4, 2, 9, 3]"</div>
    </div>
    <h3><a name="getting-the-right-results"></a>Getting the right results</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">// workout which vectors get the results</div>
        <div class="codeLine">v=[ ["O",2],["p",3],["e",9],["n",4],["S",5],["C",6],["A",7],["D",8] ];</div>
        <div class="codeLine">//</div>
        <div class="codeLine">echo(v[0]); // -&gt; ["O",2]</div>
        <div class="codeLine">echo(v[1]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; // -&gt; ["p",3]</div>
        <div class="codeLine">echo(v[1][0],v[1][1]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; "p",3
        </div>
        <div class="codeLine">echo(search("p",v)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // find "p"-&gt; [1]</div>
        <div class="codeLine">echo(search("p",v)[0]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; 1</div>
        <div class="codeLine">echo(search(9,v,0,1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // find 9 -&gt; [2]
        </div>
        <div class="codeLine">echo(v[search(9,v,0,1)[0]]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; ["e",9]</div>
        <div class="codeLine">echo(v[search(9,v,0,1)[0]][0]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; "e"</div>
        <div class="codeLine">echo(v[search(9,v,0,1)[0]][1]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; 9</div>
        <div class="codeLine">echo(v[search("p",v,1,0)[0]][1]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; 3</div>
        <div class="codeLine">echo(v[search("p",v,1,0)[0]][0]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; "p"</div>
        <div class="codeLine">echo(v[search("d",v,1,0)[0]][0]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // "d" not found -&gt; undef</div>
        <div class="codeLine">echo(v[search("D",v,1,0)[0]][1]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // -&gt; 8</div>
    </div>
    <h3><a name="openscad版本"></a>OpenSCAD版本</h3>
    <p>version()与version_num()函数会返回OpenSCAD的版本号。</p>
    <ul>
        <li>version()函数以向量的形式返回OpenSCAD的版本，例如[2011, 09, 23]</li>
        <li>version_num()函数以数值的形式返回OpenSCAD的版本，例如 20110923</li>
    </ul>
    <h3><a name="parentmodulen-与-parentmodules"></a>parent_module(n) 与 $parent_modules</h3>
    <p>$parent_modules contains the number of modules in the instantiation stack. parent_module(i) returns the name of the module i levels above the currentmodule in the instantiation stack. The stack is independent of where the modules are defined. It&#39;s where they&#39;re instantiated that counts.This can be used to e.g. build BOMs.</p>
    <p>示例:</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> module top() {</div>
        <div class="codeLine"> &nbsp; children();</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> module middle() {</div>
        <div class="codeLine"> &nbsp; children();</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> top() middle() echo(parent_module(0)); // prints "middle"</div>
        <div class="codeLine"> top() middle() echo(parent_module(1)); // prints "top"</div>
    </div>
    <h3><a name="assert"></a>assert</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p><em>参见</em></p>
    <p><em><img src="img/40px-Wikipedia-logo.png"></em></p>
    <p><a target="wikibook" href="https://zh.wikipedia.org/wiki/Wikipedia:首页">维基百科</a>中的相关条目：</p>
    <p><strong><a target="wikibook" href="https://zh.wikipedia.org/wiki/Assertion_(software_development)">Assertion (software development)</a></strong></p>
    <p>Assert evaluates a logical expression. If the expression evaluates to false, the generation of the preview/render is stopped with an error. A stringrepresentation of the expression and, if given, the message is output to the console.</p>
    <p><strong>参数</strong></p>
    <ul>
        <li> condition - Expression. The expression to be evaluated as check for the assertion.</li>
        <li> message - String. Optional message to be output in case the assertion failed.</li>
    </ul>
    <h3><a name="示例-n4964"></a>示例</h3>
    <p>The simplest example is a simple <code>assert(false);</code>, e.g. in a file named
        <code>assert_example1.scad</code>.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">cube();</div>
        <div class="codeLine">assert(false);</div>
        <div class="codeLine">sphere();</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">// ERROR: Assertion 'false' failed in file assert_example1.scad, line 2</div>
    </div>
    <p>This example has little use, but the simple <code>assert(false);</code> can be used in code sections that should be unreachable.</p>
    <h3><a name="检查参数"></a>检查参数</h3>
    <p>A useful example is checking the validity of input parameters:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module row(cnt = 3){</div>
        <div class="codeLine"> &nbsp; // Count has to be a positive integer greater 0</div>
        <div class="codeLine"> &nbsp; assert(cnt &gt; 0);</div>
        <div class="codeLine"> &nbsp; for (i = [1 : cnt]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([i * 2, 0, 0]) sphere();</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
        <div class="codeLine">​</div>
        <div class="codeLine">row(0);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">// ERROR: Assertion '(cnt &gt; 0)' failed in file assert_example2.scad, line 3</div>
    </div>
    <h3><a name="adding-message"></a>Adding message</h3>
    <p>When writing a library, it could be useful to output additional information to the user in case of an failed assertion.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module row(cnt = 3){</div>
        <div class="codeLine"> &nbsp; assert(cnt &gt; 0, "Count has to be a positive integer greater 0");</div>
        <div class="codeLine"> &nbsp; for(i = [1 : cnt]) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([i * 2, 0, 0]) sphere();</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine">}</div>
        <div class="codeLine">​</div>
        <div class="codeLine">row(0);</div>
        <div class="codeLine">​</div>
        <div class="codeLine">// ERROR: Assertion '(cnt &gt; 0)': "Count has to be a positive integer greater 0" failed in file assert_example3.scad, line 2
        </div>
    </div>
    <h3><a name="using-assertions-in-function"></a>Using assertions in function</h3>
    <p>Assert returns its children, so when using it in a function you can write</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function f(a, b) =</div>
        <div class="codeLine"> &nbsp; assert(a &lt; 0, "wrong a") // assert input</div>
        <div class="codeLine"> &nbsp; assert(b &gt; 0, "wrong b") // assert input</div>
        <div class="codeLine"> &nbsp; let (c = a + b) // derive a new value from input</div>
        <div class="codeLine"> &nbsp; assert(c != 0, "wrong c") // assert derived value</div>
        <div class="codeLine"> &nbsp; a * b; // calculate</div>
    </div>
    <h3><a name="isundef"></a>is_undef</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>is_undef accepts one parameter. If the parameter is undef, this function returns true. If the parameter is not undef, it returns false. When checkinga variable (like <code>is_undef(a)</code>), it does the variable lookup silently, meaning that is_undef(a) does not cause
        <code>WARNING: Ignoring unknown variable &#39;a&#39;.</code></p>
    <p>The alternative is code like this:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">if(a==undef){</div>
        <div class="codeLine"> &nbsp; //code goes here</div>
        <div class="codeLine">}</div>
    </div>
    <p>or</p>
    <div class="CodeMirror-code">
        <div class="codeLine">b = (a==undef) ? true : false;</div>
    </div>
    <p>will cause</p>
    <div class="CodeMirror-code">
        <div class="codeLine">WARNING: Ignoring unknown variable 'a'.</div>
    </div>
    <p>is_undef also works for special variables, allowing for things like this:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">exploded = is_undef($exploded) ? 0 : $exploded; // 1 for exploded view</div>
    </div>
    <h3><a name="legacy-support"></a>legacy support</h3>
    <p>For older openscad version, is_undef can be emulated with</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function is_undef ( a ) = (undef == a) ;</div>
    </div>
    <p>which off-course causes warning(s), but requires no changes to code relaying on is_undef().</p>
    <h3><a name="islist"></a>is_list</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("returning true");</div>
        <div class="codeLine">echo(is_list([]));</div>
        <div class="codeLine">echo(is_list([1]));</div>
        <div class="codeLine">echo(is_list([1,2]));</div>
        <div class="codeLine">echo(is_list([true]));</div>
        <div class="codeLine">echo(is_list([1,2,[5,6],"test"]));</div>
        <div class="codeLine">echo("--------");</div>
        <div class="codeLine">echo("returning false");</div>
        <div class="codeLine">echo(is_list(1));</div>
        <div class="codeLine">echo(is_list(1/0));</div>
        <div class="codeLine">echo(is_list(((1/0)/(1/0))));</div>
        <div class="codeLine">echo(is_list("test"));</div>
        <div class="codeLine">echo(is_list(true));</div>
        <div class="codeLine">echo(is_list(false));</div>
        <div class="codeLine">echo("--------");</div>
        <div class="codeLine">echo("causing warnings:");</div>
        <div class="codeLine">echo(is_list());</div>
        <div class="codeLine">echo(is_list(1,2));</div>
    </div>
    <h3><a name="isnum"></a>is_num</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("a number is a number:");</div>
        <div class="codeLine">echo(is_num(0.1));</div>
        <div class="codeLine">echo(is_num(1));</div>
        <div class="codeLine">echo(is_num(10));</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo("inf is a number:");</div>
        <div class="codeLine">echo(is_num(+1/0)); //+inf</div>
        <div class="codeLine">echo(is_num(-1/0)); //-inf</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo("nan is not a number:");</div>
        <div class="codeLine">echo(is_num(0/0)); //nan</div>
        <div class="codeLine">echo(is_num((1/0)/(1/0))); //nan</div>
        <div class="codeLine">​</div>
        <div class="codeLine">echo("resulting in false:");</div>
        <div class="codeLine">echo(is_num([]));</div>
        <div class="codeLine">echo(is_num([1]));</div>
        <div class="codeLine">echo(is_num("test"));</div>
        <div class="codeLine">echo(is_num(false));</div>
        <div class="codeLine">echo(is_num(undef));</div>
    </div>
    <h3><a name="isbool"></a>is_bool</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("resulting in true:");</div>
        <div class="codeLine">echo(is_bool(true));</div>
        <div class="codeLine">echo(is_bool(false));</div>
        <div class="codeLine">echo("resulting in false:");</div>
        <div class="codeLine">echo(is_bool([]));</div>
        <div class="codeLine">echo(is_bool([1]));</div>
        <div class="codeLine">echo(is_bool("test"));</div>
        <div class="codeLine">echo(is_bool(0.1));</div>
        <div class="codeLine">echo(is_bool(1));</div>
        <div class="codeLine">echo(is_bool(10));</div>
        <div class="codeLine">echo(is_bool(0/0)); //nan</div>
        <div class="codeLine">echo(is_bool((1/0)/(1/0))); //nan</div>
        <div class="codeLine">echo(is_bool(1/0)); //inf</div>
        <div class="codeLine">echo(is_bool(-1/0)); //-inf</div>
        <div class="codeLine">echo(is_bool(undef));</div>
    </div>
    <h3><a name="isstring"></a>is_string</h3>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <div class="CodeMirror-code">
        <div class="codeLine">echo("resulting in true:");</div>
        <div class="codeLine">echo(is_string(""));</div>
        <div class="codeLine">echo(is_string("test"));</div>
        <div class="codeLine">echo("resulting in false:");</div>
        <div class="codeLine">echo(is_string(0.1));</div>
        <div class="codeLine">echo(is_string(1));</div>
        <div class="codeLine">echo(is_string(10));</div>
        <div class="codeLine">echo(is_string([]));</div>
        <div class="codeLine">echo(is_string([1]));</div>
        <div class="codeLine">echo(is_string(false));</div>
        <div class="codeLine">echo(is_string(0/0)); //nan</div>
        <div class="codeLine">echo(is_string((1/0)/(1/0))); //nan</div>
        <div class="codeLine">echo(is_string(1/0)); //inf</div>
        <div class="codeLine">echo(is_string(-1/0)); //-inf</div>
        <div class="codeLine">echo(is_string(undef));</div>
    </div>
    <hr />
    <h1><a name="openscad用户手册用户自定义函数及模块"></a>OpenSCAD用户手册/用户自定义函数及模块</h1>
    <h3><a name="目录-n5009"></a>目录</h3>
    <ul>
        <li><a href="#介绍">1 介绍</a></li>
        <li><a href="#作用域">2 作用域</a></li>
        <li> 3 函数
            <ul>
                <li><a href="#递归函数">3.1 递归函数</a></li>
            </ul>
        </li>
        <li> 4 模块
            <ul>
                <li><a href="#对象模块">4.1 对象模块</a></li>
                <li><a href="#运算符模块">4.2 运算符模块</a></li>
                <li><a href="#children">4.3 Children</a></li>
                <li><a href="#更多的模块示例">4.4 更多的模块示例</a></li>
                <li><a href="#递归模块">4.5 递归模块</a></li>
            </ul>
        </li>
        <li><a href="#覆写内建模块">5 覆写内建模块</a></li>
        <li><a href="#覆写内建函数">6 覆写内建函数</a></li>
    </ul>
    <h3><a name="介绍"></a>介绍</h3>
    <hr />
    <p>用户可通过定义自己的模块与函数来扩展OpenSCAD语言。利用此功能可组合多个的脚本片段，便于用户以不同的数值对其进行复用。选取合适的名称有助于您对自己的脚本进行文档化。</p>
    <p>OpenSCAD提供了:</p>
    <p>OpenSCAD在编译时计算变量的值，而非运行时。 在作用域中为变量最后一次赋的值将应用于整个作用域中。此值还可用于其内部域或子域中。 参见<a href="#变量的作用域">变量的作用域</a>来获取更多细节。将OpenSCAD中的变量想象为可重写（override-able）的常量而不是传统意义上的变量或许有助于您对此概念理解。</p>
    <p>对于函数与模块而言，OpenSCAD会为每次使用的脚本内容制作一个副本。每个副本都有其自己的作用域，其中存有变量的固定值与唯一用于对应实例的表达式。</p>
    <p>函数或模块的名称对大小写敏感，因此<strong>test()</strong> 与 <strong>TEST()</strong> 是两种不同的函数/模块。</p>
    <h3><a name="作用域"></a>作用域</h3>
    <p>可以在一个模块内定义模块与函数，它们仅在那个模块的作用域中可见。</p>
    <p>例如</p>
    <p><img src="img/220px-Parabola_Openscad_plot.jpg"></p>
    <div class="CodeMirror-code">
        <div class="codeLine">function parabola(f,x) = ( 1/(4*f) ) * x*x; </div>
        <div class="codeLine">module plotParabola(f,wide,steps=1) {</div>
        <div class="codeLine"> function y(x) = parabola(f,x);</div>
        <div class="codeLine"> module &nbsp; plot(x,y) {</div>
        <div class="codeLine"> &nbsp; translate([x,y])</div>
        <div class="codeLine"> &nbsp; &nbsp; circle(1,$fn=12);</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> xAxis=[-wide/2:steps:wide/2];</div>
        <div class="codeLine"> for (x=xAxis) </div>
        <div class="codeLine"> &nbsp; plot(x,y(x));</div>
        <div class="codeLine">}</div>
        <div class="codeLine">color("red") plotParabola(10,100,5);</div>
        <div class="codeLine">color("blue") plotParabola(4,60,2);</div>
    </div>
    <p>不能在全局作用域中调用函数y()与模块plot()。</p>
    <h3><a name="函数"></a>函数</h3>
    <hr />
    <p>函数会针对数值进行计算并返回新值。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function name ( parameters ) = value ;</div>
        <div class="codeLine">// 示例1</div>
        <div class="codeLine"> &nbsp; &nbsp;</div>
        <div class="codeLine">function func0() = 5;</div>
        <div class="codeLine">function func1(x=3) = 2*x+1;</div>
        <div class="codeLine">function func2() = [1,2,3,4];</div>
        <div class="codeLine">function func3(y=7) = (y==7) ? 5 : 2 ;</div>
        <div class="codeLine">function func4(p0,p1,p2,p3) = [p0,p1,p2,p3];</div>
        <div class="codeLine"> &nbsp; &nbsp;</div>
        <div class="codeLine">echo (func0()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 5</div>
        <div class="codeLine">a = &nbsp; func1(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 7</div>
        <div class="codeLine">b= &nbsp; func1(5); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 11</div>
        <div class="codeLine">echo (func2()); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [1, 2, 3, 4]</div>
        <div class="codeLine">echo( func3(2),func3()); // 2, 5</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">z= func4(func0(),func1(),func2(),func3()); // [5, 7, [1, 2, 3, 4], 5]</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">translate([0,-4*func0(),0])cube([func0(),2*func0(),func0()]);</div>
        <div class="codeLine">// 与translate([0,-20,0])cube([5,10,5]);等效</div>
        <div class="codeLine">// 示例2 &nbsp; creates for() range to give desired no of steps to cover range</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">function steps( start, no_steps, end) = [start:(end-start)/(no_steps-1):end];</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">echo( steps(10,3,5)); &nbsp; &nbsp; &nbsp; &nbsp; // [10 : -2.5 : 5]</div>
        <div class="codeLine">for( i=steps(10,3,5))echo(i); // 10 7.5 5</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">echo(steps(10,3,15)); &nbsp; &nbsp; &nbsp; &nbsp; //[10 : 2.5 : 15]</div>
        <div class="codeLine">for( i=steps(10,3,15))echo(i); // 10 12.5 15</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">echo(steps(0,5,5)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [0 : 1.25 : 5]</div>
        <div class="codeLine">for( i=steps(0,5,5))echo(i); &nbsp; // 0 1.25 2.5 3.75 5</div>
    </div>
    <p><img src="img/220px-OpenScad_func_ex1_Rhomboid.jpg"></p>
    <p>示例3</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// 示例3 &nbsp; &nbsp; rectangle with top pushed over, keeping same y</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">function rhomboid(x=1,y=1,angle=90)</div>
        <div class="codeLine"> = [[0,0],[x,0],</div>
        <div class="codeLine"> &nbsp; [x+x*cos(angle)/sin(angle),y],</div>
        <div class="codeLine"> &nbsp; [x*cos(angle)/sin(angle),y]];</div>
        <div class="codeLine"> &nbsp; &nbsp;</div>
        <div class="codeLine">echo (v1); v1 = rhomboid(10,10,35); // [[0, 0], </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// [10, 0], </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// [24.2815, 10],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// [14.2815, 10]]</div>
        <div class="codeLine">polygon(v1);</div>
        <div class="codeLine">polygon(rhomboid(10,10,35)); &nbsp; &nbsp; &nbsp; &nbsp; // alternate</div>
        <div class="codeLine">//performing the same action with a module</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">module parallelogram(x=1,y=1,angle=90)</div>
        <div class="codeLine"> &nbsp; {polygon([[0,0],[x,0],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [x+x*cos(angle)/sin(angle),y],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [x*cos(angle)/sin(angle),y]]);};</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">parallelogram(10,10,35);</div>
    </div>
    <p>您也可以使用<strong>let</strong>语句：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function get_square_triangle_perimeter(p1, p2) =</div>
        <div class="codeLine"> &nbsp; let(hypotenuse=sqrt(p1*p1+p2*p2))</div>
        <div class="codeLine"> &nbsp; p1+p2+hypotenuse;</div>
    </div>
    <p>可用它在递归函数中保存变量。</p>
    <h3><a name="递归函数"></a>递归函数</h3>
    <p>OpenSCAD支持调用<a target="wikibook" href="https://zh.wikipedia.org/wiki/recursion_(computer_science)">递归</a>函数。利用条件运算符&quot;...
        <strong>?</strong> ... <strong>:</strong> ... &quot;来保证递归可终止。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> // 递归示例：将所有整数累加至n</div>
        <div class="codeLine"> function add_up_to(n) = ( n==0 ? 0 : n + add_up_to(n-1) );</div>
    </div>
    <p>OpenSCAD为防止应用崩溃而设置了内建递归限制（大约几千）。如果达到此上限，您将得到这样的错误消息：ERROR: Recursion detected calling function ... 。For some special cases of <a target="wikibook"href="https://zh.wikipedia.org/wiki/Tail_call">tail-recursive</a> functions, OpenSCAD is able to eliminate internally the recursion transformingit in an iterative loop. The special forms are:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function recurse(...) = &lt;test&gt; ? &lt;result&gt; : recurse(...);</div>
    </div>
    <p>and</p>
    <div class="CodeMirror-code">
        <div class="codeLine">function recurse(...) = &lt;test&gt; ? recurse(...) : &lt;result&gt;;</div>
    </div>
    <p>The previous example code does not match any of these forms. But the following is entitled to tail-recursion elimination:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">// tail-recursion elimination example: add all integers up to n</div>
        <div class="codeLine">function add_up_to(n, sum=0) =</div>
        <div class="codeLine"> &nbsp; n==0 ?</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; sum :</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; add_up_to(n-1, sum+n);</div>
        <div class="codeLine"> </div>
        <div class="codeLine">echo(sum=add_up_to(100000));</div>
        <div class="codeLine">// ECHO: sum = 5.00005e+009</div>
    </div>
    <p>Tail-recursion elimination allows much higher recursion limits.</p>
    <h3><a name="模块"></a>模块</h3>
    <p>模块可用于定义对象、运算符，或使用children()。 模块一旦定义，就可以将其临时添加至语言特性中。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module name ( parameters ) { actions }</div>
    </div>
    <p>Variables can be assigned, but their scope is limited to within each individual use of the module. There is no mechanism in OpenSCAD for modules toreturn values to the outside. See Scope of variables for more details.</p>
    <h3><a name="对象模块"></a>对象模块</h3>
    <p>Object modules use one or more primitives, with associated operators, to define new objects.</p>
    <p>In use, object modules are actions ending with a semi-colon &#39;;&#39;.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">name ( parameter values );</div>
    </div>
    <p><img src="img/OpenScad_Module_ex1_Color_bar.jpg"></p>
    <p>Color bar</p>
    <div class="CodeMirror-code">
        <div class="codeLine">//示例1</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">translate([-30,-20,0])</div>
        <div class="codeLine"> &nbsp; ShowColorBars(Expense);</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">ColorBreak=[[0,""],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [20,"lime"], // upper limit of color range</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [40,"greenyellow"],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [60,"yellow"],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [75,"LightCoral"],</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [200,"red"]];</div>
        <div class="codeLine">Expense=[16,20,25,85,52,63,45];</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">module ColorBar(value,period,range){ // 1 color on 1 bar</div>
        <div class="codeLine"> &nbsp; RangeHi = ColorBreak[range][0];</div>
        <div class="codeLine"> &nbsp; RangeLo = ColorBreak[range-1][0];</div>
        <div class="codeLine"> &nbsp; color( ColorBreak[range][1] ) </div>
        <div class="codeLine"> &nbsp; translate([10*period,0,RangeLo])</div>
        <div class="codeLine"> &nbsp; &nbsp; if (value &gt; RangeHi) &nbsp; &nbsp; cube([5,2,RangeHi-RangeLo]);</div>
        <div class="codeLine"> &nbsp; &nbsp; else if (value &gt; RangeLo) cube([5,2,value-RangeLo]);</div>
        <div class="codeLine"> } &nbsp;</div>
        <div class="codeLine">module ShowColorBars(values){</div>
        <div class="codeLine"> &nbsp; for (month = [0:len(values)-1], range = [1:len(ColorBreak)-1])</div>
        <div class="codeLine"> &nbsp; &nbsp; ColorBar(values[month],month,range);</div>
        <div class="codeLine">}</div>
    </div>
    <p><img src="img/220px-OpenScad_module_ex2_House.jpg"></p>
    <p>House</p>
    <div class="CodeMirror-code">
        <div class="codeLine">//示例2</div>
        <div class="codeLine">module house(roof="flat",paint=[1,0,0]) {</div>
        <div class="codeLine"> &nbsp; color(paint)</div>
        <div class="codeLine"> &nbsp; if(roof=="flat") { translate([0,-1,0]) cube(); }</div>
        <div class="codeLine"> &nbsp; else if(roof=="pitched") {</div>
        <div class="codeLine"> &nbsp; &nbsp; rotate([90,0,0]) linear_extrude(height=1)</div>
        <div class="codeLine"> &nbsp; &nbsp; polygon(points=[[0,0],[0,1],[0.5,1.5],[1,1],[1,0]]); }</div>
        <div class="codeLine"> &nbsp; else if(roof=="domical") {</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([0,-1,0]){</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([0.5,0.5,1]) sphere(r=0.5,$fn=20); cube(); }</div>
        <div class="codeLine">} }</div>
        <div class="codeLine">​</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; house();</div>
        <div class="codeLine">translate([2,0,0]) house("pitched");</div>
        <div class="codeLine">translate([4,0,0]) house("domical",[0,1,0]);</div>
        <div class="codeLine">translate([6,0,0]) house(roof="pitched",paint=[0,0,1]);</div>
        <div class="codeLine">translate([0,3,0]) house(paint=[0,0,0],roof="pitched");</div>
        <div class="codeLine">translate([2,3,0]) house(roof="domical");</div>
        <div class="codeLine">translate([4,3,0]) house(paint=[0,0.5,0.5]);</div>
        <div class="codeLine">//example 3</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">element_data = [[0,"","",0], // must be in order</div>
        <div class="codeLine"> &nbsp; [1,"Hydrogen","H",1.008], &nbsp; // indexed via atomic number</div>
        <div class="codeLine"> &nbsp; [2,"Helium", "He",4.003] &nbsp; // redundant atomic number to preserve your sanity later</div>
        <div class="codeLine">];</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">Hydrogen = 1;</div>
        <div class="codeLine">Helium &nbsp; = 2;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp;</div>
        <div class="codeLine">module coaster(atomic_number){</div>
        <div class="codeLine"> &nbsp; element &nbsp; &nbsp; = element_data[atomic_number][1];</div>
        <div class="codeLine"> &nbsp; symbol &nbsp; &nbsp; = element_data[atomic_number][2];</div>
        <div class="codeLine"> &nbsp; atomic_mass = element_data[atomic_number][3];</div>
        <div class="codeLine"> &nbsp; //rest of script</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="运算符模块"></a>运算符模块</h3>
    <p>Use of children() allows modules to act as operators applied to any or all of the objects within this module instantiation. In use, operator modulesdo not end with a semi-colon.</p>
    <div class="CodeMirror-code">
        <div class="codeLine">name ( parameter values ){scope of operator}</div>
    </div>
    <h3><a name="children"></a>Children</h3>
    <p>Objects are indexed via integers from 0 to $children-1. OpenSCAD sets $children to the total number of objects within the scope. Objects grouped intoa sub scope are treated as one child. <a href="#separatechildren">See example of separate children</a> below and Scope of variables. Note that
        <code>children()</code>, <code>echo()</code> and empty block statements (including <code>if</code>s) count as <code>$children</code> objects, evenif no geometry is present (as of v2017.12.23).</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> children(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all children</div>
        <div class="codeLine"> children(index); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value or variable to select one child</div>
        <div class="codeLine"> children([start : step : end]); &nbsp; &nbsp; select from start to end incremented by step</div>
        <div class="codeLine"> children([start : end]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; step defaults to 1 or -1</div>
        <div class="codeLine"> children([vector]); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selection of several children</div>
    </div>
    <p><strong>废止的child()模块</strong></p>
    <p>Up to release 2013.06 the now deprecated <code>child()</code> module was used instead. This can be translated to the new children() according to thetable:</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th style="text-align:center;">up to 2013.06</th>
                    <th style="text-align:center;">2014.03 and later</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="text-align:center;">child()</td>
                    <td style="text-align:center;">children(0)</td>
                </tr>
                <tr>
                    <td style="text-align:center;">child(x)</td>
                    <td style="text-align:center;">children(x)</td>
                </tr>
                <tr>
                    <td style="text-align:center;">for (a = [0:$children-1]) child(a)</td>
                    <td style="text-align:center;">children([0:$children-1])</td>
                </tr>
            </tbody>
        </table>
    </figure>
    <p><img src="img/220px-OpenSCAD_Manual_Modules_Module_move.jpg"></p>
    <p>Use all children</p>
    <p><em>示例</em></p>
    <div class="CodeMirror-code">
        <div class="codeLine">//Use all children</div>
        <div class="codeLine"> &nbsp; &nbsp;</div>
        <div class="codeLine">module move(x=0,y=0,z=0,rx=0,ry=0,rz=0)</div>
        <div class="codeLine">{ translate([x,y,z])rotate([rx,ry,rz]) children(); }</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">move(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cube(10,true);</div>
        <div class="codeLine">move(-10) &nbsp; &nbsp; &nbsp; &nbsp; cube(10,true);</div>
        <div class="codeLine">move(z=7.07, ry=45)cube(10,true);</div>
        <div class="codeLine">move(z=-7.07,ry=45)cube(10,true);</div>
    </div>
    <p><img src="img/220px-OpenSCAD_Manual_Modules_Module_lineuo.jpg"></p>
    <p>Use only the first child, multiple times</p>
    <div class="CodeMirror-code">
        <div class="codeLine">//Use only the first child, multiple times</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">module lineup(num, space) {</div>
        <div class="codeLine"> &nbsp; for (i = [0 : num-1])</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([ space*i, 0, 0 ]) children(0);</div>
        <div class="codeLine">}</div>
        <div class="codeLine">​</div>
        <div class="codeLine">lineup(5, 65){ sphere(30);cube(35);}</div>
    </div>
    <p><img src="img/400px-OpenSCAD_Manual_Modules_Module_SeparateChildren.jpg"></p>
    <p>Separate action for each child</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> //Separate action for each child</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine"> module SeparateChildren(space){</div>
        <div class="codeLine"> &nbsp; for ( i= [0:1:$children-1]) &nbsp; // step needed in case $children &lt; 2 &nbsp;</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([i*space,0,0]) {children(i);text(str(i));}</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine"> SeparateChildren(-20){</div>
        <div class="codeLine"> &nbsp; cube(5); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 0</div>
        <div class="codeLine"> &nbsp; sphere(5); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 1</div>
        <div class="codeLine"> &nbsp; translate([0,20,0]){ // 2</div>
        <div class="codeLine"> &nbsp; &nbsp; cube(5);</div>
        <div class="codeLine"> &nbsp; &nbsp; sphere(5);</div>
        <div class="codeLine"> &nbsp; } &nbsp; &nbsp; </div>
        <div class="codeLine"> &nbsp; cylinder(15); &nbsp; &nbsp; &nbsp; &nbsp; // 3</div>
        <div class="codeLine"> &nbsp; cube(8,true); &nbsp; &nbsp; &nbsp; &nbsp; // 4</div>
        <div class="codeLine"> }</div>
        <div class="codeLine"> translate([0,40,0])color("lightblue")</div>
        <div class="codeLine"> &nbsp; SeparateChildren(20){cube(3,true);}</div>
    </div>
    <p><img src="img/220px-OpenSCAD_Manual_Modules_Module_MultiRange.jpg"></p>
    <p>Multiple ranges</p>
    <div class="CodeMirror-code">
        <div class="codeLine">//Multiple ranges</div>
        <div class="codeLine">module MultiRange(){</div>
        <div class="codeLine"> &nbsp; color("lightblue") children([0:1]);</div>
        <div class="codeLine"> &nbsp; color("lightgreen")children([2:$children-2]);</div>
        <div class="codeLine"> &nbsp; color("lightpink") children($children-1);</div>
        <div class="codeLine">}</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">MultiRange()</div>
        <div class="codeLine">{</div>
        <div class="codeLine"> &nbsp; cube(5); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 0</div>
        <div class="codeLine"> &nbsp; sphere(5); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 1</div>
        <div class="codeLine"> &nbsp; translate([0,20,0]){ // 2</div>
        <div class="codeLine"> &nbsp; &nbsp; cube(5);</div>
        <div class="codeLine"> &nbsp; &nbsp; sphere(5);</div>
        <div class="codeLine"> &nbsp; } &nbsp; &nbsp; </div>
        <div class="codeLine"> &nbsp; cylinder(15); &nbsp; &nbsp; &nbsp; &nbsp; // 3</div>
        <div class="codeLine"> &nbsp; cube(8,true); &nbsp; &nbsp; &nbsp; &nbsp; // 4</div>
        <div class="codeLine">}</div>
    </div>
    <h3><a name="更多的模块示例"></a>更多的模块示例</h3>
    <div class="CodeMirror-code">
        <div class="codeLine">module arrow(){</div>
        <div class="codeLine"> &nbsp; cylinder(10);</div>
        <div class="codeLine"> &nbsp; cube([4,.5,3],true);</div>
        <div class="codeLine"> &nbsp; cube([.5,4,3],true);</div>
        <div class="codeLine"> &nbsp; translate([0,0,10]) cylinder(4,2,0,true);</div>
        <div class="codeLine">}</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">module cannon(){</div>
        <div class="codeLine"> &nbsp; difference(){union()</div>
        <div class="codeLine"> &nbsp; &nbsp; {sphere(10);cylinder(40,10,8);} cylinder(41,4,4);</div>
        <div class="codeLine">} }</div>
        <div class="codeLine"> &nbsp;</div>
        <div class="codeLine">module base(){</div>
        <div class="codeLine"> &nbsp; difference(){</div>
        <div class="codeLine"> &nbsp; &nbsp; cube([40,30,20],true);</div>
        <div class="codeLine"> &nbsp; &nbsp; translate([0,0,5]) cube([50,20,15],true);</div>
        <div class="codeLine">} }</div>
    </div>
    <p><img src="img/800px-OpenSCAD_Manual_Modules_Module_RotaryCluster_v2.jpg"></p>
    <p>Rotary Clusters</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module aim(elevation,azimuth=0)</div>
        <div class="codeLine"> &nbsp; { rotate([0,0,azimuth])</div>
        <div class="codeLine"> &nbsp; &nbsp; { rotate([0,90-elevation,0]) children(0);</div>
        <div class="codeLine"> &nbsp; &nbsp; children([1:1:$children-1]); &nbsp; // step needed in case $children &lt; 2</div>
        <div class="codeLine">} }</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">aim(30,20)arrow();</div>
        <div class="codeLine">aim(35,270)cannon();</div>
        <div class="codeLine">aim(15){cannon();base();}</div>
        <div class="codeLine">​</div>
        <div class="codeLine">module RotaryCluster(radius=30,number=8)</div>
        <div class="codeLine"> &nbsp; for (azimuth =[0:360/number:359])</div>
        <div class="codeLine"> &nbsp; &nbsp; rotate([0,0,azimuth]) &nbsp; &nbsp;</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; translate([radius,0,0]) { children();</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; translate([40,0,30]) text(str(azimuth)); }</div>
        <div class="codeLine"> &nbsp; </div>
        <div class="codeLine">RotaryCluster(200,7) color("lightgreen") aim(15){cannon();base();}</div>
        <div class="codeLine">rotate([0,0,110]) RotaryCluster(100,4.5) aim(35)cannon();</div>
        <div class="codeLine">color("LightBlue")aim(55,30){cannon();base();}</div>
    </div>
    <h3><a name="递归模块"></a>递归模块</h3>
    <p>Like functions, modules may contain recursive calls. However, there is no tail-recursion elimination for recursive modules.</p>
    <p>The code below generates a crude model of a tree. Each tree branch is itself a modified version of the tree and produced by recursion. Be careful tokeep the recursion depth (branching) n below 7 as the number of primitives and the preview time grow exponentially.</p>
    <p><img src="img/Simple_recursive_tree.png"></p>
    <p>A simple tree created with a recursive OpenSCAD module</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> &nbsp; module simple_tree(size, dna, n) { &nbsp; </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; if (n &gt; 0) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // trunk</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cylinder(r1=size/10, r2=size/12, h=size, $fn=24);</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // branches</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translate([0,0,size])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(bd = dna) {</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; angx = bd[0];</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; angz = bd[1];</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scal = bd[2];</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rotate([angx,0,angz])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; simple_tree(scal*size, dna, n-1);
        </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; }</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; else // leaves</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color("green")</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scale([1,1,3])</div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translate([0,0,size/6]) </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rotate([90,0,0]) </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cylinder(r=size/6,h=size/10);</div>
        <div class="codeLine"> &nbsp; }</div>
        <div class="codeLine"> &nbsp; // dna is a list of branching data bd of the tree:</div>
        <div class="codeLine"> &nbsp; // &nbsp; &nbsp; bd[0] - inclination of the branch</div>
        <div class="codeLine"> &nbsp; // &nbsp; &nbsp; bd[1] - Z rotation angle of the branch</div>
        <div class="codeLine"> &nbsp; // &nbsp; &nbsp; bd[2] - relative scale of the branch</div>
        <div class="codeLine"> &nbsp; dna = [ [12, 80, 0.85], [55, &nbsp; 0, 0.6], </div>
        <div class="codeLine"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [62, 125, 0.6], [57, -125, 0.6] ];</div>
        <div class="codeLine"> &nbsp; simple_tree(50, dna, 5);</div>
    </div>
    <p>Another example of recursive module may be found in <a target="wikibook"href="https://zh.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Tips_and_Tricks&amp;action=edit&amp;redlink=1">Tips and Tricks</a></p>
    <h3><a name="覆写内建模块"></a>覆写内建模块</h3>
    <p>It is possible to overwrite the built-in modules.</p>
    <p>A simple, but pointless example would be:</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module sphere(){</div>
        <div class="codeLine"> &nbsp; square();</div>
        <div class="codeLine">}</div>
        <div class="codeLine">sphere();</div>
    </div>
    <p>Note that the built-in sphere module can not be called when over written.</p>
    <p>A more sensible way to use this language feature is to overwrite the 3D primitives with extruded 2D-primitives. This allows additional to customizethe default parameters and to add additional parameters.</p>
    <h3><a name="覆写内建函数"></a>覆写内建函数</h3>
    <p>It is possible to overwrite the built-in functions.</p>
    <figure>
        <table>
            <thead>
                <tr>
                    <th style="text-align:center;">Source Code</th>
                    <th style="text-align:center;">Console output</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="text-align:center;"><code>echo (sin(1)); function sin() = true; echo (sin(1));</code></td>
                    <td style="text-align:center;"><code>Compiling design (CSG Tree generation)... ECHO: true ECHO: true Compiling design (CSG Productsgeneration)...</code></td>
                </tr>
            </tbody>
        </table>
    </figure>
    <hr />
    <h1><a name="openscad用户手册svg导入"></a>OpenSCAD用户手册/SVG导入</h1>
    <h3><a name="目录-n5156"></a>目录</h3>
    <ul>
        <li> 1 SVG Import
            <ul>
                <li><a href="#限制">1.1 限制</a></li>
                <li><a href="#viewbox的处理">1.2 ViewBox的处理</a></li>
                <li><a href="#dpi的处理">1.3 DPI的处理</a></li>
                <li><a href="#开放图形与闭合图形">1.4 开放图形与闭合图形</a></li>
            </ul>
        </li>
    </ul>
    <h2><a name="svg-import"></a>SVG Import</h2>
    <p><strong>[请注意: *需要使用版本 *<em>2019.05*</em>*]</strong></p>
    <p>OpenSCAD可以导入SVG文件中的几何结构。</p>
    <div class="CodeMirror-code">
        <div class="codeLine"> import("file.svg");</div>
        <div class="codeLine"> import(file = "file.svg", center = false, dpi = 96);</div>
    </div>
    <p><strong>参数</strong></p>
    <ul>
        <li> file - 字符串。要导入的文件名。</li>
        <li> center - 布尔值。如果设置为true，则被导入的几何体将根据它的包围体进行居中对齐。</li>
        <li> dpi - 双精度浮点值。如果并未为宽度/高度指定单位，则利用此DPI值计算viewbox的大小。如果连宽度/高度也未给出，则用viewbox加以替代(例如，对于AdobeIllustrator早期版本所创建的文件即是如此)。如果指定了宽度/高度的绝对单位(px/pt/pc/in/mm/cm)则忽略此DPI值。</li>
    </ul>
    <h3><a name="限制"></a>限制</h3>
    <p>顾名思义，<a target="wikibook" href="https://zh.wikipedia.org/wiki/Scalable_Vector_Graphics">可缩放矢量图形（Scalable VectorGraphics，简作SVG）</a>被设计为一种可渲染在网页上且支持交互与动画的可缩放图形格式。</p>
    <p>这就意味着部分特性不能较好地转换至CAD格式加以使用。在此过程中，SVG文件中的所有的动画功能与大多可视属性将统统被忽略掉。通常情况下，OpenSCAD会准确地导入SVG中各对象的核心几何信息，并将其转换为闭合的2D多边形。</p>
    <p>不会被导入的主要特性有：</p>
    <ul>
        <li>文本 / 字体</li>
        <li>裁剪与遮罩（Clipping and Masking）</li>
        <li>使用模板的对象</li>
    </ul>
    <h3><a name="viewbox的处理"></a>ViewBox的处理</h3>
    <p>SVG文件的<a href="#viewboxattribute">ViewBox</a>属性定义了用来展示其内容的初始坐标系。OpenSCAD导入器支持包括preserveAspectRatio属性在内的变换。<a target="wikibook"href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/">理解SVG坐标系及其变换</a>一文中详细讲解了viexBox所有相关属性的组合显示效果。</p>
    <h3><a name="dpi的处理"></a>DPI的处理</h3>
    <h3><a name="开放图形与闭合图形"></a>开放图形与闭合图形</h3>
    <p>OpenSCAD仅处理闭合多边形，因此并不能导入线段与开放多边形。而是把开放多边形看作是由其stroke-width（线宽）定义的图形。</p>
    <p>闭合图形总是采用SVG文件中定义的几何规格（geometric specification）而忽略其中的fill（填充）与stroke-with。</p>
    <p><img src="img/200px-OpenSCAD_svg-import_circles-and-arcs.svg.png"></p>
    <p>Inkscape中的SVG</p>
    <p><img src="img/200px-OpenSCAD_svg-import_circles-and-arcs_%28OpenSCAD%29.png"></p>
    <p>导入OpenSCAD中的SVG</p>
    <p>闭合图形忽略fill与stroke-width，而开放路径则采用stroke-width生成图形的轮廓。</p>
    <a target="wikibook" href="https://zh.wikibooks.org/wiki/Special:页面分类">分</a>
    <hr />
    <h1><a name="openscad用户手册stl导出"></a>OpenSCAD用户手册/STL导出</h1>
    <h3><a name="导出"></a>导出</h3>
    <p>通过F6键渲染图像后，可利用&quot;File --&gt; Export&quot;菜单将其导出为STL, OFF, AMF, DXF, SVG, CSG 或 PNG 格式文件 (图像)。</p>
    <p>请确保检查过控制台窗口的错误消息。</p>
    <ul>
        <li>利用<code>import()</code>导入STL, OFF 与 DXF 格式文件</li>
        <li>可利用<code>include&lt;&gt;</code>导入CSG 格式文件，或像普通的SCAD文件那样来加载它</li>
        <li>可利用<code>surface()</code>导入PNG 格式文件</li>
        <li>已开放针对SVG 与 AMF 格式文件的pull请求，但还需要进行更多的编码工作与测试</li>
        <li>文件后缀用于确定其具体类型</li>
    </ul>
    <h3><a name="stl导出"></a>STL导出</h3>
    <p>为了导出您的设计图，请从&quot;File --&gt; Export&quot;菜单里选中&quot;Export as STL...&quot;，再于弹出的对话框中输入文件名。别忘了添加&quot;.stl&quot;扩展名。</p>
    <p><strong>疑难解答</strong>:</p>
    <p>（译注：此部分请具体版本具体分析！）</p>
    <p>在执行<em>compile and render CGAL</em> (F6)后，您可能会看到您的设计报告中有这样一项 <em>simple: no</em>。嗯……这并不是一个好消息。</p>
    <p>参见以下<em>OpenSCAD 2010.02</em>版输出信息中的第8行：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">Parsing design (AST generation)...</div>
        <div class="codeLine">Compiling design (CSG Tree generation)...</div>
        <div class="codeLine">Compilation finished.</div>
        <div class="codeLine">Rendering Polygon Mesh using CGAL...</div>
        <div class="codeLine">Number of vertices currently in CGAL cache: 732</div>
        <div class="codeLine">Number of objects currently in CGAL cache: 12</div>
        <div class="codeLine"> &nbsp; Top level object is a 3D object:</div>
        <div class="codeLine"> &nbsp; Simple: &nbsp; &nbsp; &nbsp; &nbsp; no &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;*****************</div>
        <div class="codeLine"> &nbsp; Valid: &nbsp; &nbsp; &nbsp; &nbsp; yes</div>
        <div class="codeLine"> &nbsp; Vertices: &nbsp; &nbsp; &nbsp; 22</div>
        <div class="codeLine"> &nbsp; Halfedges: &nbsp; &nbsp; 70</div>
        <div class="codeLine"> &nbsp; Edges: &nbsp; &nbsp; &nbsp; &nbsp; 35</div>
        <div class="codeLine"> &nbsp; Halffacets: &nbsp; &nbsp; 32</div>
        <div class="codeLine"> &nbsp; Facets: &nbsp; &nbsp; &nbsp; &nbsp; 16</div>
        <div class="codeLine"> &nbsp; Volumes: &nbsp; &nbsp; &nbsp; &nbsp; 2</div>
        <div class="codeLine">Total rendering time: 0 hours, 0 minutes, 0 seconds</div>
        <div class="codeLine">Rendering finished.</div>
    </div>
    <p>当您试图导出.STL文件时，将得到下列信息：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">Object isn't a valid 2-manifold! Modify your design..</div>
    </div>
    <p>&quot;Manifold&quot;的意思是&quot;water tight（水密的）&quot;，也就是几何体中不存在孔洞。在一个有效的2-manifold图形中，每个边必须与两个面精确相连。这就意味着编写的程序必须能令一个面仅与一个对象相连。例如，如果您借助一个高为10的立方体，从另一个更宽的高为10的立方体中截去部分内容，则很难辨清顶或底中两立方体相交的部分究竟属于哪个立方体。因此，此时可以令被截去的小立方体“稍长”（或“稍短”）一些：
    </p>
    <div class="CodeMirror-code">
        <div class="codeLine">difference() {</div>
        <div class="codeLine">// 待截的原始立方体</div>
        <div class="codeLine">cube (size = [2,2,2]);</div>
        <div class="codeLine">// 被截去的立方体对象</div>
        <div class="codeLine"># translate ([0.5,0.5,-0.5]) {</div>
        <div class="codeLine"> &nbsp; cube (size = [1,1,3]);</div>
        <div class="codeLine">}</div>
        <div class="codeLine">}</div>
    </div>
    <p><img src="img/Openscad-difference-cube-example.png"></p>
    <p>difference的正确打开方式</p>
    <p><a target="wikibook" href="http://rocklinux.net/pipermail/openscad/2009-December/000018.html">OpenSCAD</a>论坛中(retrieved 15:13, 22 March 2010(UTC))还有一个取巧的范例：</p>
    <div class="CodeMirror-code">
        <div class="codeLine">module example1() {</div>
        <div class="codeLine">cube([20, 20, 20]);</div>
        <div class="codeLine">translate([-20, -20, 0]) cube([20, 20, 20]);</div>
        <div class="codeLine">cube([50, 50, 5], center = true);</div>
        <div class="codeLine">}</div>
        <div class="codeLine">module example2() {</div>
        <div class="codeLine">cube([20.1, 20.1, 20]);</div>
        <div class="codeLine">translate([-20, -20, 0]) cube([20.1, 20.1, 20]);</div>
        <div class="codeLine">cube([50, 50, 5], center = true);</div>
        <div class="codeLine">}</div>
    </div>
    <p>Example1的渲染效果如下：</p>
    <p><img src="img/Openscad-no-simple-object.png"></p>
    <p>一个非法的2-manifold立方体(simple = no)</p>
    <p><strong>example1</strong>模块是一个非法的2-manifold图形，这是因为两个立方体均共享了同一个边。两者互相爱抚却并没有相交。</p>
    <p><strong>Example2</strong>是一个合法的2-manifold图形，因为两个立方体相交了。此时，这模型满足了2-manifold的约束，保证了<em>每个边必须与两个面精确相连。</em></p>
    <p>在执行布尔减法时，必须保证减去的部分要超出被减去的部分。(<a target="wikibook"href="http://www.iheartrobotics.com/2010/01/openscad-tip-manifold-space-and-time.html">OpenSCAD使用小提示：Manifold空间与时间</a>, retrieved 18:40, 22March 2010 (UTC)).</p>
    <p>为了便于理解，这里给出另一不可导出设计的示例，本情景中，两个参与布尔减法运算的面互相接触。这将导致产生对应的错误信息。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">difference () {</div>
        <div class="codeLine"> &nbsp; cube ([20,10,10]);</div>
        <div class="codeLine"> &nbsp; translate ([10,0,0]) cube (10);</div>
        <div class="codeLine">}</div>
        <div class="codeLine">difference () {</div>
        <div class="codeLine"> &nbsp; cube ([20,10,10]);</div>
        <div class="codeLine"> &nbsp; cube (10);</div>
        <div class="codeLine">}</div>
    </div>
    <p>只需简单地令表面接触即可正确处理。</p>
    <div class="CodeMirror-code">
        <div class="codeLine">translate ([10,0,0]) cube (10);</div>
        <div class="codeLine">cube (10);</div>
    </div>
</div>
</body>

</html>
